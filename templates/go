// Package {{.PkgName}} was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package {{.PkgName}}

{{ $NotGObject := ne .PkgName "gobject" }}
{{ $NotGLib := ne .PkgName "glib" }}
{{ $HasSignals := false }}
{{ $HasDetailedSignals := false }}
{{range .Classes -}}
  {{if .Signals}}
    {{ $HasSignals = true }}
  {{end}}
  {{range .Signals}}
    {{if .Detailed}}
      {{ $HasDetailedSignals = true }}
    {{end}}
  {{end}}
{{end}}
{{ $HasCallbacks := or .HasReceiverCallbacks .HasFunctionCallbacks }}
{{ $NeedsUnsafe := or .Records $HasSignals $HasCallbacks }}
{{ $NeedsPurego := or .NeedsInit $HasSignals $HasCallbacks }}
{{ $NeedsCore := or .NeedsInit .NeedsCore }}
{{ $AnyImports := or $NeedsCore .Records $HasSignals $HasCallbacks $HasDetailedSignals }}

{{if $AnyImports}}
import (
{{- if $NeedsUnsafe}}
	"unsafe"
{{- end}}
{{- if $HasDetailedSignals}}
	"fmt"
{{- end}}
{{- if .Records}}
	"structs"
{{- end}}
{{- if $NeedsPurego}}
	"github.com/jwijenbergh/purego"
{{- end}}
{{- if $NeedsCore}}
	"github.com/jwijenbergh/puregotk/pkg/core"
{{- end}}
)
{{end}}

{{$outer := .}}

{{range .Callbacks -}}
{{.Doc}}
type {{.Name}} func({{ conv .Args.Pure.Types }}) {{.Ret.Raw}}
{{end}}

{{range .Records -}}
{{.Doc}}
type {{.Name}} struct {
     _ structs.HostLayout
     {{range .Fields}}
     {{.Name}} {{.Type}}
     {{end}}
}

{{if .TypeGetter}}
var x{{.Name}}GLibType func() types.GType
func {{.Name}}GLibType() types.GType {
	return x{{.Name}}GLibType()
}
{{end}}

func (x *{{.Name}}) GoPointer() uintptr {
     return uintptr(unsafe.Pointer(x))
}

{{$outer := .}}

{{range .Constructors -}}
var x{{.Name}} func({{conv .Args.Pure.Types}}) {{.Ret.Raw}}


{{.Doc}}
func {{.Name}}({{conv .Args.API.Full}}) {{.Ret.Return}} {
     {{.Ret.Preamble $NotGLib}}
     {{- /* Generate closure wrappers for callback parameters */}}
     {{range .Args.Callbacks}}
     var {{.Name}}Ref uintptr
     if {{.Name}} != nil {
          {{.Name}}Ptr := uintptr(unsafe.Pointer({{.Name}}))
          if cbRefPtr, ok := {{if $NotGLib}}glib.{{end}}GetCallback({{.Name}}Ptr); ok {
               {{.Name}}Ref = cbRefPtr
          } else {
               fcb := func({{range $i, $t := .PureTypes}}{{if $i}}, {{end}}arg{{$i}} {{$t}}{{end}}) {{.RetRaw}} {
                    cbFn := *{{.Name}}
                    {{if .RetRaw}}return {{end}}cbFn({{range $i, $t := .PureTypes}}{{if $i}}, {{end}}arg{{$i}}{{end}})
               }
               {{.Name}}Ref = purego.NewCallback(fcb)
               {{if $NotGLib}}glib.{{end}}SaveCallback({{.Name}}Ptr, {{.Name}}Ref)
          }
     }
     {{end}}
     {{if .Ret.Value}}cret :={{end}}x{{.Name}}({{convd .Args.API.CallWithRefs}})
     {{.Ret.Fmt $NotGObject}}
}
{{end}}

{{$outer := .}}
{{range .Receivers -}}
var x{{$outer.Name}}{{.Name}} func(uintptr {{convc .Args.Pure.Types}}) {{.Ret.Raw}}

{{.Doc}}
func (x *{{$outer.Name}}) {{.Name}}({{conv .Args.API.Full}}) {{.Ret.Return}} {
     {{.Ret.Preamble $NotGLib}}
     {{- /* Generate closure wrappers for callback parameters */}}
     {{range .Args.Callbacks}}
     var {{.Name}}Ref uintptr
     if {{.Name}} != nil {
          {{.Name}}Ptr := uintptr(unsafe.Pointer({{.Name}}))
          if cbRefPtr, ok := {{if $NotGLib}}glib.{{end}}GetCallback({{.Name}}Ptr); ok {
               {{.Name}}Ref = cbRefPtr
          } else {
               fcb := func({{range $i, $t := .PureTypes}}{{if $i}}, {{end}}arg{{$i}} {{$t}}{{end}}) {{.RetRaw}} {
                    cbFn := *{{.Name}}
                    {{if .RetRaw}}return {{end}}cbFn({{range $i, $t := .PureTypes}}{{if $i}}, {{end}}arg{{$i}}{{end}})
               }
               {{.Name}}Ref = purego.NewCallback(fcb)
               {{if $NotGLib}}glib.{{end}}SaveCallback({{.Name}}Ptr, {{.Name}}Ref)
          }
     }
     {{end}}
     {{if .Ret.Value}}cret :={{end}}x{{$outer.Name}}{{.Name}}(x.GoPointer() {{convcd .Args.API.CallWithRefs}})
     {{.Ret.Fmt $NotGObject}}
}
{{end}}

{{range .CallbackAccessors -}}
// Override{{.Name}} sets the "{{.CName}}" callback function.
{{if .Doc}}{{.Doc}}
{{end}}func (x *{{$outer.Name}}) Override{{.Name}}(cb {{.CallbackType}}) {
     if cb == nil {
          x.x{{.Name}} = 0
     } else {
          x.x{{.Name}} = purego.NewCallback(func({{conv .Args.Pure.Full}}) {{.Ret.Raw}} {
               {{if .Ret.Value}}{{if .Ret.Class}}ret := cb({{convcb .Args.Pure.Call}})
               if ret == nil {
                    return 0
               }
               return ret.GoPointer(){{else}}return cb({{convcb .Args.Pure.Call}}){{end}}{{else}}cb({{convcb .Args.Pure.Call}}){{end}}
          })
     }
}

// Get{{.Name}} gets the "{{.CName}}" callback function.
{{if .Doc}}{{.Doc}}
{{end}}func (x *{{$outer.Name}}) Get{{.Name}}() {{.CallbackType}} {
     if x.x{{.Name}} == 0 {
          return nil
     }
     var rawCallback func({{conv .Args.Pure.Full}}) {{.Ret.Raw}}
     purego.RegisterFunc(&rawCallback, x.x{{.Name}})
     return func({{conv .Args.API.Full}}) {{.Ret.Value}} {
          {{if .Ret.Value}}{{if .Ret.Class}}rawRet := rawCallback({{convcbne .Args.API.Call}})
          if rawRet == 0 {
               return nil
          }
          ret := {{.Ret.Instance}}
          ret.Ptr = rawRet
          return ret{{else}}return rawCallback({{convcbne .Args.API.Call}}){{end}}{{else}}rawCallback({{convcbne .Args.API.Call}}){{end}}
     }
}
{{end}}

{{end}}

{{range .Interfaces -}}
{{.Doc}}
type {{.Name}} interface {
     GoPointer() uintptr
     SetGoPointer(uintptr)
     {{range .Methods -}}
     {{.Name}}({{conv .Args.API.Full}}) {{.Ret.Return}}
     {{end}}
}

{{if .TypeGetter}}
var x{{.Name}}GLibType func() types.GType
func {{.Name}}GLibType() types.GType {
	return x{{.Name}}GLibType()
}
{{end}}

type {{.Name}}Base struct {
     Ptr uintptr
}

func (x *{{.Name}}Base) GoPointer() uintptr {
     if x == nil {
         return 0
     }
     return x.Ptr
}

func (x *{{.Name}}Base) SetGoPointer(ptr uintptr) {
     x.Ptr = ptr
}

{{$outer := .}}
{{range .Methods -}}
{{.Doc}}
func (x *{{$outer.Name}}Base) {{.Name}}({{conv .Args.API.Full}}) {{.Ret.Return}} {
     {{.Ret.Preamble $NotGLib}}
     {{if .Ret.Value}}cret := {{end}}{{.Namespace}}X{{.FullName}}(x.GoPointer() {{convcd .Args.API.Call}})
     {{.Ret.Fmt $NotGObject}}
}
{{end}}

{{range .Properties -}}
{{if .Writable}}
// SetProperty{{.Name}} sets the "{{.CName}}" property.
{{if .Doc}}{{.Doc}}
{{end}}func (x *{{$outer.Name}}Base) SetProperty{{.Name}}(value {{.GoType}}) {
	obj := {{if $NotGObject}}gobject.{{end}}Object{}
	obj.Ptr = x.GoPointer()
	var v {{if $NotGObject}}gobject.{{end}}Value
	{{if or (eq .GValueType "BoxedStrv") (eq .GValueType "BoxedByteArray") (eq .GValueType "BoxedPtrArray")}}v.Init({{propvset $NotGLib .GoType}}{{else}}v.Init({{propsset $NotGObject .GValueType .SetMethod}}){{end}}
	obj.SetProperty("{{.CName}}", &v)
}
{{end}}

{{if .Readable}}
// GetProperty{{.Name}} gets the "{{.CName}}" property.
{{if .Doc}}{{.Doc}}
{{end}}func (x *{{$outer.Name}}Base) GetProperty{{.Name}}() {{.GoType}} {
	obj := {{if $NotGObject}}gobject.{{end}}Object{}
	obj.Ptr = x.GoPointer()
	var v {{if $NotGObject}}gobject.{{end}}Value
	obj.GetProperty("{{.CName}}", &v)
	{{if or (eq .GValueType "BoxedStrv") (eq .GValueType "BoxedByteArray") (eq .GValueType "BoxedPtrArray")}}{{propvget .GoType}}{{else}}return {{propsget .GetMethod}}{{end}}
}
{{end}}
{{end}}

{{range .Methods -}}
var {{.Namespace}}X{{.FullName}} func(uintptr {{convc .Args.Pure.Types}}) {{.Ret.Raw}}
{{end}}
{{end}}

{{range .Aliases -}}
{{.Doc}}
type {{.Name}} = {{.Value}}
{{if .TypeGetter}}
var x{{.Name}}GLibType func() types.GType
func {{.Name}}GLibType() types.GType {
	return x{{.Name}}GLibType()
}
{{end}}
{{end}}

{{if .Constants -}}
const (
{{range .Constants -}}
	{{.Doc}}
	{{.Name}} {{.Type}} = {{.Value}}
{{end}}
)
{{end}}

{{range .Enums -}}
{{.Doc}}
type {{.Name}} int
{{if .TypeGetter}}
var x{{.Name}}GLibType func() types.GType
func {{.Name}}GLibType() types.GType {
	return x{{.Name}}GLibType()
}
{{end}}
const (
{{$outer := .}}
{{range .Values -}}
	{{.Doc}}
	{{.Name}} {{$outer.Name}} = {{.Value}}
{{end}}
)
{{end}}

{{range .Functions -}}
var x{{.Name}} func({{conv .Args.Pure.Types}}) {{.Ret.Raw}}

{{.Doc}}
func {{.Name}}({{conv .Args.API.Full}}) {{.Ret.Return}} {
     {{.Ret.Preamble $NotGLib}}
     {{- /* Generate closure wrappers for callback parameters */}}
     {{range .Args.Callbacks}}
     var {{.Name}}Ref uintptr
     if {{.Name}} != nil {
          {{.Name}}Ptr := uintptr(unsafe.Pointer({{.Name}}))
          if cbRefPtr, ok := {{if $NotGLib}}glib.{{end}}GetCallback({{.Name}}Ptr); ok {
               {{.Name}}Ref = cbRefPtr
          } else {
               fcb := func({{range $i, $t := .PureTypes}}{{if $i}}, {{end}}arg{{$i}} {{$t}}{{end}}) {{.RetRaw}} {
                    cbFn := *{{.Name}}
                    {{if .RetRaw}}return {{end}}cbFn({{range $i, $t := .PureTypes}}{{if $i}}, {{end}}arg{{$i}}{{end}})
               }
               {{.Name}}Ref = purego.NewCallback(fcb)
               {{if $NotGLib}}glib.{{end}}SaveCallback({{.Name}}Ptr, {{.Name}}Ref)
          }
     }
     {{end}}
     {{if .Ret.Value}}cret := {{end}}x{{.Name}}({{convd .Args.API.CallWithRefs}})
     {{.Ret.Fmt $NotGObject}}
}
{{end}}

{{range .Classes -}}
{{.Doc}}
type {{.Name}} struct {
     {{.Parent}}
     {{if not .Parent}}
     Ptr uintptr
     {{end}}
}

{{if .TypeGetter -}}
var x{{.Name}}GLibType func() types.GType
func {{.Name}}GLibType() types.GType {
	return x{{.Name}}GLibType()
}
{{end}}

{{$outer := .}}
func {{.Name}}NewFromInternalPtr(ptr uintptr) *{{.Name}} {
     cls := &{{.Name}}{}
     cls.Ptr = ptr
     return cls
}

{{range .Constructors -}}
var x{{.Name}} func({{conv .Args.Pure.Types}}) {{.Ret.Raw}}


{{.Doc}}
func {{.Name}}({{conv .Args.API.Full}}) {{.Ret.Return}} {
     {{.Ret.Preamble $NotGLib}}
     {{- /* Generate closure wrappers for callback parameters */}}
     {{range .Args.Callbacks}}
     var {{.Name}}Ref uintptr
     if {{.Name}} != nil {
          {{.Name}}Ptr := uintptr(unsafe.Pointer({{.Name}}))
          if cbRefPtr, ok := {{if $NotGLib}}glib.{{end}}GetCallback({{.Name}}Ptr); ok {
               {{.Name}}Ref = cbRefPtr
          } else {
               fcb := func({{range $i, $t := .PureTypes}}{{if $i}}, {{end}}arg{{$i}} {{$t}}{{end}}) {{.RetRaw}} {
                    cbFn := *{{.Name}}
                    {{if .RetRaw}}return {{end}}cbFn({{range $i, $t := .PureTypes}}{{if $i}}, {{end}}arg{{$i}}{{end}})
               }
               {{.Name}}Ref = purego.NewCallback(fcb)
               {{if $NotGLib}}glib.{{end}}SaveCallback({{.Name}}Ptr, {{.Name}}Ref)
          }
     }
     {{end}}
     {{if .Ret.Value}}cret :={{end}}x{{.Name}}({{convd .Args.API.CallWithRefs}})
     {{.Ret.Fmt $NotGObject}}
}
{{end}}

{{$outer := .}}
{{range .Receivers -}}
var x{{$outer.Name}}{{.Name}} func(uintptr {{convc .Args.Pure.Types}}) {{.Ret.Raw}}

{{.Doc}}
func (x *{{$outer.Name}}) {{.Name}}({{conv .Args.API.Full}}) {{.Ret.Return}} {
     {{.Ret.Preamble $NotGLib}}
     {{- /* Generate closure wrappers for callback parameters */}}
     {{range .Args.Callbacks}}
     var {{.Name}}Ref uintptr
     if {{.Name}} != nil {
          {{.Name}}Ptr := uintptr(unsafe.Pointer({{.Name}}))
          if cbRefPtr, ok := {{if $NotGLib}}glib.{{end}}GetCallback({{.Name}}Ptr); ok {
               {{.Name}}Ref = cbRefPtr
          } else {
               fcb := func({{range $i, $t := .PureTypes}}{{if $i}}, {{end}}arg{{$i}} {{$t}}{{end}}) {{.RetRaw}} {
                    cbFn := *{{.Name}}
                    {{if .RetRaw}}return {{end}}cbFn({{range $i, $t := .PureTypes}}{{if $i}}, {{end}}arg{{$i}}{{end}})
               }
               {{.Name}}Ref = purego.NewCallback(fcb)
               {{if $NotGLib}}glib.{{end}}SaveCallback({{.Name}}Ptr, {{.Name}}Ref)
          }
     }
     {{end}}
     {{if .Ret.Value}}cret :={{end}}x{{$outer.Name}}{{.Name}}(x.GoPointer() {{convcd .Args.API.CallWithRefs}})
     {{.Ret.Fmt $NotGObject}}
}
{{end}}

func (c *{{.Name}}) GoPointer() uintptr {
     if c == nil {
         return 0
     }
     return c.Ptr
}

func (c *{{.Name}}) SetGoPointer(ptr uintptr) {
     c.Ptr = ptr
}

{{range .Properties -}}
{{if .Writable}}
// SetProperty{{.Name}} sets the "{{.CName}}" property.
{{if .Doc}}{{.Doc}}
{{end}}func (x *{{$outer.Name}}) SetProperty{{.Name}}(value {{.GoType}}) {
	var v {{if $NotGObject}}gobject.{{end}}Value
	{{if or (eq .GValueType "BoxedStrv") (eq .GValueType "BoxedByteArray") (eq .GValueType "BoxedPtrArray")}}v.Init({{propvset $NotGLib .GoType}}{{else}}v.Init({{propsset $NotGObject .GValueType .SetMethod}}){{end}}
	x.SetProperty("{{.CName}}", &v)
}
{{end}}

{{if .Readable}}
// GetProperty{{.Name}} gets the "{{.CName}}" property.
{{if .Doc}}{{.Doc}}
{{end}}func (x *{{$outer.Name}}) GetProperty{{.Name}}() {{.GoType}} {
	var v {{if $NotGObject}}gobject.{{end}}Value
	x.GetProperty("{{.CName}}", &v)
	{{if or (eq .GValueType "BoxedStrv") (eq .GValueType "BoxedByteArray") (eq .GValueType "BoxedPtrArray")}}{{propvget .GoType}}{{else}}return {{propsget .GetMethod}}{{end}}
}
{{end}}
{{end}}

{{range .Signals -}}

{{.Doc}}
func (x *{{$outer.Name}}) Connect{{.Name}}(cb *func({{$outer.Name}} {{convc .Args.API.Types}}) {{.Ret.Value}}) uint32 {
     cbPtr := uintptr(unsafe.Pointer(cb))
     if cbRefPtr, ok := {{if $NotGLib}}glib.{{end}}GetCallback(cbPtr); ok {
          return {{if $NotGObject}}gobject.{{end}}SignalConnect(x.GoPointer(), "{{.CName}}", cbRefPtr)
     }

     fcb := func(clsPtr uintptr {{convc .Args.Pure.Full}}) {{.Ret.Raw}} {
          fa := {{$outer.Name}}{}
          fa.Ptr = clsPtr
          cbFn := *cb
          {{if .Ret.Class}}
          {{.Name}}Cls := cbFn(fa {{convc .Args.Pure.Call}})
          return {{.Name}}Cls.Ptr
          {{else if .Ret.Value}}
          return cbFn(fa {{convc .Args.Pure.Call}})
          {{else}}
          cbFn(fa {{convc .Args.Pure.Call}})
          {{end}}
     }
     cbRefPtr := purego.NewCallback(fcb)
     {{if $NotGLib}}glib.{{end}}SaveCallback(cbPtr, cbRefPtr)
     return {{if $NotGObject}}gobject.{{end}}SignalConnect(x.GoPointer(), "{{.CName}}", cbRefPtr)
}
{{if .Detailed}}
// Connect{{.Name}}WithDetail connects to the "{{.CName}}" signal with a detail string.
// The detail is appended as "{{.CName}}::<detail>".
func (x *{{$outer.Name}}) Connect{{.Name}}WithDetail(detail string, cb *func({{$outer.Name}} {{convc .Args.API.Types}}) {{.Ret.Value}}) uint32 {
     cbPtr := uintptr(unsafe.Pointer(cb))
     signalName := fmt.Sprintf("{{.CName}}::%s", detail)
     if cbRefPtr, ok := {{if $NotGLib}}glib.{{end}}GetCallback(cbPtr); ok {
          return {{if $NotGObject}}gobject.{{end}}SignalConnect(x.GoPointer(), signalName, cbRefPtr)
     }

     fcb := func(clsPtr uintptr {{convc .Args.Pure.Full}}) {{.Ret.Raw}} {
          fa := {{$outer.Name}}{}
          fa.Ptr = clsPtr
          cbFn := *cb
          {{if .Ret.Class}}
          {{.Name}}Cls := cbFn(fa {{convc .Args.Pure.Call}})
          return {{.Name}}Cls.Ptr
          {{else if .Ret.Value}}
          return cbFn(fa {{convc .Args.Pure.Call}})
          {{else}}
          cbFn(fa {{convc .Args.Pure.Call}})
          {{end}}
     }
     cbRefPtr := purego.NewCallback(fcb)
     {{if $NotGLib}}glib.{{end}}SaveCallback(cbPtr, cbRefPtr)
     return {{if $NotGObject}}gobject.{{end}}SignalConnect(x.GoPointer(), signalName, cbRefPtr)
}
{{end}}
{{end}}

{{range .Interfaces -}}
{{range .Methods -}}
{{.Doc}}
func (x *{{$outer.Name}}) {{.Name}}({{conv .Args.API.Full}}) {{.Ret.Return}} {
     {{.Ret.Preamble $NotGLib}}
     {{if .Ret.Value}}cret := {{end}} {{.Namespace}}X{{.FullName}}(x.GoPointer() {{convcd .Args.API.Call}})
     {{.Ret.Fmt $NotGObject}}
}
{{end}}
{{end}}

{{range .Functions -}}
var x{{.Name}} func({{conv .Args.Pure.Types}}) {{.Ret.Raw}}

{{.Doc}}
func {{.Name}}({{conv .Args.API.Full}}) {{.Ret.Return}} {
     {{.Ret.Preamble $NotGLib}}
     {{- /* Generate closure wrappers for callback parameters */}}
     {{range .Args.Callbacks}}
     var {{.Name}}Ref uintptr
     if {{.Name}} != nil {
          {{.Name}}Ptr := uintptr(unsafe.Pointer({{.Name}}))
          if cbRefPtr, ok := {{if $NotGLib}}glib.{{end}}GetCallback({{.Name}}Ptr); ok {
               {{.Name}}Ref = cbRefPtr
          } else {
               fcb := func({{range $i, $t := .PureTypes}}{{if $i}}, {{end}}arg{{$i}} {{$t}}{{end}}) {{.RetRaw}} {
                    cbFn := *{{.Name}}
                    {{if .RetRaw}}return {{end}}cbFn({{range $i, $t := .PureTypes}}{{if $i}}, {{end}}arg{{$i}}{{end}})
               }
               {{.Name}}Ref = purego.NewCallback(fcb)
               {{if $NotGLib}}glib.{{end}}SaveCallback({{.Name}}Ptr, {{.Name}}Ref)
          }
     }
     {{end}}
     {{if .Ret.Value}}cret := {{end}}x{{.Name}}({{convd .Args.API.CallWithRefs}})
     {{.Ret.Fmt $NotGObject}}
}
{{end}}

{{end}}


{{if .NeedsInit}}

func init() {
    {{if .PkgConfigName -}}
    core.SetPackageName("{{.PkgEnv}}", "{{.PkgConfigName}}")
    {{end -}}
    {{if .SharedLibraries -}}
    core.SetSharedLibraries("{{.PkgEnv}}", []string{ {{range .SharedLibraries}}"{{.}}", {{end}} })
    {{end -}}

    var libs []uintptr
    for _, libPath := range core.GetPaths("{{.PkgEnv}}") {
        lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
        if err != nil {
            panic(err)
        }
        libs = append(libs, lib)
    }

    {{range .Aliases -}}
    {{if .TypeGetter -}}
    core.PuregoSafeRegister(&x{{.Name}}GLibType, libs, "{{.TypeGetter}}")
    {{end}}
    {{end}}
    {{range .Enums -}}
    {{if .TypeGetter -}}
    core.PuregoSafeRegister(&x{{.Name}}GLibType, libs, "{{.TypeGetter}}")
    {{end}}
    {{end}}
    {{range .Functions -}}
    core.PuregoSafeRegister(&x{{.Name}}, libs, "{{.CName}}")
    {{end}}

    {{range .Records -}}
    {{$rec := .}}
    {{if .TypeGetter -}}
    core.PuregoSafeRegister(&x{{.Name}}GLibType, libs, "{{.TypeGetter}}")
    {{end}}
    {{range .Constructors -}}
    core.PuregoSafeRegister(&x{{.Name}}, libs, "{{.CName}}")
    {{end}}
    {{range .Receivers -}}
    core.PuregoSafeRegister(&x{{$rec.Name}}{{.Name}}, libs, "{{.CName}}")
    {{end}}
    {{end}}

    {{range .Classes -}}
    {{$cls := .}}
    {{if .TypeGetter -}}
    core.PuregoSafeRegister(&x{{.Name}}GLibType, libs, "{{.TypeGetter}}")
    {{end}}
    {{range .Constructors -}}
    core.PuregoSafeRegister(&x{{.Name}}, libs, "{{.CName}}")
    {{end}}
    {{range .Receivers -}}
    core.PuregoSafeRegister(&x{{$cls.Name}}{{.Name}}, libs, "{{.CName}}")
    {{end}}
    {{range .Functions -}}
    core.PuregoSafeRegister(&x{{.Name}}, libs, "{{.CName}}")
    {{end}}
    {{end}}

    {{range .Interfaces -}}
    {{if .TypeGetter -}}
    core.PuregoSafeRegister(&x{{.Name}}GLibType, libs, "{{.TypeGetter}}")
    {{end}}
    {{range .Methods -}}
    core.PuregoSafeRegister(&{{.Namespace}}X{{.FullName}}, libs, "{{.CName}}")
    {{end}}
    {{end}}
}
{{end}}
