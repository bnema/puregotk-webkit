// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package webkit

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type UserContentFilterStoreClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass
}

func (x *UserContentFilterStoreClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Handles storage of user content filters on disk.
//
// The WebKitUserContentFilterStore provides the means to import and save
// [JSON rule sets](https://webkit.org/blog/3476/content-blockers-first-look/),
// which can be loaded later in an efficient manner. Once filters are stored,
// the #WebKitUserContentFilter objects which represent them can be added to
// a #WebKitUserContentManager with webkit_user_content_manager_add_filter().
//
// JSON rule sets are imported using webkit_user_content_filter_store_save() and stored
// on disk in an implementation defined format. The contents of a filter store must be
// managed using the #WebKitUserContentFilterStore: a list of all the stored filters
// can be obtained with webkit_user_content_filter_store_fetch_identifiers(),
// webkit_user_content_filter_store_load() can be used to retrieve a previously saved
// filter, and removed from the store with webkit_user_content_filter_store_remove().
type UserContentFilterStore struct {
	gobject.Object
}

var xUserContentFilterStoreGLibType func() types.GType

func UserContentFilterStoreGLibType() types.GType {
	return xUserContentFilterStoreGLibType()
}

func UserContentFilterStoreNewFromInternalPtr(ptr uintptr) *UserContentFilterStore {
	cls := &UserContentFilterStore{}
	cls.Ptr = ptr
	return cls
}

var xNewUserContentFilterStore func(string) uintptr

// Create a new #WebKitUserContentFilterStore to manipulate filters stored at @storage_path.
//
// The path must point to a local filesystem, and will be created if needed.
func NewUserContentFilterStore(StoragePathVar string) *UserContentFilterStore {
	var cls *UserContentFilterStore

	cret := xNewUserContentFilterStore(StoragePathVar)

	if cret == 0 {
		return nil
	}
	cls = &UserContentFilterStore{}
	cls.Ptr = cret
	return cls
}

var xUserContentFilterStoreFetchIdentifiers func(uintptr, uintptr, uintptr, uintptr)

// Asynchronously retrieve a list of the identifiers for all the stored filters.
//
// When the operation is finished, @callback will be invoked, which then can use
// webkit_user_content_filter_store_fetch_identifiers_finish() to obtain the list of
// filter identifiers.
func (x *UserContentFilterStore) FetchIdentifiers(CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CallbackVarPtr, CallbackVarRef, CallbackVar)
		}
	}

	xUserContentFilterStoreFetchIdentifiers(x.GoPointer(), CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xUserContentFilterStoreFetchIdentifiersFinish func(uintptr, uintptr) []string

// Finishes an asynchronous fetch of the list of stored filters.
//
// Finishes an asynchronous fetch of the list of identifiers for the stored filters previously
// started with webkit_user_content_filter_store_fetch_identifiers().
func (x *UserContentFilterStore) FetchIdentifiersFinish(ResultVar gio.AsyncResult) []string {

	cret := xUserContentFilterStoreFetchIdentifiersFinish(x.GoPointer(), ResultVar.GoPointer())

	return cret
}

var xUserContentFilterStoreGetPath func(uintptr) string

// Gets the storage path for user content filters.
func (x *UserContentFilterStore) GetPath() string {

	cret := xUserContentFilterStoreGetPath(x.GoPointer())

	return cret
}

var xUserContentFilterStoreLoad func(uintptr, string, uintptr, uintptr, uintptr)

// Asynchronously load a content filter given its @identifier.
//
// The filter must have been
// previously stored using webkit_user_content_filter_store_save().
//
// When the operation is finished, @callback will be invoked, which then can use
// webkit_user_content_filter_store_load_finish() to obtain the resulting filter.
func (x *UserContentFilterStore) Load(IdentifierVar string, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CallbackVarPtr, CallbackVarRef, CallbackVar)
		}
	}

	xUserContentFilterStoreLoad(x.GoPointer(), IdentifierVar, CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xUserContentFilterStoreLoadFinish func(uintptr, uintptr, **glib.Error) *UserContentFilter

// Finishes an asynchronous filter load previously started with
// webkit_user_content_filter_store_load().
func (x *UserContentFilterStore) LoadFinish(ResultVar gio.AsyncResult) (*UserContentFilter, error) {
	var cerr *glib.Error

	cret := xUserContentFilterStoreLoadFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xUserContentFilterStoreRemove func(uintptr, string, uintptr, uintptr, uintptr)

// Asynchronously remove a content filter given its @identifier.
//
// When the operation is finished, @callback will be invoked, which then can use
// webkit_user_content_filter_store_remove_finish() to check whether the removal was
// successful.
func (x *UserContentFilterStore) Remove(IdentifierVar string, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CallbackVarPtr, CallbackVarRef, CallbackVar)
		}
	}

	xUserContentFilterStoreRemove(x.GoPointer(), IdentifierVar, CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xUserContentFilterStoreRemoveFinish func(uintptr, uintptr, **glib.Error) bool

// Finishes an asynchronous filter removal previously started with
// webkit_user_content_filter_store_remove().
func (x *UserContentFilterStore) RemoveFinish(ResultVar gio.AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := xUserContentFilterStoreRemoveFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xUserContentFilterStoreSave func(uintptr, string, *glib.Bytes, uintptr, uintptr, uintptr)

// Asynchronously save a content filter from a set source rule.
//
// Asynchronously save a content filter from a source rule set in the
// [WebKit content extesions JSON format](https://webkit.org/blog/3476/content-blockers-first-look/).
//
// The @identifier can be used afterwards to refer to the filter when using
// webkit_user_content_filter_store_remove() and webkit_user_content_filter_store_load().
// When the @identifier has been used in the past, the new filter source will replace
// the one saved beforehand for the same identifier.
//
// When the operation is finished, @callback will be invoked, which then can use
// webkit_user_content_filter_store_save_finish() to obtain the resulting filter.
func (x *UserContentFilterStore) Save(IdentifierVar string, SourceVar *glib.Bytes, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CallbackVarPtr, CallbackVarRef, CallbackVar)
		}
	}

	xUserContentFilterStoreSave(x.GoPointer(), IdentifierVar, SourceVar, CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xUserContentFilterStoreSaveFinish func(uintptr, uintptr, **glib.Error) *UserContentFilter

// Finishes an asynchronous filter save previously started with
// webkit_user_content_filter_store_save().
func (x *UserContentFilterStore) SaveFinish(ResultVar gio.AsyncResult) (*UserContentFilter, error) {
	var cerr *glib.Error

	cret := xUserContentFilterStoreSaveFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xUserContentFilterStoreSaveFromFile func(uintptr, string, uintptr, uintptr, uintptr, uintptr)

// Asynchronously save a content filter from the contents of a file.
//
// Asynchronously save a content filter from the contents of a file, which must be
// native to the platform, as checked by g_file_is_native(). See
// webkit_user_content_filter_store_save() for more details.
//
// When the operation is finished, @callback will be invoked, which then can use
// webkit_user_content_filter_store_save_finish() to obtain the resulting filter.
func (x *UserContentFilterStore) SaveFromFile(IdentifierVar string, FileVar gio.File, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CallbackVarPtr, CallbackVarRef, CallbackVar)
		}
	}

	xUserContentFilterStoreSaveFromFile(x.GoPointer(), IdentifierVar, FileVar.GoPointer(), CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xUserContentFilterStoreSaveFromFileFinish func(uintptr, uintptr, **glib.Error) *UserContentFilter

// Finishes and asynchronous filter save previously started with
// webkit_user_content_filter_store_save_from_file().
func (x *UserContentFilterStore) SaveFromFileFinish(ResultVar gio.AsyncResult) (*UserContentFilter, error) {
	var cerr *glib.Error

	cret := xUserContentFilterStoreSaveFromFileFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

func (c *UserContentFilterStore) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *UserContentFilterStore) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyPath sets the "path" property.
// The directory used for filter storage. This path is used as the base
// directory where user content filters are stored on disk.
func (x *UserContentFilterStore) SetPropertyPath(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("path", &v)
}

// GetPropertyPath gets the "path" property.
// The directory used for filter storage. This path is used as the base
// directory where user content filters are stored on disk.
func (x *UserContentFilterStore) GetPropertyPath() string {
	var v gobject.Value
	x.GetProperty("path", &v)
	return v.GetString()
}

func init() {
	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("WEBKIT") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xUserContentFilterStoreGLibType, libs, "webkit_user_content_filter_store_get_type")

	core.PuregoSafeRegister(&xNewUserContentFilterStore, libs, "webkit_user_content_filter_store_new")

	core.PuregoSafeRegister(&xUserContentFilterStoreFetchIdentifiers, libs, "webkit_user_content_filter_store_fetch_identifiers")
	core.PuregoSafeRegister(&xUserContentFilterStoreFetchIdentifiersFinish, libs, "webkit_user_content_filter_store_fetch_identifiers_finish")
	core.PuregoSafeRegister(&xUserContentFilterStoreGetPath, libs, "webkit_user_content_filter_store_get_path")
	core.PuregoSafeRegister(&xUserContentFilterStoreLoad, libs, "webkit_user_content_filter_store_load")
	core.PuregoSafeRegister(&xUserContentFilterStoreLoadFinish, libs, "webkit_user_content_filter_store_load_finish")
	core.PuregoSafeRegister(&xUserContentFilterStoreRemove, libs, "webkit_user_content_filter_store_remove")
	core.PuregoSafeRegister(&xUserContentFilterStoreRemoveFinish, libs, "webkit_user_content_filter_store_remove_finish")
	core.PuregoSafeRegister(&xUserContentFilterStoreSave, libs, "webkit_user_content_filter_store_save")
	core.PuregoSafeRegister(&xUserContentFilterStoreSaveFinish, libs, "webkit_user_content_filter_store_save_finish")
	core.PuregoSafeRegister(&xUserContentFilterStoreSaveFromFile, libs, "webkit_user_content_filter_store_save_from_file")
	core.PuregoSafeRegister(&xUserContentFilterStoreSaveFromFileFinish, libs, "webkit_user_content_filter_store_save_from_file_finish")

}
