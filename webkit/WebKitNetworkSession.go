// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package webkit

import (
	"runtime"
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type NetworkSessionClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass
}

func (x *NetworkSessionClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Manages network configuration.
type NetworkSession struct {
	gobject.Object
}

var xNetworkSessionGLibType func() types.GType

func NetworkSessionGLibType() types.GType {
	return xNetworkSessionGLibType()
}

func NetworkSessionNewFromInternalPtr(ptr uintptr) *NetworkSession {
	cls := &NetworkSession{}
	cls.Ptr = ptr
	return cls
}

var xNewNetworkSession func(uintptr, uintptr) uintptr

// Creates a new #WebKitNetworkSession with a persistent #WebKitWebsiteDataManager.
// The parameters @data_directory and @cache_directory will be used as construct
// properties of the #WebKitWebsiteDataManager of the network session. Note that if
// %NULL is passed, the default directory will be passed to #WebKitWebsiteDataManager
// so that webkit_website_data_manager_get_base_data_directory() and
// webkit_website_data_manager_get_base_cache_directory() always return a value for
// non ephemeral sessions.
//
// It must be passed as construct parameter of a #WebKitWebView.
func NewNetworkSession(DataDirectoryVar *string, CacheDirectoryVar *string) *NetworkSession {
	var cls *NetworkSession

	DataDirectoryVarPtr, DataDirectoryVarBytes := core.NullableStringToPtr(DataDirectoryVar)

	CacheDirectoryVarPtr, CacheDirectoryVarBytes := core.NullableStringToPtr(CacheDirectoryVar)

	cret := xNewNetworkSession(DataDirectoryVarPtr, CacheDirectoryVarPtr)

	runtime.KeepAlive(DataDirectoryVarBytes)

	runtime.KeepAlive(CacheDirectoryVarBytes)

	if cret == 0 {
		return nil
	}
	cls = &NetworkSession{}
	cls.Ptr = cret
	return cls
}

var xNewNetworkSessionEphemeral func() uintptr

// Creates a new #WebKitNetworkSession with an ephemeral #WebKitWebsiteDataManager.
func NewNetworkSessionEphemeral() *NetworkSession {
	var cls *NetworkSession

	cret := xNewNetworkSessionEphemeral()

	if cret == 0 {
		return nil
	}
	cls = &NetworkSession{}
	cls.Ptr = cret
	return cls
}

var xNetworkSessionAllowTlsCertificateForHost func(uintptr, uintptr, string)

// Ignore further TLS errors on the @host for the certificate present in @info.
//
// If @host is an IPv6 address, it should not be surrounded by brackets. This
// expectation matches g_uri_get_host().
func (x *NetworkSession) AllowTlsCertificateForHost(CertificateVar *gio.TlsCertificate, HostVar string) {

	xNetworkSessionAllowTlsCertificateForHost(x.GoPointer(), CertificateVar.GoPointer(), HostVar)

}

var xNetworkSessionDownloadUri func(uintptr, string) uintptr

// Requests downloading of the specified URI string.
//
// The download operation will not be associated to any #WebKitWebView,
// if you are interested in starting a download from a particular #WebKitWebView use
// webkit_web_view_download_uri() instead.
func (x *NetworkSession) DownloadUri(UriVar string) *Download {
	var cls *Download

	cret := xNetworkSessionDownloadUri(x.GoPointer(), UriVar)

	if cret == 0 {
		return nil
	}
	cls = &Download{}
	cls.Ptr = cret
	return cls
}

var xNetworkSessionGetCookieManager func(uintptr) uintptr

// Get the #WebKitCookieManager of @session.
func (x *NetworkSession) GetCookieManager() *CookieManager {
	var cls *CookieManager

	cret := xNetworkSessionGetCookieManager(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &CookieManager{}
	cls.Ptr = cret
	return cls
}

var xNetworkSessionGetItpEnabled func(uintptr) bool

// Get whether Intelligent Tracking Prevention (ITP) is enabled or not.
func (x *NetworkSession) GetItpEnabled() bool {

	cret := xNetworkSessionGetItpEnabled(x.GoPointer())

	return cret
}

var xNetworkSessionGetItpSummary func(uintptr, uintptr, uintptr, uintptr)

// Asynchronously get the list of #WebKitITPThirdParty seen for @session.
//
// Every #WebKitITPThirdParty
// contains the list of #WebKitITPFirstParty under which it has been seen.
//
// When the operation is finished, @callback will be called. You can then call
// webkit_network_session_get_itp_summary_finish() to get the result of the operation.
func (x *NetworkSession) GetItpSummary(CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CallbackVarPtr, CallbackVarRef, CallbackVar)
		}
	}

	xNetworkSessionGetItpSummary(x.GoPointer(), CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xNetworkSessionGetItpSummaryFinish func(uintptr, uintptr, **glib.Error) *glib.List

// Finish an asynchronous operation started with webkit_network_session_get_itp_summary().
func (x *NetworkSession) GetItpSummaryFinish(ResultVar gio.AsyncResult) (*glib.List, error) {
	var cerr *glib.Error

	cret := xNetworkSessionGetItpSummaryFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xNetworkSessionGetPersistentCredentialStorageEnabled func(uintptr) bool

// Get whether persistent credential storage is enabled or not.
//
// See also webkit_network_session_set_persistent_credential_storage_enabled().
func (x *NetworkSession) GetPersistentCredentialStorageEnabled() bool {

	cret := xNetworkSessionGetPersistentCredentialStorageEnabled(x.GoPointer())

	return cret
}

var xNetworkSessionGetTlsErrorsPolicy func(uintptr) TLSErrorsPolicy

// Get the TLS errors policy of @session.
func (x *NetworkSession) GetTlsErrorsPolicy() TLSErrorsPolicy {

	cret := xNetworkSessionGetTlsErrorsPolicy(x.GoPointer())

	return cret
}

var xNetworkSessionGetWebsiteDataManager func(uintptr) uintptr

// Get the #WebKitWebsiteDataManager of @session.
func (x *NetworkSession) GetWebsiteDataManager() *WebsiteDataManager {
	var cls *WebsiteDataManager

	cret := xNetworkSessionGetWebsiteDataManager(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &WebsiteDataManager{}
	cls.Ptr = cret
	return cls
}

var xNetworkSessionIsEphemeral func(uintptr) bool

// Get whether @session is ephemeral.
// A #WebKitNetworkSession is ephemeral when its #WebKitWebsiteDataManager is ephemeral.
// See #WebKitWebsiteDataManager:is-ephemeral for more details.
func (x *NetworkSession) IsEphemeral() bool {

	cret := xNetworkSessionIsEphemeral(x.GoPointer())

	return cret
}

var xNetworkSessionPrefetchDns func(uintptr, string)

// Resolve the domain name of the given @hostname in advance, so that if a URI
// of @hostname is requested the load will be performed more quickly.
func (x *NetworkSession) PrefetchDns(HostnameVar string) {

	xNetworkSessionPrefetchDns(x.GoPointer(), HostnameVar)

}

var xNetworkSessionSetItpEnabled func(uintptr, bool)

// Enable or disable Intelligent Tracking Prevention (ITP).
//
// When ITP is enabled resource load statistics
// are collected and used to decide whether to allow or block third-party cookies and prevent user tracking.
// Note that while ITP is enabled the accept policy %WEBKIT_COOKIE_POLICY_ACCEPT_NO_THIRD_PARTY is ignored and
// %WEBKIT_COOKIE_POLICY_ACCEPT_ALWAYS is used instead. See also webkit_cookie_session_set_accept_policy().
func (x *NetworkSession) SetItpEnabled(EnabledVar bool) {

	xNetworkSessionSetItpEnabled(x.GoPointer(), EnabledVar)

}

var xNetworkSessionSetPersistentCredentialStorageEnabled func(uintptr, bool)

// Enable or disable persistent credential storage.
//
// When enabled, which is the default for
// non-ephemeral sessions, the network process will try to read and write HTTP authentiacation
// credentials from persistent storage.
func (x *NetworkSession) SetPersistentCredentialStorageEnabled(EnabledVar bool) {

	xNetworkSessionSetPersistentCredentialStorageEnabled(x.GoPointer(), EnabledVar)

}

var xNetworkSessionSetProxySettings func(uintptr, NetworkProxyMode, *NetworkProxySettings)

// Set the network proxy settings to be used by connections started in @session session.
//
// By default %WEBKIT_NETWORK_PROXY_MODE_DEFAULT is used, which means that the
// system settings will be used (g_proxy_resolver_get_default()).
// If you want to override the system default settings, you can either use
// %WEBKIT_NETWORK_PROXY_MODE_NO_PROXY to make sure no proxies are used at all,
// or %WEBKIT_NETWORK_PROXY_MODE_CUSTOM to provide your own proxy settings.
// When @proxy_mode is %WEBKIT_NETWORK_PROXY_MODE_CUSTOM @proxy_settings must be
// a valid #WebKitNetworkProxySettings; otherwise, @proxy_settings must be %NULL.
func (x *NetworkSession) SetProxySettings(ProxyModeVar NetworkProxyMode, ProxySettingsVar *NetworkProxySettings) {

	xNetworkSessionSetProxySettings(x.GoPointer(), ProxyModeVar, ProxySettingsVar)

}

var xNetworkSessionSetTlsErrorsPolicy func(uintptr, TLSErrorsPolicy)

// Set the TLS errors policy of @session as @policy.
func (x *NetworkSession) SetTlsErrorsPolicy(PolicyVar TLSErrorsPolicy) {

	xNetworkSessionSetTlsErrorsPolicy(x.GoPointer(), PolicyVar)

}

func (c *NetworkSession) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *NetworkSession) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyCacheDirectory sets the "cache-directory" property.
// The base caches directory used to create the #WebKitWebsiteDataManager. If %NULL, a default location will be used.
func (x *NetworkSession) SetPropertyCacheDirectory(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("cache-directory", &v)
}

// SetPropertyDataDirectory sets the "data-directory" property.
// The base data directory used to create the #WebKitWebsiteDataManager. If %NULL, a default location will be used.
func (x *NetworkSession) SetPropertyDataDirectory(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("data-directory", &v)
}

// SetPropertyIsEphemeral sets the "is-ephemeral" property.
// Whether to create an ephermeral #WebKitWebsiteDataManager for the session.
func (x *NetworkSession) SetPropertyIsEphemeral(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("is-ephemeral", &v)
}

// GetPropertyIsEphemeral gets the "is-ephemeral" property.
// Whether to create an ephermeral #WebKitWebsiteDataManager for the session.
func (x *NetworkSession) GetPropertyIsEphemeral() bool {
	var v gobject.Value
	x.GetProperty("is-ephemeral", &v)
	return v.GetBoolean()
}

// This signal is emitted when a new download request is made.
func (x *NetworkSession) ConnectDownloadStarted(cb *func(NetworkSession, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "download-started", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, DownloadVarp uintptr) {
		fa := NetworkSession{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, DownloadVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "download-started", cbRefPtr)
}

var xNetworkSessionGetDefault func() uintptr

// Get the default network session.
// The default network session is created using webkit_network_session_new() and passing
// %NULL as data and cache directories.
func NetworkSessionGetDefault() *NetworkSession {
	var cls *NetworkSession

	cret := xNetworkSessionGetDefault()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &NetworkSession{}
	cls.Ptr = cret
	return cls
}

var xNetworkSessionSetMemoryPressureSettings func(*MemoryPressureSettings)

// Sets @settings as the #WebKitMemoryPressureSettings.
//
// Sets @settings as the #WebKitMemoryPressureSettings to be used by the network
// process created by any instance of #WebKitNetworkSession after this function
// is called.
//
// Be sure to call this function before creating any #WebKitNetworkSession.
//
// The periodic check for used memory is disabled by default on network processes. This will
// be enabled only if custom settings have been set using this function. After that, in order
// to remove the custom settings and disable the periodic check, this function must be called
// passing %NULL as the value of @settings.
func NetworkSessionSetMemoryPressureSettings(SettingsVar *MemoryPressureSettings) {

	xNetworkSessionSetMemoryPressureSettings(SettingsVar)

}

func init() {
	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("WEBKIT") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xNetworkSessionGLibType, libs, "webkit_network_session_get_type")

	core.PuregoSafeRegister(&xNewNetworkSession, libs, "webkit_network_session_new")
	core.PuregoSafeRegister(&xNewNetworkSessionEphemeral, libs, "webkit_network_session_new_ephemeral")

	core.PuregoSafeRegister(&xNetworkSessionAllowTlsCertificateForHost, libs, "webkit_network_session_allow_tls_certificate_for_host")
	core.PuregoSafeRegister(&xNetworkSessionDownloadUri, libs, "webkit_network_session_download_uri")
	core.PuregoSafeRegister(&xNetworkSessionGetCookieManager, libs, "webkit_network_session_get_cookie_manager")
	core.PuregoSafeRegister(&xNetworkSessionGetItpEnabled, libs, "webkit_network_session_get_itp_enabled")
	core.PuregoSafeRegister(&xNetworkSessionGetItpSummary, libs, "webkit_network_session_get_itp_summary")
	core.PuregoSafeRegister(&xNetworkSessionGetItpSummaryFinish, libs, "webkit_network_session_get_itp_summary_finish")
	core.PuregoSafeRegister(&xNetworkSessionGetPersistentCredentialStorageEnabled, libs, "webkit_network_session_get_persistent_credential_storage_enabled")
	core.PuregoSafeRegister(&xNetworkSessionGetTlsErrorsPolicy, libs, "webkit_network_session_get_tls_errors_policy")
	core.PuregoSafeRegister(&xNetworkSessionGetWebsiteDataManager, libs, "webkit_network_session_get_website_data_manager")
	core.PuregoSafeRegister(&xNetworkSessionIsEphemeral, libs, "webkit_network_session_is_ephemeral")
	core.PuregoSafeRegister(&xNetworkSessionPrefetchDns, libs, "webkit_network_session_prefetch_dns")
	core.PuregoSafeRegister(&xNetworkSessionSetItpEnabled, libs, "webkit_network_session_set_itp_enabled")
	core.PuregoSafeRegister(&xNetworkSessionSetPersistentCredentialStorageEnabled, libs, "webkit_network_session_set_persistent_credential_storage_enabled")
	core.PuregoSafeRegister(&xNetworkSessionSetProxySettings, libs, "webkit_network_session_set_proxy_settings")
	core.PuregoSafeRegister(&xNetworkSessionSetTlsErrorsPolicy, libs, "webkit_network_session_set_tls_errors_policy")

	core.PuregoSafeRegister(&xNetworkSessionGetDefault, libs, "webkit_network_session_get_default")
	core.PuregoSafeRegister(&xNetworkSessionSetMemoryPressureSettings, libs, "webkit_network_session_set_memory_pressure_settings")

}
