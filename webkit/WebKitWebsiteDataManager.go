// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package webkit

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// Describes a first party origin.
type ITPFirstParty struct {
	_ structs.HostLayout
}

var xITPFirstPartyGLibType func() types.GType

func ITPFirstPartyGLibType() types.GType {
	return xITPFirstPartyGLibType()
}

func (x *ITPFirstParty) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xITPFirstPartyGetDomain func(uintptr) string

// Get the domain name of @itp_first_party.
func (x *ITPFirstParty) GetDomain() string {

	cret := xITPFirstPartyGetDomain(x.GoPointer())
	return cret
}

var xITPFirstPartyGetLastUpdateTime func(uintptr) *glib.DateTime

// Get the last time a #WebKitITPThirdParty has been seen under @itp_first_party.
//
// Each @WebKitITPFirstParty is created by webkit_itp_third_party_get_first_parties() and
// therefore corresponds to exactly one #WebKitITPThirdParty.
func (x *ITPFirstParty) GetLastUpdateTime() *glib.DateTime {

	cret := xITPFirstPartyGetLastUpdateTime(x.GoPointer())
	return cret
}

var xITPFirstPartyGetWebsiteDataAccessAllowed func(uintptr) bool

// Get whether @itp_first_party has granted website data access to its #WebKitITPThirdParty.
//
// Each @WebKitITPFirstParty is created by webkit_itp_third_party_get_first_parties() and
// therefore corresponds to exactly one #WebKitITPThirdParty.
func (x *ITPFirstParty) GetWebsiteDataAccessAllowed() bool {

	cret := xITPFirstPartyGetWebsiteDataAccessAllowed(x.GoPointer())
	return cret
}

var xITPFirstPartyRef func(uintptr) *ITPFirstParty

// Atomically increments the reference count of @itp_first_party by one.
//
// This function is MT-safe and may be called from any thread.
func (x *ITPFirstParty) Ref() *ITPFirstParty {

	cret := xITPFirstPartyRef(x.GoPointer())
	return cret
}

var xITPFirstPartyUnref func(uintptr)

// Atomically decrements the reference count of @itp_first_party by one.
//
// If the reference count drops to 0, all memory allocated by
// #WebKitITPFirstParty is released. This function is MT-safe and may be
// called from any thread.
func (x *ITPFirstParty) Unref() {

	xITPFirstPartyUnref(x.GoPointer())

}

// Describes a third party origin.
type ITPThirdParty struct {
	_ structs.HostLayout
}

var xITPThirdPartyGLibType func() types.GType

func ITPThirdPartyGLibType() types.GType {
	return xITPThirdPartyGLibType()
}

func (x *ITPThirdParty) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xITPThirdPartyGetDomain func(uintptr) string

// Get the domain name of @itp_third_party.
func (x *ITPThirdParty) GetDomain() string {

	cret := xITPThirdPartyGetDomain(x.GoPointer())
	return cret
}

var xITPThirdPartyGetFirstParties func(uintptr) *glib.List

// Get the list of #WebKitITPFirstParty under which @itp_third_party has been seen.
func (x *ITPThirdParty) GetFirstParties() *glib.List {

	cret := xITPThirdPartyGetFirstParties(x.GoPointer())
	return cret
}

var xITPThirdPartyRef func(uintptr) *ITPThirdParty

// Atomically increments the reference count of @itp_third_party by one.
//
// This function is MT-safe and may be called from any thread.
func (x *ITPThirdParty) Ref() *ITPThirdParty {

	cret := xITPThirdPartyRef(x.GoPointer())
	return cret
}

var xITPThirdPartyUnref func(uintptr)

// Atomically decrements the reference count of @itp_third_party by one.
//
// If the reference count drops to 0, all memory allocated by
// #WebKitITPThirdParty is released. This function is MT-safe and may be
// called from any thread.
func (x *ITPThirdParty) Unref() {

	xITPThirdPartyUnref(x.GoPointer())

}

type WebsiteDataManagerClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass
}

func (x *WebsiteDataManagerClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Enum values used to denote the TLS errors policy.
type TLSErrorsPolicy int

var xTLSErrorsPolicyGLibType func() types.GType

func TLSErrorsPolicyGLibType() types.GType {
	return xTLSErrorsPolicyGLibType()
}

const (

	// Ignore TLS errors.
	TlsErrorsPolicyIgnoreValue TLSErrorsPolicy = 0
	// TLS errors will emit
	//   #WebKitWebView::load-failed-with-tls-errors and, if the signal is handled,
	//   finish the load. In case the signal is not handled,
	//   #WebKitWebView::load-failed is emitted before the load finishes.
	TlsErrorsPolicyFailValue TLSErrorsPolicy = 1
)

// Manages data stored locally by web sites.
//
// You can use WebKitWebsiteDataManager to configure the local directories
// where website data will be stored. Use #WebKitWebsiteDataManager:base-data-directory
// and #WebKitWebsiteDataManager:base-cache-directory set a common base directory for all
// website data and caches.
//
// A WebKitWebsiteDataManager can be ephemeral, in which case all the directory configuration
// is not needed because website data will never persist. You can create an ephemeral WebKitWebsiteDataManager
// with webkit_website_data_manager_new_ephemeral().
//
// WebKitWebsiteDataManager can also be used to fetch website data, remove data
// stored by particular websites, or clear data for all websites modified since a given
// period of time.
type WebsiteDataManager struct {
	gobject.Object
}

var xWebsiteDataManagerGLibType func() types.GType

func WebsiteDataManagerGLibType() types.GType {
	return xWebsiteDataManagerGLibType()
}

func WebsiteDataManagerNewFromInternalPtr(ptr uintptr) *WebsiteDataManager {
	cls := &WebsiteDataManager{}
	cls.Ptr = ptr
	return cls
}

var xWebsiteDataManagerClear func(uintptr, WebsiteDataTypes, glib.TimeSpan, uintptr, uintptr, uintptr)

// Asynchronously clear the website data of the given @types modified in the past @timespan.
//
// If @timespan is 0, all website data will be removed.
//
// When the operation is finished, @callback will be called. You can then call
// webkit_website_data_manager_clear_finish() to get the result of the operation.
//
// Due to implementation limitations, this function does not currently delete
// any stored cookies if @timespan is nonzero. This behavior may change in the
// future.
func (x *WebsiteDataManager) Clear(TypesVar WebsiteDataTypes, TimespanVar glib.TimeSpan, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CallbackVarPtr, CallbackVarRef, CallbackVar)
		}
	}

	xWebsiteDataManagerClear(x.GoPointer(), TypesVar, TimespanVar, CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xWebsiteDataManagerClearFinish func(uintptr, uintptr, **glib.Error) bool

// Finish an asynchronous operation started with webkit_website_data_manager_clear()
func (x *WebsiteDataManager) ClearFinish(ResultVar gio.AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := xWebsiteDataManagerClearFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xWebsiteDataManagerFetch func(uintptr, WebsiteDataTypes, uintptr, uintptr, uintptr)

// Asynchronously get the list of #WebKitWebsiteData for the given @types.
//
// When the operation is finished, @callback will be called. You can then call
// webkit_website_data_manager_fetch_finish() to get the result of the operation.
func (x *WebsiteDataManager) Fetch(TypesVar WebsiteDataTypes, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CallbackVarPtr, CallbackVarRef, CallbackVar)
		}
	}

	xWebsiteDataManagerFetch(x.GoPointer(), TypesVar, CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xWebsiteDataManagerFetchFinish func(uintptr, uintptr, **glib.Error) *glib.List

// Finish an asynchronous operation started with webkit_website_data_manager_fetch().
func (x *WebsiteDataManager) FetchFinish(ResultVar gio.AsyncResult) (*glib.List, error) {
	var cerr *glib.Error

	cret := xWebsiteDataManagerFetchFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xWebsiteDataManagerGetBaseCacheDirectory func(uintptr) string

// Get the #WebKitWebsiteDataManager:base-cache-directory property.
func (x *WebsiteDataManager) GetBaseCacheDirectory() string {

	cret := xWebsiteDataManagerGetBaseCacheDirectory(x.GoPointer())
	return cret
}

var xWebsiteDataManagerGetBaseDataDirectory func(uintptr) string

// Get the #WebKitWebsiteDataManager:base-data-directory property.
func (x *WebsiteDataManager) GetBaseDataDirectory() string {

	cret := xWebsiteDataManagerGetBaseDataDirectory(x.GoPointer())
	return cret
}

var xWebsiteDataManagerGetFaviconDatabase func(uintptr) uintptr

// Get the #WebKitFaviconDatabase of @manager.
func (x *WebsiteDataManager) GetFaviconDatabase() *FaviconDatabase {
	var cls *FaviconDatabase

	cret := xWebsiteDataManagerGetFaviconDatabase(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &FaviconDatabase{}
	cls.Ptr = cret
	return cls
}

var xWebsiteDataManagerGetFaviconsEnabled func(uintptr) bool

// Get whether website icons are enabled.
func (x *WebsiteDataManager) GetFaviconsEnabled() bool {

	cret := xWebsiteDataManagerGetFaviconsEnabled(x.GoPointer())
	return cret
}

var xWebsiteDataManagerGetItpSummary func(uintptr, uintptr, uintptr, uintptr)

// Asynchronously get the list of #WebKitITPThirdParty seen for @manager.
//
// Every #WebKitITPThirdParty
// contains the list of #WebKitITPFirstParty under which it has been seen.
//
// When the operation is finished, @callback will be called. You can then call
// webkit_website_data_manager_get_itp_summary_finish() to get the result of the operation.
func (x *WebsiteDataManager) GetItpSummary(CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CallbackVarPtr, CallbackVarRef, CallbackVar)
		}
	}

	xWebsiteDataManagerGetItpSummary(x.GoPointer(), CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xWebsiteDataManagerGetItpSummaryFinish func(uintptr, uintptr, **glib.Error) *glib.List

// Finish an asynchronous operation started with webkit_website_data_manager_get_itp_summary().
func (x *WebsiteDataManager) GetItpSummaryFinish(ResultVar gio.AsyncResult) (*glib.List, error) {
	var cerr *glib.Error

	cret := xWebsiteDataManagerGetItpSummaryFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xWebsiteDataManagerIsEphemeral func(uintptr) bool

// Get whether a #WebKitWebsiteDataManager is ephemeral.
//
// See #WebKitWebsiteDataManager:is-ephemeral for more details.
func (x *WebsiteDataManager) IsEphemeral() bool {

	cret := xWebsiteDataManagerIsEphemeral(x.GoPointer())
	return cret
}

var xWebsiteDataManagerRemove func(uintptr, WebsiteDataTypes, *glib.List, uintptr, uintptr, uintptr)

// Asynchronously removes the website data in the given @website_data list.
//
// Asynchronously removes the website data of the given @types for websites in the given @website_data list.
// Use webkit_website_data_manager_clear() if you want to remove the website data for all sites.
//
// When the operation is finished, @callback will be called. You can then call
// webkit_website_data_manager_remove_finish() to get the result of the operation.
func (x *WebsiteDataManager) Remove(TypesVar WebsiteDataTypes, WebsiteDataVar *glib.List, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CallbackVarPtr, CallbackVarRef, CallbackVar)
		}
	}

	xWebsiteDataManagerRemove(x.GoPointer(), TypesVar, WebsiteDataVar, CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xWebsiteDataManagerRemoveFinish func(uintptr, uintptr, **glib.Error) bool

// Finish an asynchronous operation started with webkit_website_data_manager_remove().
func (x *WebsiteDataManager) RemoveFinish(ResultVar gio.AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := xWebsiteDataManagerRemoveFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xWebsiteDataManagerSetFaviconsEnabled func(uintptr, bool)

// Set whether website icons are enabled. Website icons are disabled by default.
// When website icons are disabled, the #WebKitFaviconDatabase of @manager is closed and
// its reference removed, so webkit_website_data_manager_get_favicon_database() will
// return %NULL. If website icons are enabled again, a new #WebKitFaviconDatabase will
// be created.
func (x *WebsiteDataManager) SetFaviconsEnabled(EnabledVar bool) {

	xWebsiteDataManagerSetFaviconsEnabled(x.GoPointer(), EnabledVar)

}

func (c *WebsiteDataManager) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *WebsiteDataManager) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyBaseCacheDirectory sets the "base-cache-directory" property.
// The base directory for caches. If %NULL, a default location will be used.
func (x *WebsiteDataManager) SetPropertyBaseCacheDirectory(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("base-cache-directory", &v)
}

// GetPropertyBaseCacheDirectory gets the "base-cache-directory" property.
// The base directory for caches. If %NULL, a default location will be used.
func (x *WebsiteDataManager) GetPropertyBaseCacheDirectory() string {
	var v gobject.Value
	x.GetProperty("base-cache-directory", &v)
	return v.GetString()
}

// SetPropertyBaseDataDirectory sets the "base-data-directory" property.
// The base directory for website data. If %NULL, a default location will be used.
func (x *WebsiteDataManager) SetPropertyBaseDataDirectory(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("base-data-directory", &v)
}

// GetPropertyBaseDataDirectory gets the "base-data-directory" property.
// The base directory for website data. If %NULL, a default location will be used.
func (x *WebsiteDataManager) GetPropertyBaseDataDirectory() string {
	var v gobject.Value
	x.GetProperty("base-data-directory", &v)
	return v.GetString()
}

// SetPropertyIsEphemeral sets the "is-ephemeral" property.
// Whether the #WebKitWebsiteDataManager is ephemeral. An ephemeral #WebKitWebsiteDataManager
// handles all websites data as non-persistent, and nothing will be written to the client
// storage. Note that if you create an ephemeral #WebKitWebsiteDataManager all other construction
// parameters to configure data directories will be ignored.
func (x *WebsiteDataManager) SetPropertyIsEphemeral(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("is-ephemeral", &v)
}

// GetPropertyIsEphemeral gets the "is-ephemeral" property.
// Whether the #WebKitWebsiteDataManager is ephemeral. An ephemeral #WebKitWebsiteDataManager
// handles all websites data as non-persistent, and nothing will be written to the client
// storage. Note that if you create an ephemeral #WebKitWebsiteDataManager all other construction
// parameters to configure data directories will be ignored.
func (x *WebsiteDataManager) GetPropertyIsEphemeral() bool {
	var v gobject.Value
	x.GetProperty("is-ephemeral", &v)
	return v.GetBoolean()
}

// SetPropertyOriginStorageRatio sets the "origin-storage-ratio" property.
// The percentage of volume space that can be used for data storage for every domain.
// If the maximum storage is reached the storage request will fail with a QuotaExceededError exception.
// A value of 0.0 means that data storage is not allowed. A value of -1.0, which is the default,
// means WebKit will use the default quota (1 GiB).
func (x *WebsiteDataManager) SetPropertyOriginStorageRatio(value float64) {
	var v gobject.Value
	v.Init(gobject.TypeDoubleVal)
	v.SetDouble(value)
	x.SetProperty("origin-storage-ratio", &v)
}

// SetPropertyTotalStorageRatio sets the "total-storage-ratio" property.
// The percentage of volume space that can be used for data storage for all domains.
// If the maximum storage is reached the eviction will happen.
// A value of 0.0 means that data storage is not allowed. A value of -1.0, which is the default,
// means there's no limit for the total storage.
func (x *WebsiteDataManager) SetPropertyTotalStorageRatio(value float64) {
	var v gobject.Value
	v.Init(gobject.TypeDoubleVal)
	v.SetDouble(value)
	x.SetProperty("total-storage-ratio", &v)
}

func init() {
	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("WEBKIT") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xTLSErrorsPolicyGLibType, libs, "webkit_tls_errors_policy_get_type")

	core.PuregoSafeRegister(&xITPFirstPartyGLibType, libs, "webkit_itp_first_party_get_type")

	core.PuregoSafeRegister(&xITPFirstPartyGetDomain, libs, "webkit_itp_first_party_get_domain")
	core.PuregoSafeRegister(&xITPFirstPartyGetLastUpdateTime, libs, "webkit_itp_first_party_get_last_update_time")
	core.PuregoSafeRegister(&xITPFirstPartyGetWebsiteDataAccessAllowed, libs, "webkit_itp_first_party_get_website_data_access_allowed")
	core.PuregoSafeRegister(&xITPFirstPartyRef, libs, "webkit_itp_first_party_ref")
	core.PuregoSafeRegister(&xITPFirstPartyUnref, libs, "webkit_itp_first_party_unref")

	core.PuregoSafeRegister(&xITPThirdPartyGLibType, libs, "webkit_itp_third_party_get_type")

	core.PuregoSafeRegister(&xITPThirdPartyGetDomain, libs, "webkit_itp_third_party_get_domain")
	core.PuregoSafeRegister(&xITPThirdPartyGetFirstParties, libs, "webkit_itp_third_party_get_first_parties")
	core.PuregoSafeRegister(&xITPThirdPartyRef, libs, "webkit_itp_third_party_ref")
	core.PuregoSafeRegister(&xITPThirdPartyUnref, libs, "webkit_itp_third_party_unref")

	core.PuregoSafeRegister(&xWebsiteDataManagerGLibType, libs, "webkit_website_data_manager_get_type")

	core.PuregoSafeRegister(&xWebsiteDataManagerClear, libs, "webkit_website_data_manager_clear")
	core.PuregoSafeRegister(&xWebsiteDataManagerClearFinish, libs, "webkit_website_data_manager_clear_finish")
	core.PuregoSafeRegister(&xWebsiteDataManagerFetch, libs, "webkit_website_data_manager_fetch")
	core.PuregoSafeRegister(&xWebsiteDataManagerFetchFinish, libs, "webkit_website_data_manager_fetch_finish")
	core.PuregoSafeRegister(&xWebsiteDataManagerGetBaseCacheDirectory, libs, "webkit_website_data_manager_get_base_cache_directory")
	core.PuregoSafeRegister(&xWebsiteDataManagerGetBaseDataDirectory, libs, "webkit_website_data_manager_get_base_data_directory")
	core.PuregoSafeRegister(&xWebsiteDataManagerGetFaviconDatabase, libs, "webkit_website_data_manager_get_favicon_database")
	core.PuregoSafeRegister(&xWebsiteDataManagerGetFaviconsEnabled, libs, "webkit_website_data_manager_get_favicons_enabled")
	core.PuregoSafeRegister(&xWebsiteDataManagerGetItpSummary, libs, "webkit_website_data_manager_get_itp_summary")
	core.PuregoSafeRegister(&xWebsiteDataManagerGetItpSummaryFinish, libs, "webkit_website_data_manager_get_itp_summary_finish")
	core.PuregoSafeRegister(&xWebsiteDataManagerIsEphemeral, libs, "webkit_website_data_manager_is_ephemeral")
	core.PuregoSafeRegister(&xWebsiteDataManagerRemove, libs, "webkit_website_data_manager_remove")
	core.PuregoSafeRegister(&xWebsiteDataManagerRemoveFinish, libs, "webkit_website_data_manager_remove_finish")
	core.PuregoSafeRegister(&xWebsiteDataManagerSetFaviconsEnabled, libs, "webkit_website_data_manager_set_favicons_enabled")

}
