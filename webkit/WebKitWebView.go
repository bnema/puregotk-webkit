// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package webkit

import (
	"structs"
	"unsafe"

	"github.com/bnema/puregotk-webkit/javascriptcore"
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
	"github.com/jwijenbergh/puregotk/v4/gtk"
)

type WebViewClass struct {
	_ structs.HostLayout

	Parent uintptr

	xLoadChanged uintptr

	xLoadFailed uintptr

	xCreate uintptr

	xReadyToShow uintptr

	xRunAsModal uintptr

	xClose uintptr

	xScriptDialog uintptr

	xDecidePolicy uintptr

	xPermissionRequest uintptr

	xMouseTargetChanged uintptr

	xPrint uintptr

	xResourceLoadStarted uintptr

	xEnterFullscreen uintptr

	xLeaveFullscreen uintptr

	xRunFileChooser uintptr

	xContextMenu uintptr

	xContextMenuDismissed uintptr

	xSubmitForm uintptr

	xInsecureContentDetected uintptr

	xWebProcessCrashed uintptr

	xAuthenticate uintptr

	xLoadFailedWithTlsErrors uintptr

	xShowNotification uintptr

	xRunColorChooser uintptr

	xShowOptionMenu uintptr

	xWebProcessTerminated uintptr

	xUserMessageReceived uintptr

	xQueryPermissionState uintptr

	xWebkitReserved0 uintptr

	xWebkitReserved1 uintptr

	xWebkitReserved2 uintptr

	xWebkitReserved3 uintptr

	xWebkitReserved4 uintptr

	xWebkitReserved5 uintptr

	xWebkitReserved6 uintptr

	xWebkitReserved7 uintptr

	xWebkitReserved8 uintptr

	xWebkitReserved9 uintptr

	xWebkitReserved10 uintptr

	xWebkitReserved11 uintptr

	xWebkitReserved12 uintptr

	xWebkitReserved13 uintptr

	xWebkitReserved14 uintptr

	xWebkitReserved15 uintptr

	xWebkitReserved16 uintptr

	xWebkitReserved17 uintptr

	xWebkitReserved18 uintptr

	xWebkitReserved19 uintptr

	xWebkitReserved20 uintptr

	xWebkitReserved21 uintptr

	xWebkitReserved22 uintptr

	xWebkitReserved23 uintptr

	xWebkitReserved24 uintptr

	xWebkitReserved25 uintptr

	xWebkitReserved26 uintptr

	xWebkitReserved27 uintptr

	xWebkitReserved28 uintptr

	xWebkitReserved29 uintptr

	xWebkitReserved30 uintptr
}

func (x *WebViewClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideLoadChanged sets the "load_changed" callback function.
func (x *WebViewClass) OverrideLoadChanged(cb func(*WebView, LoadEvent)) {
	if cb == nil {
		x.xLoadChanged = 0
	} else {
		x.xLoadChanged = purego.NewCallback(func(WebViewVarp uintptr, LoadEventVarp LoadEvent) {
			cb(WebViewNewFromInternalPtr(WebViewVarp), LoadEventVarp)
		})
	}
}

// GetLoadChanged gets the "load_changed" callback function.
func (x *WebViewClass) GetLoadChanged() func(*WebView, LoadEvent) {
	if x.xLoadChanged == 0 {
		return nil
	}
	var rawCallback func(WebViewVarp uintptr, LoadEventVarp LoadEvent)
	purego.RegisterFunc(&rawCallback, x.xLoadChanged)
	return func(WebViewVar *WebView, LoadEventVar LoadEvent) {
		rawCallback(WebViewVar.GoPointer(), LoadEventVar)
	}
}

// OverrideLoadFailed sets the "load_failed" callback function.
func (x *WebViewClass) OverrideLoadFailed(cb func(*WebView, LoadEvent, string, *glib.Error) bool) {
	if cb == nil {
		x.xLoadFailed = 0
	} else {
		x.xLoadFailed = purego.NewCallback(func(WebViewVarp uintptr, LoadEventVarp LoadEvent, FailingUriVarp string, ErrorVarp *glib.Error) bool {
			return cb(WebViewNewFromInternalPtr(WebViewVarp), LoadEventVarp, FailingUriVarp, ErrorVarp)
		})
	}
}

// GetLoadFailed gets the "load_failed" callback function.
func (x *WebViewClass) GetLoadFailed() func(*WebView, LoadEvent, string, *glib.Error) bool {
	if x.xLoadFailed == 0 {
		return nil
	}
	var rawCallback func(WebViewVarp uintptr, LoadEventVarp LoadEvent, FailingUriVarp string, ErrorVarp *glib.Error) bool
	purego.RegisterFunc(&rawCallback, x.xLoadFailed)
	return func(WebViewVar *WebView, LoadEventVar LoadEvent, FailingUriVar string, ErrorVar *glib.Error) bool {
		return rawCallback(WebViewVar.GoPointer(), LoadEventVar, FailingUriVar, ErrorVar)
	}
}

// OverrideCreate sets the "create" callback function.
func (x *WebViewClass) OverrideCreate(cb func(*WebView, *NavigationAction) *gtk.Widget) {
	if cb == nil {
		x.xCreate = 0
	} else {
		x.xCreate = purego.NewCallback(func(WebViewVarp uintptr, NavigationActionVarp *NavigationAction) uintptr {
			ret := cb(WebViewNewFromInternalPtr(WebViewVarp), NavigationActionVarp)
			if ret == nil {
				return 0
			}
			return ret.GoPointer()
		})
	}
}

// GetCreate gets the "create" callback function.
func (x *WebViewClass) GetCreate() func(*WebView, *NavigationAction) *gtk.Widget {
	if x.xCreate == 0 {
		return nil
	}
	var rawCallback func(WebViewVarp uintptr, NavigationActionVarp *NavigationAction) uintptr
	purego.RegisterFunc(&rawCallback, x.xCreate)
	return func(WebViewVar *WebView, NavigationActionVar *NavigationAction) *gtk.Widget {
		rawRet := rawCallback(WebViewVar.GoPointer(), NavigationActionVar)
		if rawRet == 0 {
			return nil
		}
		ret := &gtk.Widget{}
		ret.Ptr = rawRet
		return ret
	}
}

// OverrideReadyToShow sets the "ready_to_show" callback function.
func (x *WebViewClass) OverrideReadyToShow(cb func(*WebView)) {
	if cb == nil {
		x.xReadyToShow = 0
	} else {
		x.xReadyToShow = purego.NewCallback(func(WebViewVarp uintptr) {
			cb(WebViewNewFromInternalPtr(WebViewVarp))
		})
	}
}

// GetReadyToShow gets the "ready_to_show" callback function.
func (x *WebViewClass) GetReadyToShow() func(*WebView) {
	if x.xReadyToShow == 0 {
		return nil
	}
	var rawCallback func(WebViewVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xReadyToShow)
	return func(WebViewVar *WebView) {
		rawCallback(WebViewVar.GoPointer())
	}
}

// OverrideRunAsModal sets the "run_as_modal" callback function.
func (x *WebViewClass) OverrideRunAsModal(cb func(*WebView)) {
	if cb == nil {
		x.xRunAsModal = 0
	} else {
		x.xRunAsModal = purego.NewCallback(func(WebViewVarp uintptr) {
			cb(WebViewNewFromInternalPtr(WebViewVarp))
		})
	}
}

// GetRunAsModal gets the "run_as_modal" callback function.
func (x *WebViewClass) GetRunAsModal() func(*WebView) {
	if x.xRunAsModal == 0 {
		return nil
	}
	var rawCallback func(WebViewVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xRunAsModal)
	return func(WebViewVar *WebView) {
		rawCallback(WebViewVar.GoPointer())
	}
}

// OverrideClose sets the "close" callback function.
func (x *WebViewClass) OverrideClose(cb func(*WebView)) {
	if cb == nil {
		x.xClose = 0
	} else {
		x.xClose = purego.NewCallback(func(WebViewVarp uintptr) {
			cb(WebViewNewFromInternalPtr(WebViewVarp))
		})
	}
}

// GetClose gets the "close" callback function.
func (x *WebViewClass) GetClose() func(*WebView) {
	if x.xClose == 0 {
		return nil
	}
	var rawCallback func(WebViewVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xClose)
	return func(WebViewVar *WebView) {
		rawCallback(WebViewVar.GoPointer())
	}
}

// OverrideScriptDialog sets the "script_dialog" callback function.
func (x *WebViewClass) OverrideScriptDialog(cb func(*WebView, *ScriptDialog) bool) {
	if cb == nil {
		x.xScriptDialog = 0
	} else {
		x.xScriptDialog = purego.NewCallback(func(WebViewVarp uintptr, DialogVarp *ScriptDialog) bool {
			return cb(WebViewNewFromInternalPtr(WebViewVarp), DialogVarp)
		})
	}
}

// GetScriptDialog gets the "script_dialog" callback function.
func (x *WebViewClass) GetScriptDialog() func(*WebView, *ScriptDialog) bool {
	if x.xScriptDialog == 0 {
		return nil
	}
	var rawCallback func(WebViewVarp uintptr, DialogVarp *ScriptDialog) bool
	purego.RegisterFunc(&rawCallback, x.xScriptDialog)
	return func(WebViewVar *WebView, DialogVar *ScriptDialog) bool {
		return rawCallback(WebViewVar.GoPointer(), DialogVar)
	}
}

// OverrideDecidePolicy sets the "decide_policy" callback function.
func (x *WebViewClass) OverrideDecidePolicy(cb func(*WebView, *PolicyDecision, PolicyDecisionType) bool) {
	if cb == nil {
		x.xDecidePolicy = 0
	} else {
		x.xDecidePolicy = purego.NewCallback(func(WebViewVarp uintptr, DecisionVarp uintptr, TypeVarp PolicyDecisionType) bool {
			return cb(WebViewNewFromInternalPtr(WebViewVarp), PolicyDecisionNewFromInternalPtr(DecisionVarp), TypeVarp)
		})
	}
}

// GetDecidePolicy gets the "decide_policy" callback function.
func (x *WebViewClass) GetDecidePolicy() func(*WebView, *PolicyDecision, PolicyDecisionType) bool {
	if x.xDecidePolicy == 0 {
		return nil
	}
	var rawCallback func(WebViewVarp uintptr, DecisionVarp uintptr, TypeVarp PolicyDecisionType) bool
	purego.RegisterFunc(&rawCallback, x.xDecidePolicy)
	return func(WebViewVar *WebView, DecisionVar *PolicyDecision, TypeVar PolicyDecisionType) bool {
		return rawCallback(WebViewVar.GoPointer(), DecisionVar.GoPointer(), TypeVar)
	}
}

// OverridePermissionRequest sets the "permission_request" callback function.
func (x *WebViewClass) OverridePermissionRequest(cb func(*WebView, PermissionRequest) bool) {
	if cb == nil {
		x.xPermissionRequest = 0
	} else {
		x.xPermissionRequest = purego.NewCallback(func(WebViewVarp uintptr, PermissionRequestVarp uintptr) bool {
			return cb(WebViewNewFromInternalPtr(WebViewVarp), &PermissionRequestBase{Ptr: PermissionRequestVarp})
		})
	}
}

// GetPermissionRequest gets the "permission_request" callback function.
func (x *WebViewClass) GetPermissionRequest() func(*WebView, PermissionRequest) bool {
	if x.xPermissionRequest == 0 {
		return nil
	}
	var rawCallback func(WebViewVarp uintptr, PermissionRequestVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xPermissionRequest)
	return func(WebViewVar *WebView, PermissionRequestVar PermissionRequest) bool {
		return rawCallback(WebViewVar.GoPointer(), PermissionRequestVar.GoPointer())
	}
}

// OverrideMouseTargetChanged sets the "mouse_target_changed" callback function.
func (x *WebViewClass) OverrideMouseTargetChanged(cb func(*WebView, *HitTestResult, uint)) {
	if cb == nil {
		x.xMouseTargetChanged = 0
	} else {
		x.xMouseTargetChanged = purego.NewCallback(func(WebViewVarp uintptr, HitTestResultVarp uintptr, ModifiersVarp uint) {
			cb(WebViewNewFromInternalPtr(WebViewVarp), HitTestResultNewFromInternalPtr(HitTestResultVarp), ModifiersVarp)
		})
	}
}

// GetMouseTargetChanged gets the "mouse_target_changed" callback function.
func (x *WebViewClass) GetMouseTargetChanged() func(*WebView, *HitTestResult, uint) {
	if x.xMouseTargetChanged == 0 {
		return nil
	}
	var rawCallback func(WebViewVarp uintptr, HitTestResultVarp uintptr, ModifiersVarp uint)
	purego.RegisterFunc(&rawCallback, x.xMouseTargetChanged)
	return func(WebViewVar *WebView, HitTestResultVar *HitTestResult, ModifiersVar uint) {
		rawCallback(WebViewVar.GoPointer(), HitTestResultVar.GoPointer(), ModifiersVar)
	}
}

// OverridePrint sets the "print" callback function.
func (x *WebViewClass) OverridePrint(cb func(*WebView, *PrintOperation) bool) {
	if cb == nil {
		x.xPrint = 0
	} else {
		x.xPrint = purego.NewCallback(func(WebViewVarp uintptr, PrintOperationVarp uintptr) bool {
			return cb(WebViewNewFromInternalPtr(WebViewVarp), PrintOperationNewFromInternalPtr(PrintOperationVarp))
		})
	}
}

// GetPrint gets the "print" callback function.
func (x *WebViewClass) GetPrint() func(*WebView, *PrintOperation) bool {
	if x.xPrint == 0 {
		return nil
	}
	var rawCallback func(WebViewVarp uintptr, PrintOperationVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xPrint)
	return func(WebViewVar *WebView, PrintOperationVar *PrintOperation) bool {
		return rawCallback(WebViewVar.GoPointer(), PrintOperationVar.GoPointer())
	}
}

// OverrideResourceLoadStarted sets the "resource_load_started" callback function.
func (x *WebViewClass) OverrideResourceLoadStarted(cb func(*WebView, *WebResource, *URIRequest)) {
	if cb == nil {
		x.xResourceLoadStarted = 0
	} else {
		x.xResourceLoadStarted = purego.NewCallback(func(WebViewVarp uintptr, ResourceVarp uintptr, RequestVarp uintptr) {
			cb(WebViewNewFromInternalPtr(WebViewVarp), WebResourceNewFromInternalPtr(ResourceVarp), URIRequestNewFromInternalPtr(RequestVarp))
		})
	}
}

// GetResourceLoadStarted gets the "resource_load_started" callback function.
func (x *WebViewClass) GetResourceLoadStarted() func(*WebView, *WebResource, *URIRequest) {
	if x.xResourceLoadStarted == 0 {
		return nil
	}
	var rawCallback func(WebViewVarp uintptr, ResourceVarp uintptr, RequestVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xResourceLoadStarted)
	return func(WebViewVar *WebView, ResourceVar *WebResource, RequestVar *URIRequest) {
		rawCallback(WebViewVar.GoPointer(), ResourceVar.GoPointer(), RequestVar.GoPointer())
	}
}

// OverrideEnterFullscreen sets the "enter_fullscreen" callback function.
func (x *WebViewClass) OverrideEnterFullscreen(cb func(*WebView) bool) {
	if cb == nil {
		x.xEnterFullscreen = 0
	} else {
		x.xEnterFullscreen = purego.NewCallback(func(WebViewVarp uintptr) bool {
			return cb(WebViewNewFromInternalPtr(WebViewVarp))
		})
	}
}

// GetEnterFullscreen gets the "enter_fullscreen" callback function.
func (x *WebViewClass) GetEnterFullscreen() func(*WebView) bool {
	if x.xEnterFullscreen == 0 {
		return nil
	}
	var rawCallback func(WebViewVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xEnterFullscreen)
	return func(WebViewVar *WebView) bool {
		return rawCallback(WebViewVar.GoPointer())
	}
}

// OverrideLeaveFullscreen sets the "leave_fullscreen" callback function.
func (x *WebViewClass) OverrideLeaveFullscreen(cb func(*WebView) bool) {
	if cb == nil {
		x.xLeaveFullscreen = 0
	} else {
		x.xLeaveFullscreen = purego.NewCallback(func(WebViewVarp uintptr) bool {
			return cb(WebViewNewFromInternalPtr(WebViewVarp))
		})
	}
}

// GetLeaveFullscreen gets the "leave_fullscreen" callback function.
func (x *WebViewClass) GetLeaveFullscreen() func(*WebView) bool {
	if x.xLeaveFullscreen == 0 {
		return nil
	}
	var rawCallback func(WebViewVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xLeaveFullscreen)
	return func(WebViewVar *WebView) bool {
		return rawCallback(WebViewVar.GoPointer())
	}
}

// OverrideRunFileChooser sets the "run_file_chooser" callback function.
func (x *WebViewClass) OverrideRunFileChooser(cb func(*WebView, *FileChooserRequest) bool) {
	if cb == nil {
		x.xRunFileChooser = 0
	} else {
		x.xRunFileChooser = purego.NewCallback(func(WebViewVarp uintptr, RequestVarp uintptr) bool {
			return cb(WebViewNewFromInternalPtr(WebViewVarp), FileChooserRequestNewFromInternalPtr(RequestVarp))
		})
	}
}

// GetRunFileChooser gets the "run_file_chooser" callback function.
func (x *WebViewClass) GetRunFileChooser() func(*WebView, *FileChooserRequest) bool {
	if x.xRunFileChooser == 0 {
		return nil
	}
	var rawCallback func(WebViewVarp uintptr, RequestVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xRunFileChooser)
	return func(WebViewVar *WebView, RequestVar *FileChooserRequest) bool {
		return rawCallback(WebViewVar.GoPointer(), RequestVar.GoPointer())
	}
}

// OverrideContextMenu sets the "context_menu" callback function.
func (x *WebViewClass) OverrideContextMenu(cb func(*WebView, *ContextMenu, *HitTestResult) bool) {
	if cb == nil {
		x.xContextMenu = 0
	} else {
		x.xContextMenu = purego.NewCallback(func(WebViewVarp uintptr, ContextMenuVarp uintptr, HitTestResultVarp uintptr) bool {
			return cb(WebViewNewFromInternalPtr(WebViewVarp), ContextMenuNewFromInternalPtr(ContextMenuVarp), HitTestResultNewFromInternalPtr(HitTestResultVarp))
		})
	}
}

// GetContextMenu gets the "context_menu" callback function.
func (x *WebViewClass) GetContextMenu() func(*WebView, *ContextMenu, *HitTestResult) bool {
	if x.xContextMenu == 0 {
		return nil
	}
	var rawCallback func(WebViewVarp uintptr, ContextMenuVarp uintptr, HitTestResultVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xContextMenu)
	return func(WebViewVar *WebView, ContextMenuVar *ContextMenu, HitTestResultVar *HitTestResult) bool {
		return rawCallback(WebViewVar.GoPointer(), ContextMenuVar.GoPointer(), HitTestResultVar.GoPointer())
	}
}

// OverrideContextMenuDismissed sets the "context_menu_dismissed" callback function.
func (x *WebViewClass) OverrideContextMenuDismissed(cb func(*WebView)) {
	if cb == nil {
		x.xContextMenuDismissed = 0
	} else {
		x.xContextMenuDismissed = purego.NewCallback(func(WebViewVarp uintptr) {
			cb(WebViewNewFromInternalPtr(WebViewVarp))
		})
	}
}

// GetContextMenuDismissed gets the "context_menu_dismissed" callback function.
func (x *WebViewClass) GetContextMenuDismissed() func(*WebView) {
	if x.xContextMenuDismissed == 0 {
		return nil
	}
	var rawCallback func(WebViewVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xContextMenuDismissed)
	return func(WebViewVar *WebView) {
		rawCallback(WebViewVar.GoPointer())
	}
}

// OverrideSubmitForm sets the "submit_form" callback function.
func (x *WebViewClass) OverrideSubmitForm(cb func(*WebView, *FormSubmissionRequest)) {
	if cb == nil {
		x.xSubmitForm = 0
	} else {
		x.xSubmitForm = purego.NewCallback(func(WebViewVarp uintptr, RequestVarp uintptr) {
			cb(WebViewNewFromInternalPtr(WebViewVarp), FormSubmissionRequestNewFromInternalPtr(RequestVarp))
		})
	}
}

// GetSubmitForm gets the "submit_form" callback function.
func (x *WebViewClass) GetSubmitForm() func(*WebView, *FormSubmissionRequest) {
	if x.xSubmitForm == 0 {
		return nil
	}
	var rawCallback func(WebViewVarp uintptr, RequestVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xSubmitForm)
	return func(WebViewVar *WebView, RequestVar *FormSubmissionRequest) {
		rawCallback(WebViewVar.GoPointer(), RequestVar.GoPointer())
	}
}

// OverrideInsecureContentDetected sets the "insecure_content_detected" callback function.
func (x *WebViewClass) OverrideInsecureContentDetected(cb func(*WebView, InsecureContentEvent)) {
	if cb == nil {
		x.xInsecureContentDetected = 0
	} else {
		x.xInsecureContentDetected = purego.NewCallback(func(WebViewVarp uintptr, EventVarp InsecureContentEvent) {
			cb(WebViewNewFromInternalPtr(WebViewVarp), EventVarp)
		})
	}
}

// GetInsecureContentDetected gets the "insecure_content_detected" callback function.
func (x *WebViewClass) GetInsecureContentDetected() func(*WebView, InsecureContentEvent) {
	if x.xInsecureContentDetected == 0 {
		return nil
	}
	var rawCallback func(WebViewVarp uintptr, EventVarp InsecureContentEvent)
	purego.RegisterFunc(&rawCallback, x.xInsecureContentDetected)
	return func(WebViewVar *WebView, EventVar InsecureContentEvent) {
		rawCallback(WebViewVar.GoPointer(), EventVar)
	}
}

// OverrideWebProcessCrashed sets the "web_process_crashed" callback function.
func (x *WebViewClass) OverrideWebProcessCrashed(cb func(*WebView) bool) {
	if cb == nil {
		x.xWebProcessCrashed = 0
	} else {
		x.xWebProcessCrashed = purego.NewCallback(func(WebViewVarp uintptr) bool {
			return cb(WebViewNewFromInternalPtr(WebViewVarp))
		})
	}
}

// GetWebProcessCrashed gets the "web_process_crashed" callback function.
func (x *WebViewClass) GetWebProcessCrashed() func(*WebView) bool {
	if x.xWebProcessCrashed == 0 {
		return nil
	}
	var rawCallback func(WebViewVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xWebProcessCrashed)
	return func(WebViewVar *WebView) bool {
		return rawCallback(WebViewVar.GoPointer())
	}
}

// OverrideAuthenticate sets the "authenticate" callback function.
func (x *WebViewClass) OverrideAuthenticate(cb func(*WebView, *AuthenticationRequest) bool) {
	if cb == nil {
		x.xAuthenticate = 0
	} else {
		x.xAuthenticate = purego.NewCallback(func(WebViewVarp uintptr, RequestVarp uintptr) bool {
			return cb(WebViewNewFromInternalPtr(WebViewVarp), AuthenticationRequestNewFromInternalPtr(RequestVarp))
		})
	}
}

// GetAuthenticate gets the "authenticate" callback function.
func (x *WebViewClass) GetAuthenticate() func(*WebView, *AuthenticationRequest) bool {
	if x.xAuthenticate == 0 {
		return nil
	}
	var rawCallback func(WebViewVarp uintptr, RequestVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xAuthenticate)
	return func(WebViewVar *WebView, RequestVar *AuthenticationRequest) bool {
		return rawCallback(WebViewVar.GoPointer(), RequestVar.GoPointer())
	}
}

// OverrideLoadFailedWithTlsErrors sets the "load_failed_with_tls_errors" callback function.
func (x *WebViewClass) OverrideLoadFailedWithTlsErrors(cb func(*WebView, string, *gio.TlsCertificate, gio.TlsCertificateFlags) bool) {
	if cb == nil {
		x.xLoadFailedWithTlsErrors = 0
	} else {
		x.xLoadFailedWithTlsErrors = purego.NewCallback(func(WebViewVarp uintptr, FailingUriVarp string, CertificateVarp uintptr, ErrorsVarp gio.TlsCertificateFlags) bool {
			return cb(WebViewNewFromInternalPtr(WebViewVarp), FailingUriVarp, gio.TlsCertificateNewFromInternalPtr(CertificateVarp), ErrorsVarp)
		})
	}
}

// GetLoadFailedWithTlsErrors gets the "load_failed_with_tls_errors" callback function.
func (x *WebViewClass) GetLoadFailedWithTlsErrors() func(*WebView, string, *gio.TlsCertificate, gio.TlsCertificateFlags) bool {
	if x.xLoadFailedWithTlsErrors == 0 {
		return nil
	}
	var rawCallback func(WebViewVarp uintptr, FailingUriVarp string, CertificateVarp uintptr, ErrorsVarp gio.TlsCertificateFlags) bool
	purego.RegisterFunc(&rawCallback, x.xLoadFailedWithTlsErrors)
	return func(WebViewVar *WebView, FailingUriVar string, CertificateVar *gio.TlsCertificate, ErrorsVar gio.TlsCertificateFlags) bool {
		return rawCallback(WebViewVar.GoPointer(), FailingUriVar, CertificateVar.GoPointer(), ErrorsVar)
	}
}

// OverrideShowNotification sets the "show_notification" callback function.
func (x *WebViewClass) OverrideShowNotification(cb func(*WebView, *Notification) bool) {
	if cb == nil {
		x.xShowNotification = 0
	} else {
		x.xShowNotification = purego.NewCallback(func(WebViewVarp uintptr, NotificationVarp uintptr) bool {
			return cb(WebViewNewFromInternalPtr(WebViewVarp), NotificationNewFromInternalPtr(NotificationVarp))
		})
	}
}

// GetShowNotification gets the "show_notification" callback function.
func (x *WebViewClass) GetShowNotification() func(*WebView, *Notification) bool {
	if x.xShowNotification == 0 {
		return nil
	}
	var rawCallback func(WebViewVarp uintptr, NotificationVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xShowNotification)
	return func(WebViewVar *WebView, NotificationVar *Notification) bool {
		return rawCallback(WebViewVar.GoPointer(), NotificationVar.GoPointer())
	}
}

// OverrideRunColorChooser sets the "run_color_chooser" callback function.
func (x *WebViewClass) OverrideRunColorChooser(cb func(*WebView, *ColorChooserRequest) bool) {
	if cb == nil {
		x.xRunColorChooser = 0
	} else {
		x.xRunColorChooser = purego.NewCallback(func(WebViewVarp uintptr, RequestVarp uintptr) bool {
			return cb(WebViewNewFromInternalPtr(WebViewVarp), ColorChooserRequestNewFromInternalPtr(RequestVarp))
		})
	}
}

// GetRunColorChooser gets the "run_color_chooser" callback function.
func (x *WebViewClass) GetRunColorChooser() func(*WebView, *ColorChooserRequest) bool {
	if x.xRunColorChooser == 0 {
		return nil
	}
	var rawCallback func(WebViewVarp uintptr, RequestVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xRunColorChooser)
	return func(WebViewVar *WebView, RequestVar *ColorChooserRequest) bool {
		return rawCallback(WebViewVar.GoPointer(), RequestVar.GoPointer())
	}
}

// OverrideShowOptionMenu sets the "show_option_menu" callback function.
func (x *WebViewClass) OverrideShowOptionMenu(cb func(*WebView, *OptionMenu, *gdk.Rectangle) bool) {
	if cb == nil {
		x.xShowOptionMenu = 0
	} else {
		x.xShowOptionMenu = purego.NewCallback(func(WebViewVarp uintptr, MenuVarp uintptr, RectangleVarp *gdk.Rectangle) bool {
			return cb(WebViewNewFromInternalPtr(WebViewVarp), OptionMenuNewFromInternalPtr(MenuVarp), RectangleVarp)
		})
	}
}

// GetShowOptionMenu gets the "show_option_menu" callback function.
func (x *WebViewClass) GetShowOptionMenu() func(*WebView, *OptionMenu, *gdk.Rectangle) bool {
	if x.xShowOptionMenu == 0 {
		return nil
	}
	var rawCallback func(WebViewVarp uintptr, MenuVarp uintptr, RectangleVarp *gdk.Rectangle) bool
	purego.RegisterFunc(&rawCallback, x.xShowOptionMenu)
	return func(WebViewVar *WebView, MenuVar *OptionMenu, RectangleVar *gdk.Rectangle) bool {
		return rawCallback(WebViewVar.GoPointer(), MenuVar.GoPointer(), RectangleVar)
	}
}

// OverrideWebProcessTerminated sets the "web_process_terminated" callback function.
func (x *WebViewClass) OverrideWebProcessTerminated(cb func(*WebView, WebProcessTerminationReason)) {
	if cb == nil {
		x.xWebProcessTerminated = 0
	} else {
		x.xWebProcessTerminated = purego.NewCallback(func(WebViewVarp uintptr, ReasonVarp WebProcessTerminationReason) {
			cb(WebViewNewFromInternalPtr(WebViewVarp), ReasonVarp)
		})
	}
}

// GetWebProcessTerminated gets the "web_process_terminated" callback function.
func (x *WebViewClass) GetWebProcessTerminated() func(*WebView, WebProcessTerminationReason) {
	if x.xWebProcessTerminated == 0 {
		return nil
	}
	var rawCallback func(WebViewVarp uintptr, ReasonVarp WebProcessTerminationReason)
	purego.RegisterFunc(&rawCallback, x.xWebProcessTerminated)
	return func(WebViewVar *WebView, ReasonVar WebProcessTerminationReason) {
		rawCallback(WebViewVar.GoPointer(), ReasonVar)
	}
}

// OverrideUserMessageReceived sets the "user_message_received" callback function.
func (x *WebViewClass) OverrideUserMessageReceived(cb func(*WebView, *UserMessage) bool) {
	if cb == nil {
		x.xUserMessageReceived = 0
	} else {
		x.xUserMessageReceived = purego.NewCallback(func(WebViewVarp uintptr, MessageVarp uintptr) bool {
			return cb(WebViewNewFromInternalPtr(WebViewVarp), UserMessageNewFromInternalPtr(MessageVarp))
		})
	}
}

// GetUserMessageReceived gets the "user_message_received" callback function.
func (x *WebViewClass) GetUserMessageReceived() func(*WebView, *UserMessage) bool {
	if x.xUserMessageReceived == 0 {
		return nil
	}
	var rawCallback func(WebViewVarp uintptr, MessageVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xUserMessageReceived)
	return func(WebViewVar *WebView, MessageVar *UserMessage) bool {
		return rawCallback(WebViewVar.GoPointer(), MessageVar.GoPointer())
	}
}

// OverrideQueryPermissionState sets the "query_permission_state" callback function.
func (x *WebViewClass) OverrideQueryPermissionState(cb func(*WebView, *PermissionStateQuery) bool) {
	if cb == nil {
		x.xQueryPermissionState = 0
	} else {
		x.xQueryPermissionState = purego.NewCallback(func(WebViewVarp uintptr, QueryVarp *PermissionStateQuery) bool {
			return cb(WebViewNewFromInternalPtr(WebViewVarp), QueryVarp)
		})
	}
}

// GetQueryPermissionState gets the "query_permission_state" callback function.
func (x *WebViewClass) GetQueryPermissionState() func(*WebView, *PermissionStateQuery) bool {
	if x.xQueryPermissionState == 0 {
		return nil
	}
	var rawCallback func(WebViewVarp uintptr, QueryVarp *PermissionStateQuery) bool
	purego.RegisterFunc(&rawCallback, x.xQueryPermissionState)
	return func(WebViewVar *WebView, QueryVar *PermissionStateQuery) bool {
		return rawCallback(WebViewVar.GoPointer(), QueryVar)
	}
}

// OverrideWebkitReserved0 sets the "_webkit_reserved0" callback function.
func (x *WebViewClass) OverrideWebkitReserved0(cb func()) {
	if cb == nil {
		x.xWebkitReserved0 = 0
	} else {
		x.xWebkitReserved0 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetWebkitReserved0 gets the "_webkit_reserved0" callback function.
func (x *WebViewClass) GetWebkitReserved0() func() {
	if x.xWebkitReserved0 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xWebkitReserved0)
	return func() {
		rawCallback()
	}
}

// OverrideWebkitReserved1 sets the "_webkit_reserved1" callback function.
func (x *WebViewClass) OverrideWebkitReserved1(cb func()) {
	if cb == nil {
		x.xWebkitReserved1 = 0
	} else {
		x.xWebkitReserved1 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetWebkitReserved1 gets the "_webkit_reserved1" callback function.
func (x *WebViewClass) GetWebkitReserved1() func() {
	if x.xWebkitReserved1 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xWebkitReserved1)
	return func() {
		rawCallback()
	}
}

// OverrideWebkitReserved2 sets the "_webkit_reserved2" callback function.
func (x *WebViewClass) OverrideWebkitReserved2(cb func()) {
	if cb == nil {
		x.xWebkitReserved2 = 0
	} else {
		x.xWebkitReserved2 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetWebkitReserved2 gets the "_webkit_reserved2" callback function.
func (x *WebViewClass) GetWebkitReserved2() func() {
	if x.xWebkitReserved2 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xWebkitReserved2)
	return func() {
		rawCallback()
	}
}

// OverrideWebkitReserved3 sets the "_webkit_reserved3" callback function.
func (x *WebViewClass) OverrideWebkitReserved3(cb func()) {
	if cb == nil {
		x.xWebkitReserved3 = 0
	} else {
		x.xWebkitReserved3 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetWebkitReserved3 gets the "_webkit_reserved3" callback function.
func (x *WebViewClass) GetWebkitReserved3() func() {
	if x.xWebkitReserved3 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xWebkitReserved3)
	return func() {
		rawCallback()
	}
}

// OverrideWebkitReserved4 sets the "_webkit_reserved4" callback function.
func (x *WebViewClass) OverrideWebkitReserved4(cb func()) {
	if cb == nil {
		x.xWebkitReserved4 = 0
	} else {
		x.xWebkitReserved4 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetWebkitReserved4 gets the "_webkit_reserved4" callback function.
func (x *WebViewClass) GetWebkitReserved4() func() {
	if x.xWebkitReserved4 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xWebkitReserved4)
	return func() {
		rawCallback()
	}
}

// OverrideWebkitReserved5 sets the "_webkit_reserved5" callback function.
func (x *WebViewClass) OverrideWebkitReserved5(cb func()) {
	if cb == nil {
		x.xWebkitReserved5 = 0
	} else {
		x.xWebkitReserved5 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetWebkitReserved5 gets the "_webkit_reserved5" callback function.
func (x *WebViewClass) GetWebkitReserved5() func() {
	if x.xWebkitReserved5 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xWebkitReserved5)
	return func() {
		rawCallback()
	}
}

// OverrideWebkitReserved6 sets the "_webkit_reserved6" callback function.
func (x *WebViewClass) OverrideWebkitReserved6(cb func()) {
	if cb == nil {
		x.xWebkitReserved6 = 0
	} else {
		x.xWebkitReserved6 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetWebkitReserved6 gets the "_webkit_reserved6" callback function.
func (x *WebViewClass) GetWebkitReserved6() func() {
	if x.xWebkitReserved6 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xWebkitReserved6)
	return func() {
		rawCallback()
	}
}

// OverrideWebkitReserved7 sets the "_webkit_reserved7" callback function.
func (x *WebViewClass) OverrideWebkitReserved7(cb func()) {
	if cb == nil {
		x.xWebkitReserved7 = 0
	} else {
		x.xWebkitReserved7 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetWebkitReserved7 gets the "_webkit_reserved7" callback function.
func (x *WebViewClass) GetWebkitReserved7() func() {
	if x.xWebkitReserved7 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xWebkitReserved7)
	return func() {
		rawCallback()
	}
}

// OverrideWebkitReserved8 sets the "_webkit_reserved8" callback function.
func (x *WebViewClass) OverrideWebkitReserved8(cb func()) {
	if cb == nil {
		x.xWebkitReserved8 = 0
	} else {
		x.xWebkitReserved8 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetWebkitReserved8 gets the "_webkit_reserved8" callback function.
func (x *WebViewClass) GetWebkitReserved8() func() {
	if x.xWebkitReserved8 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xWebkitReserved8)
	return func() {
		rawCallback()
	}
}

// OverrideWebkitReserved9 sets the "_webkit_reserved9" callback function.
func (x *WebViewClass) OverrideWebkitReserved9(cb func()) {
	if cb == nil {
		x.xWebkitReserved9 = 0
	} else {
		x.xWebkitReserved9 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetWebkitReserved9 gets the "_webkit_reserved9" callback function.
func (x *WebViewClass) GetWebkitReserved9() func() {
	if x.xWebkitReserved9 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xWebkitReserved9)
	return func() {
		rawCallback()
	}
}

// OverrideWebkitReserved10 sets the "_webkit_reserved10" callback function.
func (x *WebViewClass) OverrideWebkitReserved10(cb func()) {
	if cb == nil {
		x.xWebkitReserved10 = 0
	} else {
		x.xWebkitReserved10 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetWebkitReserved10 gets the "_webkit_reserved10" callback function.
func (x *WebViewClass) GetWebkitReserved10() func() {
	if x.xWebkitReserved10 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xWebkitReserved10)
	return func() {
		rawCallback()
	}
}

// OverrideWebkitReserved11 sets the "_webkit_reserved11" callback function.
func (x *WebViewClass) OverrideWebkitReserved11(cb func()) {
	if cb == nil {
		x.xWebkitReserved11 = 0
	} else {
		x.xWebkitReserved11 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetWebkitReserved11 gets the "_webkit_reserved11" callback function.
func (x *WebViewClass) GetWebkitReserved11() func() {
	if x.xWebkitReserved11 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xWebkitReserved11)
	return func() {
		rawCallback()
	}
}

// OverrideWebkitReserved12 sets the "_webkit_reserved12" callback function.
func (x *WebViewClass) OverrideWebkitReserved12(cb func()) {
	if cb == nil {
		x.xWebkitReserved12 = 0
	} else {
		x.xWebkitReserved12 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetWebkitReserved12 gets the "_webkit_reserved12" callback function.
func (x *WebViewClass) GetWebkitReserved12() func() {
	if x.xWebkitReserved12 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xWebkitReserved12)
	return func() {
		rawCallback()
	}
}

// OverrideWebkitReserved13 sets the "_webkit_reserved13" callback function.
func (x *WebViewClass) OverrideWebkitReserved13(cb func()) {
	if cb == nil {
		x.xWebkitReserved13 = 0
	} else {
		x.xWebkitReserved13 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetWebkitReserved13 gets the "_webkit_reserved13" callback function.
func (x *WebViewClass) GetWebkitReserved13() func() {
	if x.xWebkitReserved13 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xWebkitReserved13)
	return func() {
		rawCallback()
	}
}

// OverrideWebkitReserved14 sets the "_webkit_reserved14" callback function.
func (x *WebViewClass) OverrideWebkitReserved14(cb func()) {
	if cb == nil {
		x.xWebkitReserved14 = 0
	} else {
		x.xWebkitReserved14 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetWebkitReserved14 gets the "_webkit_reserved14" callback function.
func (x *WebViewClass) GetWebkitReserved14() func() {
	if x.xWebkitReserved14 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xWebkitReserved14)
	return func() {
		rawCallback()
	}
}

// OverrideWebkitReserved15 sets the "_webkit_reserved15" callback function.
func (x *WebViewClass) OverrideWebkitReserved15(cb func()) {
	if cb == nil {
		x.xWebkitReserved15 = 0
	} else {
		x.xWebkitReserved15 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetWebkitReserved15 gets the "_webkit_reserved15" callback function.
func (x *WebViewClass) GetWebkitReserved15() func() {
	if x.xWebkitReserved15 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xWebkitReserved15)
	return func() {
		rawCallback()
	}
}

// OverrideWebkitReserved16 sets the "_webkit_reserved16" callback function.
func (x *WebViewClass) OverrideWebkitReserved16(cb func()) {
	if cb == nil {
		x.xWebkitReserved16 = 0
	} else {
		x.xWebkitReserved16 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetWebkitReserved16 gets the "_webkit_reserved16" callback function.
func (x *WebViewClass) GetWebkitReserved16() func() {
	if x.xWebkitReserved16 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xWebkitReserved16)
	return func() {
		rawCallback()
	}
}

// OverrideWebkitReserved17 sets the "_webkit_reserved17" callback function.
func (x *WebViewClass) OverrideWebkitReserved17(cb func()) {
	if cb == nil {
		x.xWebkitReserved17 = 0
	} else {
		x.xWebkitReserved17 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetWebkitReserved17 gets the "_webkit_reserved17" callback function.
func (x *WebViewClass) GetWebkitReserved17() func() {
	if x.xWebkitReserved17 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xWebkitReserved17)
	return func() {
		rawCallback()
	}
}

// OverrideWebkitReserved18 sets the "_webkit_reserved18" callback function.
func (x *WebViewClass) OverrideWebkitReserved18(cb func()) {
	if cb == nil {
		x.xWebkitReserved18 = 0
	} else {
		x.xWebkitReserved18 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetWebkitReserved18 gets the "_webkit_reserved18" callback function.
func (x *WebViewClass) GetWebkitReserved18() func() {
	if x.xWebkitReserved18 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xWebkitReserved18)
	return func() {
		rawCallback()
	}
}

// OverrideWebkitReserved19 sets the "_webkit_reserved19" callback function.
func (x *WebViewClass) OverrideWebkitReserved19(cb func()) {
	if cb == nil {
		x.xWebkitReserved19 = 0
	} else {
		x.xWebkitReserved19 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetWebkitReserved19 gets the "_webkit_reserved19" callback function.
func (x *WebViewClass) GetWebkitReserved19() func() {
	if x.xWebkitReserved19 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xWebkitReserved19)
	return func() {
		rawCallback()
	}
}

// OverrideWebkitReserved20 sets the "_webkit_reserved20" callback function.
func (x *WebViewClass) OverrideWebkitReserved20(cb func()) {
	if cb == nil {
		x.xWebkitReserved20 = 0
	} else {
		x.xWebkitReserved20 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetWebkitReserved20 gets the "_webkit_reserved20" callback function.
func (x *WebViewClass) GetWebkitReserved20() func() {
	if x.xWebkitReserved20 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xWebkitReserved20)
	return func() {
		rawCallback()
	}
}

// OverrideWebkitReserved21 sets the "_webkit_reserved21" callback function.
func (x *WebViewClass) OverrideWebkitReserved21(cb func()) {
	if cb == nil {
		x.xWebkitReserved21 = 0
	} else {
		x.xWebkitReserved21 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetWebkitReserved21 gets the "_webkit_reserved21" callback function.
func (x *WebViewClass) GetWebkitReserved21() func() {
	if x.xWebkitReserved21 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xWebkitReserved21)
	return func() {
		rawCallback()
	}
}

// OverrideWebkitReserved22 sets the "_webkit_reserved22" callback function.
func (x *WebViewClass) OverrideWebkitReserved22(cb func()) {
	if cb == nil {
		x.xWebkitReserved22 = 0
	} else {
		x.xWebkitReserved22 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetWebkitReserved22 gets the "_webkit_reserved22" callback function.
func (x *WebViewClass) GetWebkitReserved22() func() {
	if x.xWebkitReserved22 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xWebkitReserved22)
	return func() {
		rawCallback()
	}
}

// OverrideWebkitReserved23 sets the "_webkit_reserved23" callback function.
func (x *WebViewClass) OverrideWebkitReserved23(cb func()) {
	if cb == nil {
		x.xWebkitReserved23 = 0
	} else {
		x.xWebkitReserved23 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetWebkitReserved23 gets the "_webkit_reserved23" callback function.
func (x *WebViewClass) GetWebkitReserved23() func() {
	if x.xWebkitReserved23 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xWebkitReserved23)
	return func() {
		rawCallback()
	}
}

// OverrideWebkitReserved24 sets the "_webkit_reserved24" callback function.
func (x *WebViewClass) OverrideWebkitReserved24(cb func()) {
	if cb == nil {
		x.xWebkitReserved24 = 0
	} else {
		x.xWebkitReserved24 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetWebkitReserved24 gets the "_webkit_reserved24" callback function.
func (x *WebViewClass) GetWebkitReserved24() func() {
	if x.xWebkitReserved24 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xWebkitReserved24)
	return func() {
		rawCallback()
	}
}

// OverrideWebkitReserved25 sets the "_webkit_reserved25" callback function.
func (x *WebViewClass) OverrideWebkitReserved25(cb func()) {
	if cb == nil {
		x.xWebkitReserved25 = 0
	} else {
		x.xWebkitReserved25 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetWebkitReserved25 gets the "_webkit_reserved25" callback function.
func (x *WebViewClass) GetWebkitReserved25() func() {
	if x.xWebkitReserved25 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xWebkitReserved25)
	return func() {
		rawCallback()
	}
}

// OverrideWebkitReserved26 sets the "_webkit_reserved26" callback function.
func (x *WebViewClass) OverrideWebkitReserved26(cb func()) {
	if cb == nil {
		x.xWebkitReserved26 = 0
	} else {
		x.xWebkitReserved26 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetWebkitReserved26 gets the "_webkit_reserved26" callback function.
func (x *WebViewClass) GetWebkitReserved26() func() {
	if x.xWebkitReserved26 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xWebkitReserved26)
	return func() {
		rawCallback()
	}
}

// OverrideWebkitReserved27 sets the "_webkit_reserved27" callback function.
func (x *WebViewClass) OverrideWebkitReserved27(cb func()) {
	if cb == nil {
		x.xWebkitReserved27 = 0
	} else {
		x.xWebkitReserved27 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetWebkitReserved27 gets the "_webkit_reserved27" callback function.
func (x *WebViewClass) GetWebkitReserved27() func() {
	if x.xWebkitReserved27 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xWebkitReserved27)
	return func() {
		rawCallback()
	}
}

// OverrideWebkitReserved28 sets the "_webkit_reserved28" callback function.
func (x *WebViewClass) OverrideWebkitReserved28(cb func()) {
	if cb == nil {
		x.xWebkitReserved28 = 0
	} else {
		x.xWebkitReserved28 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetWebkitReserved28 gets the "_webkit_reserved28" callback function.
func (x *WebViewClass) GetWebkitReserved28() func() {
	if x.xWebkitReserved28 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xWebkitReserved28)
	return func() {
		rawCallback()
	}
}

// OverrideWebkitReserved29 sets the "_webkit_reserved29" callback function.
func (x *WebViewClass) OverrideWebkitReserved29(cb func()) {
	if cb == nil {
		x.xWebkitReserved29 = 0
	} else {
		x.xWebkitReserved29 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetWebkitReserved29 gets the "_webkit_reserved29" callback function.
func (x *WebViewClass) GetWebkitReserved29() func() {
	if x.xWebkitReserved29 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xWebkitReserved29)
	return func() {
		rawCallback()
	}
}

// OverrideWebkitReserved30 sets the "_webkit_reserved30" callback function.
func (x *WebViewClass) OverrideWebkitReserved30(cb func()) {
	if cb == nil {
		x.xWebkitReserved30 = 0
	} else {
		x.xWebkitReserved30 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetWebkitReserved30 gets the "_webkit_reserved30" callback function.
func (x *WebViewClass) GetWebkitReserved30() func() {
	if x.xWebkitReserved30 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xWebkitReserved30)
	return func() {
		rawCallback()
	}
}

type WebViewPrivate struct {
	_ structs.HostLayout
}

func (x *WebViewPrivate) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Enum values used to specify options when taking a snapshot
// from a #WebKitWebView.
type SnapshotOptions int

var xSnapshotOptionsGLibType func() types.GType

func SnapshotOptionsGLibType() types.GType {
	return xSnapshotOptionsGLibType()
}

const (

	// Do not include any special options.
	SnapshotOptionsNoneValue SnapshotOptions = 0
	// Whether to include in the
	// snapshot the highlight of the selected content.
	SnapshotOptionsIncludeSelectionHighlightingValue SnapshotOptions = 1
	// Do not fill the background with white before
	// rendering the snapshot. Since 2.8
	SnapshotOptionsTransparentBackgroundValue SnapshotOptions = 2
)

// Enum values previously used to denote the different events which can trigger
// the detection of insecure content. Since 2.46, WebKit generally no longer
// loads insecure content in secure contexts.
type InsecureContentEvent int

var xInsecureContentEventGLibType func() types.GType

func InsecureContentEventGLibType() types.GType {
	return xInsecureContentEventGLibType()
}

const (

	// Insecure content has been detected by
	// trying to execute any kind of logic (e.g. a script) from an
	// untrusted source.
	InsecureContentRunValue InsecureContentEvent = 0
	// Insecure content has been
	// detected by trying to display any kind of resource (e.g. an image)
	// from an untrusted source.
	InsecureContentDisplayedValue InsecureContentEvent = 1
)

// Enum values used to denote the different events that happen during a
// #WebKitWebView load operation.
type LoadEvent int

var xLoadEventGLibType func() types.GType

func LoadEventGLibType() types.GType {
	return xLoadEventGLibType()
}

const (

	// A new load request has been made.
	// No data has been received yet, empty structures have
	// been allocated to perform the load; the load may still
	// fail due to transport issues such as not being able to
	// resolve a name, or connect to a port.
	LoadStartedValue LoadEvent = 0
	// A provisional data source received
	// a server redirect.
	LoadRedirectedValue LoadEvent = 1
	// The content started arriving for a page load.
	// The necessary transport requirements are established, and the
	// load is being performed.
	LoadCommittedValue LoadEvent = 2
	// Load completed. All resources are done loading
	// or there was an error during the load operation.
	LoadFinishedValue LoadEvent = 3
)

// Enum values used to specify the capture state of a media device.
type MediaCaptureState int

var xMediaCaptureStateGLibType func() types.GType

func MediaCaptureStateGLibType() types.GType {
	return xMediaCaptureStateGLibType()
}

const (

	// Media capture is disabled.
	MediaCaptureStateNoneValue MediaCaptureState = 0
	// Media capture is active.
	MediaCaptureStateActiveValue MediaCaptureState = 1
	// Media capture is muted.
	MediaCaptureStateMutedValue MediaCaptureState = 2
)

// Enum values used for determining the type of a policy decision during
// #WebKitWebView::decide-policy.
type PolicyDecisionType int

var xPolicyDecisionTypeGLibType func() types.GType

func PolicyDecisionTypeGLibType() types.GType {
	return xPolicyDecisionTypeGLibType()
}

const (

	// This type of policy decision
	//   is requested when WebKit is about to navigate to a new page in either the
	//   main frame or a subframe. Acceptable policy decisions are either
	//   webkit_policy_decision_use() or webkit_policy_decision_ignore(). This
	//   type of policy decision is always a #WebKitNavigationPolicyDecision.
	PolicyDecisionTypeNavigationActionValue PolicyDecisionType = 0
	// This type of policy decision
	//   is requested when WebKit is about to create a new window. Acceptable policy
	//   decisions are either webkit_policy_decision_use() or
	//   webkit_policy_decision_ignore(). This type of policy decision is always
	//   a #WebKitNavigationPolicyDecision. These decisions are useful for implementing
	//   special actions for new windows, such as forcing the new window to open
	//   in a tab when a keyboard modifier is active or handling a special
	//   target attribute on &lt;a&gt; elements.
	PolicyDecisionTypeNewWindowActionValue PolicyDecisionType = 1
	// This type of decision is used when WebKit has
	//   received a response for a network resource and is about to start the load.
	//   Note that these resources include all subresources of a page such as images
	//   and stylesheets as well as main documents. Appropriate policy responses to
	//   this decision are webkit_policy_decision_use(), webkit_policy_decision_ignore(),
	//   or webkit_policy_decision_download(). This type of policy decision is always
	//   a #WebKitResponsePolicyDecision. This decision is useful for forcing
	//   some types of resources to be downloaded rather than rendered in the WebView
	//   or to block the transfer of resources entirely.
	PolicyDecisionTypeResponseValue PolicyDecisionType = 2
)

// Enum values to specify the different ways in which a #WebKitWebView
// can save its current web page into a self-contained file.
type SaveMode int

var xSaveModeGLibType func() types.GType

func SaveModeGLibType() types.GType {
	return xSaveModeGLibType()
}

const (

	// Save the current page using the MHTML format.
	SaveModeMhtmlValue SaveMode = 0
)

// Enum values used to specify the region from which to get a #WebKitWebView
// snapshot
type SnapshotRegion int

var xSnapshotRegionGLibType func() types.GType

func SnapshotRegionGLibType() types.GType {
	return xSnapshotRegionGLibType()
}

const (

	// Specifies a snapshot only for the area that is
	// visible in the webview
	SnapshotRegionVisibleValue SnapshotRegion = 0
	// A snapshot of the entire document.
	SnapshotRegionFullDocumentValue SnapshotRegion = 1
)

// Enum values used for setting if a #WebKitWebView is intended for
// WebExtensions.
type WebExtensionMode int

var xWebExtensionModeGLibType func() types.GType

func WebExtensionModeGLibType() types.GType {
	return xWebExtensionModeGLibType()
}

const (

	// Not for an extension.
	WebExtensionModeNoneValue WebExtensionMode = 0
	// For a ManifestV2 extension.
	WebExtensionModeManifestv2Value WebExtensionMode = 1
	// For a ManifestV3 extension.
	WebExtensionModeManifestv3Value WebExtensionMode = 2
)

// Enum values used to specify the reason why the web process terminated abnormally.
type WebProcessTerminationReason int

var xWebProcessTerminationReasonGLibType func() types.GType

func WebProcessTerminationReasonGLibType() types.GType {
	return xWebProcessTerminationReasonGLibType()
}

const (

	// the web process crashed.
	WebProcessCrashedValue WebProcessTerminationReason = 0
	// the web process exceeded the memory limit.
	WebProcessExceededMemoryLimitValue WebProcessTerminationReason = 1
	// the web process termination was requested by an API call. Since: 2.34
	WebProcessTerminatedByApiValue WebProcessTerminationReason = 2
)

// The central class of the WPE WebKit and WebKitGTK APIs.
//
// #WebKitWebView is the central class of the WPE WebKit and WebKitGTK
// APIs. It is responsible for managing the drawing of the content and
// forwarding of events. You can load any URI into the #WebKitWebView or
// a data string. With #WebKitSettings you can control various aspects
// of the rendering and loading of the content.
//
// Note that in WebKitGTK, #WebKitWebView is scrollable by itself, so
// you don't need to embed it in a #GtkScrolledWindow.
type WebView struct {
	WebViewBase
}

var xWebViewGLibType func() types.GType

func WebViewGLibType() types.GType {
	return xWebViewGLibType()
}

func WebViewNewFromInternalPtr(ptr uintptr) *WebView {
	cls := &WebView{}
	cls.Ptr = ptr
	return cls
}

var xNewWebView func() uintptr

// Creates a new #WebKitWebView with the default #WebKitWebContext.
//
// Creates a new #WebKitWebView with the default #WebKitWebContext and
// no #WebKitUserContentManager associated with it.
// See also webkit_web_view_new_with_context(),
// webkit_web_view_new_with_user_content_manager(), and
// webkit_web_view_new_with_settings().
func NewWebView() *WebView {
	var cls *WebView

	cret := xNewWebView()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &WebView{}
	cls.Ptr = cret
	return cls
}

var xWebViewCallAsyncJavascriptFunction func(uintptr, string, int, *glib.Variant, uintptr, uintptr, uintptr, uintptr, uintptr)

// Asynchronously call @body with @arguments in the script world with name @world_name of the main frame current context in @web_view.
// The @arguments values must be one of the following types, or contain only the following GVariant types: number, string and dictionary.
// The result of the operation can be a Promise that will be properly passed to the callback.
// If @world_name is %NULL, the default world is used. Any value that is not %NULL is a distin ct world.
// The @source_uri will be shown in exceptions and doesn't affect the behavior of the script.
// When not provided, the document URL is used.
//
// Note that if #WebKitSettings:enable-javascript is %FALSE, this method will do nothing.
// If you want to use this method but still prevent web content from executing its own
// JavaScript, then use #WebKitSettings:enable-javascript-markup.
//
// When the operation is finished, @callback will be called. You can then call
// webkit_web_view_call_async_javascript_function_finish() to get the result of the operation.
//
// This is an example that shows how to pass arguments to a JS function that returns a Promise
// that resolves with the passed argument:
//
// ```c
// static void
// web_view_javascript_finished (GObject      *object,
//
//	GAsyncResult *result,
//	gpointer      user_data)
//
//	{
//	    JSCValue               *value;
//	    GError                 *error = NULL;
//
//	    value = webkit_web_view_call_async_javascript_function_finish (WEBKIT_WEB_VIEW (object), result, &amp;error);
//	    if (!value) {
//	        g_warning ("Error running javascript: %s", error-&gt;message);
//	        g_error_free (error);
//	        return;
//	    }
//
//	    if (jsc_value_is_number (value)) {
//	        gint32        int_value = jsc_value_to_string (value);
//	        JSCException *exception = jsc_context_get_exception (jsc_value_get_context (value));
//	        if (exception)
//	            g_warning ("Error running javascript: %s", jsc_exception_get_message (exception));
//	        else
//	            g_print ("Script result: %d\n", int_value);
//	        g_free (str_value);
//	    } else {
//	        g_warning ("Error running javascript: unexpected return value");
//	    }
//	    g_object_unref (value);
//	}
//
// static void
// web_view_evaluate_promise (WebKitWebView *web_view)
//
//	{
//	    GVariantDict dict;
//	    g_variant_dict_init (&amp;dict, NULL);
//	    g_variant_dict_insert (&amp;dict, "count", "u", 42);
//	    GVariant *args = g_variant_dict_end (&amp;dict);
//	    const gchar *body = "return new Promise((resolve) =&gt; { resolve(count); });";
//	    webkit_web_view_call_async_javascript_function (web_view, body, -1, arguments, NULL, NULL, NULL, web_view_javascript_finished, NULL);
//	}
//
// ```
func (x *WebView) CallAsyncJavascriptFunction(BodyVar string, LengthVar int, ArgumentsVar *glib.Variant, WorldNameVar *string, SourceUriVar *string, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CallbackVarPtr, CallbackVarRef, CallbackVar)
		}
	}

	WorldNameVarPtr := core.GStrdupNullable(WorldNameVar)
	defer core.GFreeNullable(WorldNameVarPtr)

	SourceUriVarPtr := core.GStrdupNullable(SourceUriVar)
	defer core.GFreeNullable(SourceUriVarPtr)

	xWebViewCallAsyncJavascriptFunction(x.GoPointer(), BodyVar, LengthVar, ArgumentsVar, WorldNameVarPtr, SourceUriVarPtr, CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xWebViewCallAsyncJavascriptFunctionFinish func(uintptr, uintptr, **glib.Error) uintptr

// Finish an asynchronous operation started with webkit_web_view_call_async_javascript_function().
func (x *WebView) CallAsyncJavascriptFunctionFinish(ResultVar gio.AsyncResult) (*javascriptcore.Value, error) {
	var cls *javascriptcore.Value
	var cerr *glib.Error

	cret := xWebViewCallAsyncJavascriptFunctionFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &javascriptcore.Value{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xWebViewCanExecuteEditingCommand func(uintptr, string, uintptr, uintptr, uintptr)

// Asynchronously check if it is possible to execute the given editing command.
//
// When the operation is finished, @callback will be called. You can then call
// webkit_web_view_can_execute_editing_command_finish() to get the result of the operation.
func (x *WebView) CanExecuteEditingCommand(CommandVar string, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CallbackVarPtr, CallbackVarRef, CallbackVar)
		}
	}

	xWebViewCanExecuteEditingCommand(x.GoPointer(), CommandVar, CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xWebViewCanExecuteEditingCommandFinish func(uintptr, uintptr, **glib.Error) bool

// Finish an asynchronous operation started with webkit_web_view_can_execute_editing_command().
func (x *WebView) CanExecuteEditingCommandFinish(ResultVar gio.AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := xWebViewCanExecuteEditingCommandFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xWebViewCanGoBack func(uintptr) bool

// Determines whether @web_view has a previous history item.
func (x *WebView) CanGoBack() bool {

	cret := xWebViewCanGoBack(x.GoPointer())
	return cret
}

var xWebViewCanGoForward func(uintptr) bool

// Determines whether @web_view has a next history item.
func (x *WebView) CanGoForward() bool {

	cret := xWebViewCanGoForward(x.GoPointer())
	return cret
}

var xWebViewCanShowMimeType func(uintptr, string) bool

// Whether or not a MIME type can be displayed in @web_view.
func (x *WebView) CanShowMimeType(MimeTypeVar string) bool {

	cret := xWebViewCanShowMimeType(x.GoPointer(), MimeTypeVar)
	return cret
}

var xWebViewDownloadUri func(uintptr, string) uintptr

// Requests downloading of the specified URI string for @web_view.
func (x *WebView) DownloadUri(UriVar string) *Download {
	var cls *Download

	cret := xWebViewDownloadUri(x.GoPointer(), UriVar)

	if cret == 0 {
		return nil
	}
	cls = &Download{}
	cls.Ptr = cret
	return cls
}

var xWebViewEvaluateJavascript func(uintptr, string, int, uintptr, uintptr, uintptr, uintptr, uintptr)

// Asynchronously evaluate @script in the script world with name @world_name of the main frame current context in @web_view.
// If @world_name is %NULL, the default world is used. Any value that is not %NULL is a distinct world.
// The @source_uri will be shown in exceptions and doesn't affect the behavior of the script.
// When not provided, the document URL is used.
//
// Note that if #WebKitSettings:enable-javascript is %FALSE, this method will do nothing.
// If you want to use this method but still prevent web content from executing its own
// JavaScript, then use #WebKitSettings:enable-javascript-markup.
//
// When the operation is finished, @callback will be called. You can then call
// webkit_web_view_evaluate_javascript_finish() to get the result of the operation.
//
// This is an example of using webkit_web_view_evaluate_javascript() with a script returning
// a string:
//
// ```c
// static void
// web_view_javascript_finished (GObject      *object,
//
//	GAsyncResult *result,
//	gpointer      user_data)
//
//	{
//	    JSCValue               *value;
//	    GError                 *error = NULL;
//
//	    value = webkit_web_view_evaluate_javascript_finish (WEBKIT_WEB_VIEW (object), result, &amp;error);
//	    if (!value) {
//	        g_warning ("Error running javascript: %s", error-&gt;message);
//	        g_error_free (error);
//	        return;
//	    }
//
//	    if (jsc_value_is_string (value)) {
//	        gchar        *str_value = jsc_value_to_string (value);
//	        JSCException *exception = jsc_context_get_exception (jsc_value_get_context (value));
//	        if (exception)
//	            g_warning ("Error running javascript: %s", jsc_exception_get_message (exception));
//	        else
//	            g_print ("Script result: %s\n", str_value);
//	        g_free (str_value);
//	    } else {
//	        g_warning ("Error running javascript: unexpected return value");
//	    }
//	    g_object_unref (value);
//	}
//
// static void
// web_view_get_link_url (WebKitWebView *web_view,
//
//	const gchar   *link_id)
//
//	{
//	    gchar *script = g_strdup_printf ("window.document.getElementById('%s').href;", link_id);
//	    webkit_web_view_evaluate_javascript (web_view, script, -1, NULL, NULL, NULL, web_view_javascript_finished, NULL);
//	    g_free (script);
//	}
//
// ```
func (x *WebView) EvaluateJavascript(ScriptVar string, LengthVar int, WorldNameVar *string, SourceUriVar *string, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CallbackVarPtr, CallbackVarRef, CallbackVar)
		}
	}

	WorldNameVarPtr := core.GStrdupNullable(WorldNameVar)
	defer core.GFreeNullable(WorldNameVarPtr)

	SourceUriVarPtr := core.GStrdupNullable(SourceUriVar)
	defer core.GFreeNullable(SourceUriVarPtr)

	xWebViewEvaluateJavascript(x.GoPointer(), ScriptVar, LengthVar, WorldNameVarPtr, SourceUriVarPtr, CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xWebViewEvaluateJavascriptFinish func(uintptr, uintptr, **glib.Error) uintptr

// Finish an asynchronous operation started with webkit_web_view_evaluate_javascript().
func (x *WebView) EvaluateJavascriptFinish(ResultVar gio.AsyncResult) (*javascriptcore.Value, error) {
	var cls *javascriptcore.Value
	var cerr *glib.Error

	cret := xWebViewEvaluateJavascriptFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &javascriptcore.Value{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xWebViewExecuteEditingCommand func(uintptr, string)

// Request to execute the given @command for @web_view.
//
// You can use webkit_web_view_can_execute_editing_command() to check whether
// it's possible to execute the command.
func (x *WebView) ExecuteEditingCommand(CommandVar string) {

	xWebViewExecuteEditingCommand(x.GoPointer(), CommandVar)

}

var xWebViewExecuteEditingCommandWithArgument func(uintptr, string, string)

// Request to execute the given @command with @argument for @web_view.
//
// You can use
// webkit_web_view_can_execute_editing_command() to check whether
// it's possible to execute the command.
func (x *WebView) ExecuteEditingCommandWithArgument(CommandVar string, ArgumentVar string) {

	xWebViewExecuteEditingCommandWithArgument(x.GoPointer(), CommandVar, ArgumentVar)

}

var xWebViewGetAutomationPresentationType func(uintptr) AutomationBrowsingContextPresentation

// Get the presentation type of #WebKitWebView when created for automation.
func (x *WebView) GetAutomationPresentationType() AutomationBrowsingContextPresentation {

	cret := xWebViewGetAutomationPresentationType(x.GoPointer())
	return cret
}

var xWebViewGetBackForwardList func(uintptr) uintptr

// Obtains the #WebKitBackForwardList associated with the given #WebKitWebView.
//
// The #WebKitBackForwardList is owned by the #WebKitWebView.
func (x *WebView) GetBackForwardList() *BackForwardList {
	var cls *BackForwardList

	cret := xWebViewGetBackForwardList(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &BackForwardList{}
	cls.Ptr = cret
	return cls
}

var xWebViewGetBackgroundColor func(uintptr, *gdk.RGBA)

// Gets the color that is used to draw the @web_view background.
//
// Gets the color that is used to draw the @web_view background before
// the actual contents are rendered.
// For more information see also webkit_web_view_set_background_color()
func (x *WebView) GetBackgroundColor(RgbaVar *gdk.RGBA) {

	xWebViewGetBackgroundColor(x.GoPointer(), RgbaVar)

}

var xWebViewGetCameraCaptureState func(uintptr) MediaCaptureState

// Get the camera capture state of a #WebKitWebView.
func (x *WebView) GetCameraCaptureState() MediaCaptureState {

	cret := xWebViewGetCameraCaptureState(x.GoPointer())
	return cret
}

var xWebViewGetContext func(uintptr) uintptr

// Gets the web context of @web_view.
func (x *WebView) GetContext() *WebContext {
	var cls *WebContext

	cret := xWebViewGetContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &WebContext{}
	cls.Ptr = cret
	return cls
}

var xWebViewGetCustomCharset func(uintptr) string

// Returns the current custom character encoding name of @web_view.
func (x *WebView) GetCustomCharset() string {

	cret := xWebViewGetCustomCharset(x.GoPointer())
	return cret
}

var xWebViewGetDefaultContentSecurityPolicy func(uintptr) string

// Gets the configured default Content-Security-Policy.
func (x *WebView) GetDefaultContentSecurityPolicy() string {

	cret := xWebViewGetDefaultContentSecurityPolicy(x.GoPointer())
	return cret
}

var xWebViewGetDisplayCaptureState func(uintptr) MediaCaptureState

// Get the display capture state of a #WebKitWebView.
func (x *WebView) GetDisplayCaptureState() MediaCaptureState {

	cret := xWebViewGetDisplayCaptureState(x.GoPointer())
	return cret
}

var xWebViewGetEditorState func(uintptr) uintptr

// Gets the web editor state of @web_view.
func (x *WebView) GetEditorState() *EditorState {
	var cls *EditorState

	cret := xWebViewGetEditorState(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &EditorState{}
	cls.Ptr = cret
	return cls
}

var xWebViewGetEstimatedLoadProgress func(uintptr) float64

// Gets the value of the #WebKitWebView:estimated-load-progress property.
//
// You can monitor the estimated progress of a load operation by
// connecting to the notify::estimated-load-progress signal of @web_view.
func (x *WebView) GetEstimatedLoadProgress() float64 {

	cret := xWebViewGetEstimatedLoadProgress(x.GoPointer())
	return cret
}

var xWebViewGetFavicon func(uintptr) uintptr

// Returns favicon currently associated to @web_view.
//
// Returns favicon currently associated to @web_view, if any. You can
// connect to notify::favicon signal of @web_view to be notified when
// the favicon is available.
func (x *WebView) GetFavicon() *gdk.Texture {
	var cls *gdk.Texture

	cret := xWebViewGetFavicon(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gdk.Texture{}
	cls.Ptr = cret
	return cls
}

var xWebViewGetFindController func(uintptr) uintptr

// Gets the #WebKitFindController.
//
// Gets the #WebKitFindController that will allow the caller to query
// the #WebKitWebView for the text to look for.
func (x *WebView) GetFindController() *FindController {
	var cls *FindController

	cret := xWebViewGetFindController(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &FindController{}
	cls.Ptr = cret
	return cls
}

var xWebViewGetInputMethodContext func(uintptr) uintptr

// Get the #WebKitInputMethodContext currently in use by @web_view.
//
// Get the #WebKitInputMethodContext currently in use by @web_view, or %NULL if no input method is being used.
func (x *WebView) GetInputMethodContext() *InputMethodContext {
	var cls *InputMethodContext

	cret := xWebViewGetInputMethodContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &InputMethodContext{}
	cls.Ptr = cret
	return cls
}

var xWebViewGetInspector func(uintptr) uintptr

// Get the #WebKitWebInspector associated to @web_view
func (x *WebView) GetInspector() *WebInspector {
	var cls *WebInspector

	cret := xWebViewGetInspector(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &WebInspector{}
	cls.Ptr = cret
	return cls
}

var xWebViewGetIsMuted func(uintptr) bool

// Gets the mute state of @web_view.
func (x *WebView) GetIsMuted() bool {

	cret := xWebViewGetIsMuted(x.GoPointer())
	return cret
}

var xWebViewGetIsWebProcessResponsive func(uintptr) bool

// Get whether the current web process of a #WebKitWebView is responsive.
func (x *WebView) GetIsWebProcessResponsive() bool {

	cret := xWebViewGetIsWebProcessResponsive(x.GoPointer())
	return cret
}

var xWebViewGetMainResource func(uintptr) uintptr

// Return the main resource of @web_view.
func (x *WebView) GetMainResource() *WebResource {
	var cls *WebResource

	cret := xWebViewGetMainResource(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &WebResource{}
	cls.Ptr = cret
	return cls
}

var xWebViewGetMicrophoneCaptureState func(uintptr) MediaCaptureState

// Get the microphone capture state of a #WebKitWebView.
func (x *WebView) GetMicrophoneCaptureState() MediaCaptureState {

	cret := xWebViewGetMicrophoneCaptureState(x.GoPointer())
	return cret
}

var xWebViewGetNetworkSession func(uintptr) uintptr

// Get the #WebKitNetworkSession associated to @web_view.
func (x *WebView) GetNetworkSession() *NetworkSession {
	var cls *NetworkSession

	cret := xWebViewGetNetworkSession(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &NetworkSession{}
	cls.Ptr = cret
	return cls
}

var xWebViewGetPageId func(uintptr) uint64

// Get the identifier of the #WebKitWebPage corresponding to
// the #WebKitWebView
func (x *WebView) GetPageId() uint64 {

	cret := xWebViewGetPageId(x.GoPointer())
	return cret
}

var xWebViewGetSessionState func(uintptr) *WebViewSessionState

// Gets the current session state of @web_view
func (x *WebView) GetSessionState() *WebViewSessionState {

	cret := xWebViewGetSessionState(x.GoPointer())
	return cret
}

var xWebViewGetSettings func(uintptr) uintptr

// Gets the #WebKitSettings currently applied to @web_view.
//
// If no other #WebKitSettings have been explicitly applied to
// @web_view with webkit_web_view_set_settings(), the default
// #WebKitSettings will be returned. This method always returns
// a valid #WebKitSettings object.
// To modify any of the @web_view settings, you can either create
// a new #WebKitSettings object with webkit_settings_new(), setting
// the desired preferences, and then replace the existing @web_view
// settings with webkit_web_view_set_settings() or get the existing
// @web_view settings and update it directly. #WebKitSettings objects
// can be shared by multiple #WebKitWebView&lt;!-- --&gt;s, so modifying
// the settings of a #WebKitWebView would affect other
// #WebKitWebView&lt;!-- --&gt;s using the same #WebKitSettings.
func (x *WebView) GetSettings() *Settings {
	var cls *Settings

	cret := xWebViewGetSettings(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Settings{}
	cls.Ptr = cret
	return cls
}

var xWebViewGetSnapshot func(uintptr, SnapshotRegion, SnapshotOptions, uintptr, uintptr, uintptr)

// Asynchronously retrieves a snapshot of @web_view for @region.
//
// @options specifies how the snapshot should be rendered.
//
// When the operation is finished, @callback will be called. You must
// call webkit_web_view_get_snapshot_finish() to get the result of the
// operation.
func (x *WebView) GetSnapshot(RegionVar SnapshotRegion, OptionsVar SnapshotOptions, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CallbackVarPtr, CallbackVarRef, CallbackVar)
		}
	}

	xWebViewGetSnapshot(x.GoPointer(), RegionVar, OptionsVar, CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xWebViewGetSnapshotFinish func(uintptr, uintptr, **glib.Error) uintptr

// Finishes an asynchronous operation started with webkit_web_view_get_snapshot().
func (x *WebView) GetSnapshotFinish(ResultVar gio.AsyncResult) (*gdk.Texture, error) {
	var cls *gdk.Texture
	var cerr *glib.Error

	cret := xWebViewGetSnapshotFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &gdk.Texture{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xWebViewGetThemeColor func(uintptr, *gdk.RGBA) bool

// Gets the theme color that is specified by the content in the @web_view.
// If the @web_view doesn't have a theme color it will fill the @rgba
// with transparent black content.
func (x *WebView) GetThemeColor(RgbaVar *gdk.RGBA) bool {

	cret := xWebViewGetThemeColor(x.GoPointer(), RgbaVar)
	return cret
}

var xWebViewGetTitle func(uintptr) string

// Gets the value of the #WebKitWebView:title property.
//
// You can connect to notify::title signal of @web_view to
// be notified when the title has been received.
func (x *WebView) GetTitle() string {

	cret := xWebViewGetTitle(x.GoPointer())
	return cret
}

var xWebViewGetTlsInfo func(uintptr, **gio.TlsCertificate, *gio.TlsCertificateFlags) bool

// Retrieves the #GTlsCertificate associated with the main resource of @web_view.
//
// Retrieves the #GTlsCertificate associated with the main resource of @web_view,
// and the #GTlsCertificateFlags showing what problems, if any, have been found
// with that certificate.
// If the connection is not HTTPS, this function returns %FALSE.
// This function should be called after a response has been received from the
// server, so you can connect to #WebKitWebView::load-changed and call this function
// when it's emitted with %WEBKIT_LOAD_COMMITTED event.
//
// Note that this function provides no information about the security of the web
// page if the current #WebKitTLSErrorsPolicy is %WEBKIT_TLS_ERRORS_POLICY_IGNORE,
// as subresources of the page may be controlled by an attacker. This function
// may safely be used to determine the security status of the current page only
// if the current #WebKitTLSErrorsPolicy is %WEBKIT_TLS_ERRORS_POLICY_FAIL, in
// which case subresources that fail certificate verification will be blocked.
func (x *WebView) GetTlsInfo(CertificateVar **gio.TlsCertificate, ErrorsVar *gio.TlsCertificateFlags) bool {

	cret := xWebViewGetTlsInfo(x.GoPointer(), CertificateVar, ErrorsVar)
	return cret
}

var xWebViewGetUri func(uintptr) string

// Returns the current active URI of @web_view.
//
// The active URI might change during
// a load operation:
//
// &lt;orderedlist&gt;
// &lt;listitem&gt;&lt;para&gt;
//
//	When nothing has been loaded yet on @web_view the active URI is %NULL.
//
// &lt;/para&gt;&lt;/listitem&gt;
// &lt;listitem&gt;&lt;para&gt;
//
//	When a new load operation starts the active URI is the requested URI:
//	&lt;itemizedlist&gt;
//	&lt;listitem&gt;&lt;para&gt;
//	  If the load operation was started by webkit_web_view_load_uri(),
//	  the requested URI is the given one.
//	&lt;/para&gt;&lt;/listitem&gt;
//	&lt;listitem&gt;&lt;para&gt;
//	  If the load operation was started by webkit_web_view_load_html(),
//	  the requested URI is "about:blank".
//	&lt;/para&gt;&lt;/listitem&gt;
//	&lt;listitem&gt;&lt;para&gt;
//	  If the load operation was started by webkit_web_view_load_alternate_html(),
//	  the requested URI is content URI provided.
//	&lt;/para&gt;&lt;/listitem&gt;
//	&lt;listitem&gt;&lt;para&gt;
//	  If the load operation was started by webkit_web_view_go_back() or
//	  webkit_web_view_go_forward(), the requested URI is the original URI
//	  of the previous/next item in the #WebKitBackForwardList of @web_view.
//	&lt;/para&gt;&lt;/listitem&gt;
//	&lt;listitem&gt;&lt;para&gt;
//	  If the load operation was started by
//	  webkit_web_view_go_to_back_forward_list_item(), the requested URI
//	  is the opriginal URI of the given #WebKitBackForwardListItem.
//	&lt;/para&gt;&lt;/listitem&gt;
//	&lt;/itemizedlist&gt;
//
// &lt;/para&gt;&lt;/listitem&gt;
// &lt;listitem&gt;&lt;para&gt;
//
//	If there is a server redirection during the load operation,
//	the active URI is the redirected URI. When the signal
//	#WebKitWebView::load-changed is emitted with %WEBKIT_LOAD_REDIRECTED
//	event, the active URI is already updated to the redirected URI.
//
// &lt;/para&gt;&lt;/listitem&gt;
// &lt;listitem&gt;&lt;para&gt;
//
//	When the signal #WebKitWebView::load-changed is emitted
//	with %WEBKIT_LOAD_COMMITTED event, the active URI is the final
//	one and it will not change unless a new load operation is started
//	or a navigation action within the same page is performed.
//
// &lt;/para&gt;&lt;/listitem&gt;
// &lt;/orderedlist&gt;
//
// You can monitor the active URI by connecting to the notify::uri
// signal of @web_view.
func (x *WebView) GetUri() string {

	cret := xWebViewGetUri(x.GoPointer())
	return cret
}

var xWebViewGetUserContentManager func(uintptr) uintptr

// Gets the user content manager associated to @web_view.
func (x *WebView) GetUserContentManager() *UserContentManager {
	var cls *UserContentManager

	cret := xWebViewGetUserContentManager(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &UserContentManager{}
	cls.Ptr = cret
	return cls
}

var xWebViewGetWebExtensionMode func(uintptr) WebExtensionMode

// Get the view's #WebKitWebExtensionMode.
func (x *WebView) GetWebExtensionMode() WebExtensionMode {

	cret := xWebViewGetWebExtensionMode(x.GoPointer())
	return cret
}

var xWebViewGetWebsitePolicies func(uintptr) uintptr

// Gets the default website policies.
//
// Gets the default website policies set on construction in the
// @web_view. These can be overridden on a per-origin basis via the
// #WebKitWebView::decide-policy signal handler.
//
// See also webkit_policy_decision_use_with_policies().
func (x *WebView) GetWebsitePolicies() *WebsitePolicies {
	var cls *WebsitePolicies

	cret := xWebViewGetWebsitePolicies(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &WebsitePolicies{}
	cls.Ptr = cret
	return cls
}

var xWebViewGetWindowProperties func(uintptr) uintptr

// Get the #WebKitWindowProperties object.
//
// Get the #WebKitWindowProperties object containing the properties
// that the window containing @web_view should have.
func (x *WebView) GetWindowProperties() *WindowProperties {
	var cls *WindowProperties

	cret := xWebViewGetWindowProperties(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &WindowProperties{}
	cls.Ptr = cret
	return cls
}

var xWebViewGetZoomLevel func(uintptr) float64

// Set the zoom level of @web_view.
//
// Get the zoom level of @web_view, i.e. the factor by which the
// view contents are scaled with respect to their original size.
func (x *WebView) GetZoomLevel() float64 {

	cret := xWebViewGetZoomLevel(x.GoPointer())
	return cret
}

var xWebViewGoBack func(uintptr)

// Loads the previous history item.
//
// You can monitor the load operation by connecting to
// #WebKitWebView::load-changed signal.
func (x *WebView) GoBack() {

	xWebViewGoBack(x.GoPointer())

}

var xWebViewGoForward func(uintptr)

// Loads the next history item.
//
// You can monitor the load operation by connecting to
// #WebKitWebView::load-changed signal.
func (x *WebView) GoForward() {

	xWebViewGoForward(x.GoPointer())

}

var xWebViewGoToBackForwardListItem func(uintptr, uintptr)

// Loads the specific history item @list_item.
//
// You can monitor the load operation by connecting to
// #WebKitWebView::load-changed signal.
func (x *WebView) GoToBackForwardListItem(ListItemVar *BackForwardListItem) {

	xWebViewGoToBackForwardListItem(x.GoPointer(), ListItemVar.GoPointer())

}

var xWebViewIsControlledByAutomation func(uintptr) bool

// Get whether a #WebKitWebView was created with #WebKitWebView:is-controlled-by-automation
// property enabled.
//
// Only #WebKitWebView&lt;!-- --&gt;s controlled by automation can be used in an
// automation session.
func (x *WebView) IsControlledByAutomation() bool {

	cret := xWebViewIsControlledByAutomation(x.GoPointer())
	return cret
}

var xWebViewIsEditable func(uintptr) bool

// Gets whether the user is allowed to edit the HTML document.
//
// When @web_view is not editable an element in the HTML document can only be edited if the
// CONTENTEDITABLE attribute has been set on the element or one of its parent
// elements. By default a #WebKitWebView is not editable.
func (x *WebView) IsEditable() bool {

	cret := xWebViewIsEditable(x.GoPointer())
	return cret
}

var xWebViewIsLoading func(uintptr) bool

// Gets the value of the #WebKitWebView:is-loading property.
//
// You can monitor when a #WebKitWebView is loading a page by connecting to
// notify::is-loading signal of @web_view. This is useful when you are
// interesting in knowing when the view is loading something but not in the
// details about the status of the load operation, for example to start a spinner
// when the view is loading a page and stop it when it finishes.
func (x *WebView) IsLoading() bool {

	cret := xWebViewIsLoading(x.GoPointer())
	return cret
}

var xWebViewIsPlayingAudio func(uintptr) bool

// Gets the value of the #WebKitWebView:is-playing-audio property.
//
// You can monitor when a page in a #WebKitWebView is playing audio by
// connecting to the notify::is-playing-audio signal of @web_view. This
// is useful when the application wants to provide visual feedback when a
// page is producing sound.
func (x *WebView) IsPlayingAudio() bool {

	cret := xWebViewIsPlayingAudio(x.GoPointer())
	return cret
}

var xWebViewLoadAlternateHtml func(uintptr, string, string, uintptr)

// Load the given @content string for the URI @content_uri.
//
// This allows clients to display page-loading errors in the #WebKitWebView itself.
// When this method is called from #WebKitWebView::load-failed signal to show an
// error page, then the back-forward list is maintained appropriately.
// For everything else this method works the same way as webkit_web_view_load_html().
func (x *WebView) LoadAlternateHtml(ContentVar string, ContentUriVar string, BaseUriVar *string) {

	BaseUriVarPtr := core.GStrdupNullable(BaseUriVar)
	defer core.GFreeNullable(BaseUriVarPtr)

	xWebViewLoadAlternateHtml(x.GoPointer(), ContentVar, ContentUriVar, BaseUriVarPtr)

}

var xWebViewLoadBytes func(uintptr, *glib.Bytes, uintptr, uintptr, uintptr)

// Load the specified @bytes into @web_view using the given @mime_type and @encoding.
//
// When @mime_type is %NULL, it defaults to "text/html".
// When @encoding is %NULL, it defaults to "UTF-8".
// When @base_uri is %NULL, it defaults to "about:blank".
// You can monitor the load operation by connecting to #WebKitWebView::load-changed signal.
func (x *WebView) LoadBytes(BytesVar *glib.Bytes, MimeTypeVar *string, EncodingVar *string, BaseUriVar *string) {

	MimeTypeVarPtr := core.GStrdupNullable(MimeTypeVar)
	defer core.GFreeNullable(MimeTypeVarPtr)

	EncodingVarPtr := core.GStrdupNullable(EncodingVar)
	defer core.GFreeNullable(EncodingVarPtr)

	BaseUriVarPtr := core.GStrdupNullable(BaseUriVar)
	defer core.GFreeNullable(BaseUriVarPtr)

	xWebViewLoadBytes(x.GoPointer(), BytesVar, MimeTypeVarPtr, EncodingVarPtr, BaseUriVarPtr)

}

var xWebViewLoadHtml func(uintptr, string, uintptr)

// Load the given @content string with the specified @base_uri.
//
// If @base_uri is not %NULL, relative URLs in the @content will be
// resolved against @base_uri and absolute local paths must be children of the @base_uri.
// For security reasons absolute local paths that are not children of @base_uri
// will cause the web process to terminate.
// If you need to include URLs in @content that are local paths in a different
// directory than @base_uri you can build a data URI for them. When @base_uri is %NULL,
// it defaults to "about:blank". The mime type of the document will be "text/html".
// You can monitor the load operation by connecting to #WebKitWebView::load-changed signal.
func (x *WebView) LoadHtml(ContentVar string, BaseUriVar *string) {

	BaseUriVarPtr := core.GStrdupNullable(BaseUriVar)
	defer core.GFreeNullable(BaseUriVarPtr)

	xWebViewLoadHtml(x.GoPointer(), ContentVar, BaseUriVarPtr)

}

var xWebViewLoadPlainText func(uintptr, string)

// Load the specified @plain_text string into @web_view.
//
// The mime type of document will be "text/plain". You can monitor the load
// operation by connecting to #WebKitWebView::load-changed signal.
func (x *WebView) LoadPlainText(PlainTextVar string) {

	xWebViewLoadPlainText(x.GoPointer(), PlainTextVar)

}

var xWebViewLoadRequest func(uintptr, uintptr)

// Requests loading of the specified #WebKitURIRequest.
//
// You can monitor the load operation by connecting to
// #WebKitWebView::load-changed signal.
func (x *WebView) LoadRequest(RequestVar *URIRequest) {

	xWebViewLoadRequest(x.GoPointer(), RequestVar.GoPointer())

}

var xWebViewLoadUri func(uintptr, string)

// Requests loading of the specified URI string.
//
// You can monitor the load operation by connecting to
// #WebKitWebView::load-changed signal.
func (x *WebView) LoadUri(UriVar string) {

	xWebViewLoadUri(x.GoPointer(), UriVar)

}

var xWebViewReload func(uintptr)

// Reloads the current contents of @web_view.
//
// See also webkit_web_view_reload_bypass_cache().
func (x *WebView) Reload() {

	xWebViewReload(x.GoPointer())

}

var xWebViewReloadBypassCache func(uintptr)

// Reloads the current contents of @web_view without
// using any cached data.
func (x *WebView) ReloadBypassCache() {

	xWebViewReloadBypassCache(x.GoPointer())

}

var xWebViewRestoreSessionState func(uintptr, *WebViewSessionState)

// Restore the @web_view session state from @state
func (x *WebView) RestoreSessionState(StateVar *WebViewSessionState) {

	xWebViewRestoreSessionState(x.GoPointer(), StateVar)

}

var xWebViewSave func(uintptr, SaveMode, uintptr, uintptr, uintptr)

// Asynchronously save the current web page.
//
// Asynchronously save the current web page associated to the
// #WebKitWebView into a self-contained format using the mode
// specified in @save_mode.
//
// When the operation is finished, @callback will be called. You can
// then call webkit_web_view_save_finish() to get the result of the
// operation.
func (x *WebView) Save(SaveModeVar SaveMode, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CallbackVarPtr, CallbackVarRef, CallbackVar)
		}
	}

	xWebViewSave(x.GoPointer(), SaveModeVar, CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xWebViewSaveFinish func(uintptr, uintptr, **glib.Error) uintptr

// Finish an asynchronous operation started with webkit_web_view_save().
func (x *WebView) SaveFinish(ResultVar gio.AsyncResult) (*gio.InputStream, error) {
	var cls *gio.InputStream
	var cerr *glib.Error

	cret := xWebViewSaveFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &gio.InputStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xWebViewSaveToFile func(uintptr, uintptr, SaveMode, uintptr, uintptr, uintptr)

// Asynchronously save the current web page.
//
// Asynchronously save the current web page associated to the
// #WebKitWebView into a self-contained format using the mode
// specified in @save_mode and writing it to @file.
//
// When the operation is finished, @callback will be called. You can
// then call webkit_web_view_save_to_file_finish() to get the result of the
// operation.
func (x *WebView) SaveToFile(FileVar gio.File, SaveModeVar SaveMode, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CallbackVarPtr, CallbackVarRef, CallbackVar)
		}
	}

	xWebViewSaveToFile(x.GoPointer(), FileVar.GoPointer(), SaveModeVar, CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xWebViewSaveToFileFinish func(uintptr, uintptr, **glib.Error) bool

// Finish an asynchronous operation started with webkit_web_view_save_to_file().
func (x *WebView) SaveToFileFinish(ResultVar gio.AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := xWebViewSaveToFileFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xWebViewSendMessageToPage func(uintptr, uintptr, uintptr, uintptr, uintptr)

// Send @message to the #WebKitWebPage corresponding to @web_view.
//
// If @message is floating, it's consumed.
// If you don't expect any reply, or you simply want to ignore it, you can pass %NULL as @callback.
// When the operation is finished, @callback will be called. You can then call
// webkit_web_view_send_message_to_page_finish() to get the message reply.
func (x *WebView) SendMessageToPage(MessageVar *UserMessage, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CallbackVarPtr, CallbackVarRef, CallbackVar)
		}
	}

	xWebViewSendMessageToPage(x.GoPointer(), MessageVar.GoPointer(), CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xWebViewSendMessageToPageFinish func(uintptr, uintptr, **glib.Error) uintptr

// Finish an asynchronous operation started with webkit_web_view_send_message_to_page().
func (x *WebView) SendMessageToPageFinish(ResultVar gio.AsyncResult) (*UserMessage, error) {
	var cls *UserMessage
	var cerr *glib.Error

	cret := xWebViewSendMessageToPageFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &UserMessage{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xWebViewSetBackgroundColor func(uintptr, *gdk.RGBA)

// Sets the color that will be used to draw the @web_view background.
//
// Sets the color that will be used to draw the @web_view background before
// the actual contents are rendered. Note that if the web page loaded in @web_view
// specifies a background color, it will take precedence over the @rgba color.
// By default the @web_view background color is opaque white.
func (x *WebView) SetBackgroundColor(RgbaVar *gdk.RGBA) {

	xWebViewSetBackgroundColor(x.GoPointer(), RgbaVar)

}

var xWebViewSetCameraCaptureState func(uintptr, MediaCaptureState)

// Set the camera capture state of a #WebKitWebView.
//
// If #WebKitSettings:enable-mediastream is %FALSE, this method will have no visible effect. Once the
// state of the device has been set to %WEBKIT_MEDIA_CAPTURE_STATE_NONE it cannot be changed
// anymore. The page can however request capture again using the mediaDevices API.
func (x *WebView) SetCameraCaptureState(StateVar MediaCaptureState) {

	xWebViewSetCameraCaptureState(x.GoPointer(), StateVar)

}

var xWebViewSetCorsAllowlist func(uintptr, []string)

// Sets the @allowlist for CORS.
//
// Sets the @allowlist for which
// [Cross-Origin Resource Sharing](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)
// checks are disabled in @web_view. URI patterns must be of the form
// `[protocol]://[host]/[path]`, each component may contain the wildcard
// character (`*`) to represent zero or more other characters. All three
// components are required and must not be omitted from the URI
// patterns.
//
// Disabling CORS checks permits resources from other origins to load
// allowlisted resources. It does not permit the allowlisted resources
// to load resources from other origins.
//
// If this function is called multiple times, only the allowlist set by
// the most recent call will be effective.
func (x *WebView) SetCorsAllowlist(AllowlistVar []string) {

	xWebViewSetCorsAllowlist(x.GoPointer(), AllowlistVar)

}

var xWebViewSetCustomCharset func(uintptr, uintptr)

// Sets the current custom character encoding override of @web_view.
//
// The custom character encoding will override any text encoding detected via HTTP headers or
// META tags. Calling this method will stop any current load operation and reload the
// current page. Setting the custom character encoding to %NULL removes the character
// encoding override.
func (x *WebView) SetCustomCharset(CharsetVar *string) {

	CharsetVarPtr := core.GStrdupNullable(CharsetVar)
	defer core.GFreeNullable(CharsetVarPtr)

	xWebViewSetCustomCharset(x.GoPointer(), CharsetVarPtr)

}

var xWebViewSetDisplayCaptureState func(uintptr, MediaCaptureState)

// Set the display capture state of a #WebKitWebView.
//
// If #WebKitSettings:enable-mediastream is %FALSE, this method will have no visible effect. Once the
// state of the device has been set to %WEBKIT_MEDIA_CAPTURE_STATE_NONE it cannot be changed
// anymore. The page can however request capture again using the mediaDevices API.
func (x *WebView) SetDisplayCaptureState(StateVar MediaCaptureState) {

	xWebViewSetDisplayCaptureState(x.GoPointer(), StateVar)

}

var xWebViewSetEditable func(uintptr, bool)

// Sets whether the user is allowed to edit the HTML document.
//
// If @editable is %TRUE, @web_view allows the user to edit the HTML document. If
// @editable is %FALSE, an element in @web_view's document can only be edited if the
// CONTENTEDITABLE attribute has been set on the element or one of its parent
// elements. By default a #WebKitWebView is not editable.
//
// Normally, a HTML document is not editable unless the elements within the
// document are editable. This function provides a way to make the contents
// of a #WebKitWebView editable without altering the document or DOM structure.
func (x *WebView) SetEditable(EditableVar bool) {

	xWebViewSetEditable(x.GoPointer(), EditableVar)

}

var xWebViewSetInputMethodContext func(uintptr, uintptr)

// Set the #WebKitInputMethodContext to be used by @web_view.
//
// Set the #WebKitInputMethodContext to be used by @web_view, or %NULL to not use any input method.
// Note that the same #WebKitInputMethodContext can't be set on more than one #WebKitWebView at the same time.
func (x *WebView) SetInputMethodContext(ContextVar *InputMethodContext) {

	xWebViewSetInputMethodContext(x.GoPointer(), ContextVar.GoPointer())

}

var xWebViewSetIsMuted func(uintptr, bool)

// Sets the mute state of @web_view.
func (x *WebView) SetIsMuted(MutedVar bool) {

	xWebViewSetIsMuted(x.GoPointer(), MutedVar)

}

var xWebViewSetMicrophoneCaptureState func(uintptr, MediaCaptureState)

// Set the microphone capture state of a #WebKitWebView.
//
// If #WebKitSettings:enable-mediastream is %FALSE, this method will have no visible effect. Once the
// state of the device has been set to %WEBKIT_MEDIA_CAPTURE_STATE_NONE it cannot be changed
// anymore. The page can however request capture again using the mediaDevices API.
func (x *WebView) SetMicrophoneCaptureState(StateVar MediaCaptureState) {

	xWebViewSetMicrophoneCaptureState(x.GoPointer(), StateVar)

}

var xWebViewSetSettings func(uintptr, uintptr)

// Sets the #WebKitSettings to be applied to @web_view.
//
// The
// existing #WebKitSettings of @web_view will be replaced by
// @settings. New settings are applied immediately on @web_view.
// The same #WebKitSettings object can be shared
// by multiple #WebKitWebView&lt;!-- --&gt;s.
func (x *WebView) SetSettings(SettingsVar *Settings) {

	xWebViewSetSettings(x.GoPointer(), SettingsVar.GoPointer())

}

var xWebViewSetZoomLevel func(uintptr, float64)

// Set the zoom level of @web_view.
//
// Set the zoom level of @web_view, i.e. the factor by which the
// view contents are scaled with respect to their original size.
func (x *WebView) SetZoomLevel(ZoomLevelVar float64) {

	xWebViewSetZoomLevel(x.GoPointer(), ZoomLevelVar)

}

var xWebViewStopLoading func(uintptr)

// Stops any ongoing loading operation in @web_view.
//
// This method does nothing if no content is being loaded.
// If there is a loading operation in progress, it will be cancelled and
// #WebKitWebView::load-failed signal will be emitted with
// %WEBKIT_NETWORK_ERROR_CANCELLED error.
func (x *WebView) StopLoading() {

	xWebViewStopLoading(x.GoPointer())

}

var xWebViewTerminateWebProcess func(uintptr)

// Terminates the web process associated to @web_view.
//
// When the web process gets terminated
// using this method, the #WebKitWebView::web-process-terminated signal is emitted with
// %WEBKIT_WEB_PROCESS_TERMINATED_BY_API as the reason for termination.
func (x *WebView) TerminateWebProcess() {

	xWebViewTerminateWebProcess(x.GoPointer())

}

var xWebViewTryClose func(uintptr)

// Tries to close the @web_view.
//
// This will fire the onbeforeunload event
// to ask the user for confirmation to close the page. If there isn't an
// onbeforeunload event handler or the user confirms to close the page,
// the #WebKitWebView::close signal is emitted, otherwise nothing happens.
func (x *WebView) TryClose() {

	xWebViewTryClose(x.GoPointer())

}

func (c *WebView) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *WebView) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyDefaultContentSecurityPolicy sets the "default-content-security-policy" property.
// The default Content-Security-Policy used by the webview as if it were set
// by an HTTP header.
//
// This applies to all content loaded including through navigation or via the various
// webkit_web_view_load_\* APIs. However do note that many WebKit APIs bypass
// Content-Security-Policy in general such as #WebKitUserContentManager and
// webkit_web_view_run_javascript().
//
// Policies are additive so if a website sets its own policy it still applies
// on top of the policy set here.
func (x *WebView) SetPropertyDefaultContentSecurityPolicy(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("default-content-security-policy", &v)
}

// GetPropertyDefaultContentSecurityPolicy gets the "default-content-security-policy" property.
// The default Content-Security-Policy used by the webview as if it were set
// by an HTTP header.
//
// This applies to all content loaded including through navigation or via the various
// webkit_web_view_load_\* APIs. However do note that many WebKit APIs bypass
// Content-Security-Policy in general such as #WebKitUserContentManager and
// webkit_web_view_run_javascript().
//
// Policies are additive so if a website sets its own policy it still applies
// on top of the policy set here.
func (x *WebView) GetPropertyDefaultContentSecurityPolicy() string {
	var v gobject.Value
	x.GetProperty("default-content-security-policy", &v)
	return v.GetString()
}

// SetPropertyEditable sets the "editable" property.
// Whether the pages loaded inside #WebKitWebView are editable. For more
// information see webkit_web_view_set_editable().
func (x *WebView) SetPropertyEditable(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("editable", &v)
}

// GetPropertyEditable gets the "editable" property.
// Whether the pages loaded inside #WebKitWebView are editable. For more
// information see webkit_web_view_set_editable().
func (x *WebView) GetPropertyEditable() bool {
	var v gobject.Value
	x.GetProperty("editable", &v)
	return v.GetBoolean()
}

// GetPropertyEstimatedLoadProgress gets the "estimated-load-progress" property.
// An estimate of the percent completion for the current loading operation.
// This value will range from 0.0 to 1.0 and, once a load completes,
// will remain at 1.0 until a new load starts, at which point it
// will be reset to 0.0.
// The value is an estimate based on the total number of bytes expected
// to be received for a document, including all its possible subresources
// and child documents.
func (x *WebView) GetPropertyEstimatedLoadProgress() float64 {
	var v gobject.Value
	x.GetProperty("estimated-load-progress", &v)
	return v.GetDouble()
}

// SetPropertyIsControlledByAutomation sets the "is-controlled-by-automation" property.
// Whether the #WebKitWebView is controlled by automation tools (e.g. WebDriver, Selenium). This is
// required for views returned as a response to #WebKitAutomationSession::create-web-view signal,
// alongside any view you want to control during an automation session.
//
// As a %G_PARAM_CONSTRUCT_ONLY, you need to set it during construction and it can't be modified.
//
// If #WebKitWebView:related-view is also passed during construction, #WebKitWebView:is-controlled-by-automation
// ignores its own parameter and inherits directly from the related view #WebKitWebView:is-controlled-by-automation
// property. This is the recommended way when creating new views as a response to the #WebKitWebView::create
// signal. For example, as response to JavaScript `window.open()` calls during an automation session.
func (x *WebView) SetPropertyIsControlledByAutomation(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("is-controlled-by-automation", &v)
}

// GetPropertyIsControlledByAutomation gets the "is-controlled-by-automation" property.
// Whether the #WebKitWebView is controlled by automation tools (e.g. WebDriver, Selenium). This is
// required for views returned as a response to #WebKitAutomationSession::create-web-view signal,
// alongside any view you want to control during an automation session.
//
// As a %G_PARAM_CONSTRUCT_ONLY, you need to set it during construction and it can't be modified.
//
// If #WebKitWebView:related-view is also passed during construction, #WebKitWebView:is-controlled-by-automation
// ignores its own parameter and inherits directly from the related view #WebKitWebView:is-controlled-by-automation
// property. This is the recommended way when creating new views as a response to the #WebKitWebView::create
// signal. For example, as response to JavaScript `window.open()` calls during an automation session.
func (x *WebView) GetPropertyIsControlledByAutomation() bool {
	var v gobject.Value
	x.GetProperty("is-controlled-by-automation", &v)
	return v.GetBoolean()
}

// GetPropertyIsLoading gets the "is-loading" property.
// Whether the #WebKitWebView is currently loading a page. This property becomes
// %TRUE as soon as a new load operation is requested and before the
// #WebKitWebView::load-changed signal is emitted with %WEBKIT_LOAD_STARTED and
// at that point the active URI is the requested one.
// When the load operation finishes the property is set to %FALSE before
// #WebKitWebView::load-changed is emitted with %WEBKIT_LOAD_FINISHED.
func (x *WebView) GetPropertyIsLoading() bool {
	var v gobject.Value
	x.GetProperty("is-loading", &v)
	return v.GetBoolean()
}

// SetPropertyIsMuted sets the "is-muted" property.
// Whether the #WebKitWebView audio is muted. When %TRUE, audio is silenced.
// It may still be playing, i.e. #WebKitWebView:is-playing-audio may be %TRUE.
func (x *WebView) SetPropertyIsMuted(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("is-muted", &v)
}

// GetPropertyIsMuted gets the "is-muted" property.
// Whether the #WebKitWebView audio is muted. When %TRUE, audio is silenced.
// It may still be playing, i.e. #WebKitWebView:is-playing-audio may be %TRUE.
func (x *WebView) GetPropertyIsMuted() bool {
	var v gobject.Value
	x.GetProperty("is-muted", &v)
	return v.GetBoolean()
}

// GetPropertyIsPlayingAudio gets the "is-playing-audio" property.
// Whether the #WebKitWebView is currently playing audio from a page.
// This property becomes %TRUE as soon as web content starts playing any
// kind of audio. When a page is no longer playing any kind of sound,
// the property is set back to %FALSE.
func (x *WebView) GetPropertyIsPlayingAudio() bool {
	var v gobject.Value
	x.GetProperty("is-playing-audio", &v)
	return v.GetBoolean()
}

// GetPropertyIsWebProcessResponsive gets the "is-web-process-responsive" property.
// Whether the web process currently associated to the #WebKitWebView is responsive.
func (x *WebView) GetPropertyIsWebProcessResponsive() bool {
	var v gobject.Value
	x.GetProperty("is-web-process-responsive", &v)
	return v.GetBoolean()
}

// GetPropertyPageId gets the "page-id" property.
// The identifier of the #WebKitWebPage corresponding to the #WebKitWebView.
func (x *WebView) GetPropertyPageId() uint64 {
	var v gobject.Value
	x.GetProperty("page-id", &v)
	return v.GetUint64()
}

// GetPropertyThemeColor gets the "theme-color" property.
// The theme color of the WebView's current page.
func (x *WebView) GetPropertyThemeColor() uintptr {
	var v gobject.Value
	x.GetProperty("theme-color", &v)
	return v.GetPointer()
}

// GetPropertyTitle gets the "title" property.
// The main frame document title of this #WebKitWebView. If
// the title has not been received yet, it will be %NULL.
func (x *WebView) GetPropertyTitle() string {
	var v gobject.Value
	x.GetProperty("title", &v)
	return v.GetString()
}

// GetPropertyUri gets the "uri" property.
// The current active URI of the #WebKitWebView.
// See webkit_web_view_get_uri() for more details.
func (x *WebView) GetPropertyUri() string {
	var v gobject.Value
	x.GetProperty("uri", &v)
	return v.GetString()
}

// SetPropertyZoomLevel sets the "zoom-level" property.
// The zoom level of the #WebKitWebView content.
// See webkit_web_view_set_zoom_level() for more details.
func (x *WebView) SetPropertyZoomLevel(value float64) {
	var v gobject.Value
	v.Init(gobject.TypeDoubleVal)
	v.SetDouble(value)
	x.SetProperty("zoom-level", &v)
}

// GetPropertyZoomLevel gets the "zoom-level" property.
// The zoom level of the #WebKitWebView content.
// See webkit_web_view_set_zoom_level() for more details.
func (x *WebView) GetPropertyZoomLevel() float64 {
	var v gobject.Value
	x.GetProperty("zoom-level", &v)
	return v.GetDouble()
}

// This signal is emitted when the user is challenged with HTTP
// authentication. To let the  application access or supply
// the credentials as well as to allow the client application
// to either cancel the request or perform the authentication,
// the signal will pass an instance of the
// #WebKitAuthenticationRequest in the @request argument.
// To handle this signal asynchronously you should keep a ref
// of the request and return %TRUE. To disable HTTP authentication
// entirely, connect to this signal and simply return %TRUE.
//
// The default signal handler will run a default authentication
// dialog asynchronously for the user to interact with.
func (x *WebView) ConnectAuthenticate(cb *func(WebView, uintptr) bool) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "authenticate", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, RequestVarp uintptr) bool {
		fa := WebView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, RequestVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "authenticate", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Emitted when closing a #WebKitWebView is requested. This occurs when a
// call is made from JavaScript's &lt;function&gt;window.close&lt;/function&gt; function or
// after trying to close the @web_view with webkit_web_view_try_close().
// It is the owner's responsibility to handle this signal to hide or
// destroy the #WebKitWebView, if necessary.
func (x *WebView) ConnectClose(cb *func(WebView)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "close", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) {
		fa := WebView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "close", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Emitted when a context menu is about to be displayed to give the application
// a chance to customize the proposed menu, prevent the menu from being displayed,
// or build its own context menu.
// &lt;itemizedlist&gt;
// &lt;listitem&gt;&lt;para&gt;
//
//	To customize the proposed menu you can use webkit_context_menu_prepend(),
//	webkit_context_menu_append() or webkit_context_menu_insert() to add new
//	#WebKitContextMenuItem&lt;!-- --&gt;s to @context_menu, webkit_context_menu_move_item()
//	to reorder existing items, or webkit_context_menu_remove() to remove an
//	existing item. The signal handler should return %FALSE, and the menu represented
//	by @context_menu will be shown.
//
// &lt;/para&gt;&lt;/listitem&gt;
// &lt;listitem&gt;&lt;para&gt;
//
//	To prevent the menu from being displayed you can just connect to this signal
//	and return %TRUE so that the proposed menu will not be shown.
//
// &lt;/para&gt;&lt;/listitem&gt;
// &lt;listitem&gt;&lt;para&gt;
//
//	To build your own menu, you can remove all items from the proposed menu with
//	webkit_context_menu_remove_all(), add your own items and return %FALSE so
//	that the menu will be shown. You can also ignore the proposed #WebKitContextMenu,
//	build your own #GtkMenu and return %TRUE to prevent the proposed menu from being shown.
//
// &lt;/para&gt;&lt;/listitem&gt;
// &lt;listitem&gt;&lt;para&gt;
//
//	If you just want the default menu to be shown always, simply don't connect to this
//	signal because showing the proposed context menu is the default behaviour.
//
// &lt;/para&gt;&lt;/listitem&gt;
// &lt;/itemizedlist&gt;
//
// If the signal handler returns %FALSE the context menu represented by @context_menu
// will be shown, if it return %TRUE the context menu will not be shown.
//
// The proposed #WebKitContextMenu passed in @context_menu argument is only valid
// during the signal emission.
func (x *WebView) ConnectContextMenu(cb *func(WebView, uintptr, uintptr) bool) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "context-menu", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, ContextMenuVarp uintptr, HitTestResultVarp uintptr) bool {
		fa := WebView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, ContextMenuVarp, HitTestResultVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "context-menu", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Emitted after #WebKitWebView::context-menu signal, if the context menu is shown,
// to notify that the context menu is dismissed.
func (x *WebView) ConnectContextMenuDismissed(cb *func(WebView)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "context-menu-dismissed", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) {
		fa := WebView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "context-menu-dismissed", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Emitted when the creation of a new #WebKitWebView is requested.
// If this signal is handled the signal handler should return the
// newly created #WebKitWebView.
//
// The #WebKitNavigationAction parameter contains information about the
// navigation action that triggered this signal.
//
// The new #WebKitWebView must be related to @web_view, see
// #WebKitWebView:related-view for more details.
//
// The new #WebKitWebView should not be displayed to the user
// until the #WebKitWebView::ready-to-show signal is emitted.
//
// For creating views as response to automation tools requests, see the
// #WebKitAutomationSession::create-web-view signal.
func (x *WebView) ConnectCreate(cb *func(WebView, uintptr) gtk.Widget) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "create", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, NavigationActionVarp uintptr) uintptr {
		fa := WebView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		CreateCls := cbFn(fa, NavigationActionVarp)
		return CreateCls.Ptr

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "create", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// This signal is emitted when WebKit is requesting the client to decide a policy
// decision, such as whether to navigate to a page, open a new window or whether or
// not to download a resource. The #WebKitNavigationPolicyDecision passed in the
// @decision argument is a generic type, but should be casted to a more
// specific type when making the decision. For example:
//
// ```c
// static gboolean
// decide_policy_cb (WebKitWebView *web_view,
//
//	WebKitPolicyDecision *decision,
//	WebKitPolicyDecisionType type)
//
//	{
//	    switch (type) {
//	    case WEBKIT_POLICY_DECISION_TYPE_NAVIGATION_ACTION: {
//	        WebKitNavigationPolicyDecision *navigation_decision = WEBKIT_NAVIGATION_POLICY_DECISION (decision);
//	        // Make a policy decision here
//	        break;
//	    }
//	    case WEBKIT_POLICY_DECISION_TYPE_NEW_WINDOW_ACTION: {
//	        WebKitNavigationPolicyDecision *navigation_decision = WEBKIT_NAVIGATION_POLICY_DECISION (decision);
//	        // Make a policy decision here
//	        break;
//	    }
//	    case WEBKIT_POLICY_DECISION_TYPE_RESPONSE:
//	        WebKitResponsePolicyDecision *response = WEBKIT_RESPONSE_POLICY_DECISION (decision);
//	        // Make a policy decision here
//	        break;
//	    default:
//	        // Making no decision results in webkit_policy_decision_use()
//	        return FALSE;
//	    }
//	    return TRUE;
//	}
//
// ```
//
// It is possible to make policy decision asynchronously, by simply calling g_object_ref()
// on the @decision argument and returning %TRUE to block the default signal handler.
// If the last reference is removed on a #WebKitPolicyDecision and no decision has been
// made explicitly, webkit_policy_decision_use() will be the default policy decision. The
// default signal handler will simply call webkit_policy_decision_use(). Only the first
// policy decision chosen for a given #WebKitPolicyDecision will have any affect.
func (x *WebView) ConnectDecidePolicy(cb *func(WebView, uintptr, PolicyDecisionType) bool) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "decide-policy", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, DecisionVarp uintptr, DecisionTypeVarp PolicyDecisionType) bool {
		fa := WebView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, DecisionVarp, DecisionTypeVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "decide-policy", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Emitted when JavaScript code calls
// &lt;function&gt;element.webkitRequestFullScreen&lt;/function&gt;. If the
// signal is not handled the #WebKitWebView will proceed to full screen
// its top level window. This signal can be used by client code to
// request permission to the user prior doing the full screen
// transition and eventually prepare the top-level window
// (e.g. hide some widgets that would otherwise be part of the
// full screen window).
func (x *WebView) ConnectEnterFullscreen(cb *func(WebView) bool) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "enter-fullscreen", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) bool {
		fa := WebView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "enter-fullscreen", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Prior to 2.46, this signal was emitted when insecure content was
// loaded in a secure content. Since 2.46, this signal is generally
// no longer emitted.
func (x *WebView) ConnectInsecureContentDetected(cb *func(WebView, InsecureContentEvent)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "insecure-content-detected", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, EventVarp InsecureContentEvent) {
		fa := WebView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, EventVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "insecure-content-detected", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Emitted when the #WebKitWebView is about to restore its top level
// window out of its full screen state. This signal can be used by
// client code to restore widgets hidden during the
// #WebKitWebView::enter-fullscreen stage for instance.
func (x *WebView) ConnectLeaveFullscreen(cb *func(WebView) bool) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "leave-fullscreen", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) bool {
		fa := WebView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "leave-fullscreen", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Emitted when a load operation in @web_view changes.
// The signal is always emitted with %WEBKIT_LOAD_STARTED when a
// new load request is made and %WEBKIT_LOAD_FINISHED when the load
// finishes successfully or due to an error. When the ongoing load
// operation fails #WebKitWebView::load-failed signal is emitted
// before #WebKitWebView::load-changed is emitted with
// %WEBKIT_LOAD_FINISHED.
// If a redirection is received from the server, this signal is emitted
// with %WEBKIT_LOAD_REDIRECTED after the initial emission with
// %WEBKIT_LOAD_STARTED and before %WEBKIT_LOAD_COMMITTED.
// When the page content starts arriving the signal is emitted with
// %WEBKIT_LOAD_COMMITTED event.
//
// You can handle this signal and use a switch to track any ongoing
// load operation.
//
// ```c
// static void web_view_load_changed (WebKitWebView  *web_view,
//
//	WebKitLoadEvent load_event,
//	gpointer        user_data)
//
//	{
//	    switch (load_event) {
//	    case WEBKIT_LOAD_STARTED:
//	        // New load, we have now a provisional URI
//	        provisional_uri = webkit_web_view_get_uri (web_view);
//	        // Here we could start a spinner or update the
//	        // location bar with the provisional URI
//	        break;
//	    case WEBKIT_LOAD_REDIRECTED:
//	        redirected_uri = webkit_web_view_get_uri (web_view);
//	        break;
//	    case WEBKIT_LOAD_COMMITTED:
//	        // The load is being performed. Current URI is
//	        // the final one and it won't change unless a new
//	        // load is requested or a navigation within the
//	        // same page is performed
//	        uri = webkit_web_view_get_uri (web_view);
//	        break;
//	    case WEBKIT_LOAD_FINISHED:
//	        // Load finished, we can now stop the spinner
//	        break;
//	    }
//	}
//
// ```
func (x *WebView) ConnectLoadChanged(cb *func(WebView, LoadEvent)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "load-changed", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, LoadEventVarp LoadEvent) {
		fa := WebView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, LoadEventVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "load-changed", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Emitted when an error occurs during a load operation.
// If the error happened when starting to load data for a page
// @load_event will be %WEBKIT_LOAD_STARTED. If it happened while
// loading a committed data source @load_event will be %WEBKIT_LOAD_COMMITTED.
// Since a load error causes the load operation to finish, the signal
// WebKitWebView::load-changed will always be emitted with
// %WEBKIT_LOAD_FINISHED event right after this one.
//
// By default, if the signal is not handled, a stock error page will be displayed.
// You need to handle the signal if you want to provide your own error page.
func (x *WebView) ConnectLoadFailed(cb *func(WebView, LoadEvent, string, uintptr) bool) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "load-failed", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, LoadEventVarp LoadEvent, FailingUriVarp string, ErrorVarp uintptr) bool {
		fa := WebView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, LoadEventVarp, FailingUriVarp, ErrorVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "load-failed", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Emitted when a TLS error occurs during a load operation.
// To allow an exception for this @certificate
// and the host of @failing_uri use webkit_web_context_allow_tls_certificate_for_host().
//
// To handle this signal asynchronously you should call g_object_ref() on @certificate
// and return %TRUE.
//
// If %FALSE is returned, #WebKitWebView::load-failed will be emitted. The load
// will finish regardless of the returned value.
func (x *WebView) ConnectLoadFailedWithTlsErrors(cb *func(WebView, string, uintptr, gio.TlsCertificateFlags) bool) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "load-failed-with-tls-errors", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, FailingUriVarp string, CertificateVarp uintptr, ErrorsVarp gio.TlsCertificateFlags) bool {
		fa := WebView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, FailingUriVarp, CertificateVarp, ErrorsVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "load-failed-with-tls-errors", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// This signal is emitted when the mouse cursor moves over an
// element such as a link, image or a media element. To determine
// what type of element the mouse cursor is over, a Hit Test is performed
// on the current mouse coordinates and the result is passed in the
// @hit_test_result argument. The @modifiers argument is a bitmask of
// #GdkModifierType flags indicating the state of modifier keys.
// The signal is emitted again when the mouse is moved out of the
// current element with a new @hit_test_result.
func (x *WebView) ConnectMouseTargetChanged(cb *func(WebView, uintptr, uint)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "mouse-target-changed", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, HitTestResultVarp uintptr, ModifiersVarp uint) {
		fa := WebView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, HitTestResultVarp, ModifiersVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "mouse-target-changed", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// This signal is emitted when WebKit is requesting the client to
// decide about a permission request, such as allowing the browser
// to switch to fullscreen mode, sharing its location or similar
// operations.
//
// A possible way to use this signal could be through a dialog
// allowing the user decide what to do with the request:
//
// ```c
// static gboolean permission_request_cb (WebKitWebView *web_view,
//
//	WebKitPermissionRequest *request,
//	GtkWindow *parent_window)
//
//	{
//	    GtkWidget *dialog = gtk_message_dialog_new (parent_window,
//	                                                GTK_DIALOG_MODAL,
//	                                                GTK_MESSAGE_QUESTION,
//	                                                GTK_BUTTONS_YES_NO,
//	                                                "Allow Permission Request?");
//	    gtk_widget_show (dialog);
//	    gint result = gtk_dialog_run (GTK_DIALOG (dialog));
//
//	    switch (result) {
//	    case GTK_RESPONSE_YES:
//	        webkit_permission_request_allow (request);
//	        break;
//	    default:
//	        webkit_permission_request_deny (request);
//	        break;
//	    }
//	    gtk_widget_destroy (dialog);
//
//	    return TRUE;
//	}
//
// ```
//
// It is possible to handle permission requests asynchronously, by
// simply calling g_object_ref() on the @request argument and
// returning %TRUE to block the default signal handler.  If the
// last reference is removed on a #WebKitPermissionRequest and the
// request has not been handled, webkit_permission_request_deny()
// will be the default action.
//
// If the signal is not handled, the @request will be completed automatically
// by the specific #WebKitPermissionRequest that could allow or deny it. Check the
// documentation of classes implementing #WebKitPermissionRequest interface to know
// their default action.
func (x *WebView) ConnectPermissionRequest(cb *func(WebView, uintptr) bool) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "permission-request", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, RequestVarp uintptr) bool {
		fa := WebView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, RequestVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "permission-request", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Emitted when printing is requested on @web_view, usually by a JavaScript call,
// before the print dialog is shown. This signal can be used to set the initial
// print settings and page setup of @print_operation to be used as default values in
// the print dialog. You can call webkit_print_operation_set_print_settings() and
// webkit_print_operation_set_page_setup() and then return %FALSE to propagate the
// event so that the print dialog is shown.
//
// You can connect to this signal and return %TRUE to cancel the print operation
// or implement your own print dialog.
func (x *WebView) ConnectPrint(cb *func(WebView, uintptr) bool) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "print", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, PrintOperationVarp uintptr) bool {
		fa := WebView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, PrintOperationVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "print", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// This signal allows the User-Agent to respond to permission requests for powerful features, as
// specified by the [Permissions W3C Specification](https://w3c.github.io/permissions/).
// You can reply to the query using webkit_permission_state_query_finish().
//
// You can handle the query asynchronously by calling webkit_permission_state_query_ref() on
// @query and returning %TRUE. If the last reference of @query is removed and the query has not
// been handled, the query result will be set to %WEBKIT_QUERY_PERMISSION_PROMPT.
func (x *WebView) ConnectQueryPermissionState(cb *func(WebView, uintptr) bool) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "query-permission-state", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, QueryVarp uintptr) bool {
		fa := WebView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, QueryVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "query-permission-state", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Emitted after #WebKitWebView::create on the newly created #WebKitWebView
// when it should be displayed to the user. When this signal is emitted
// all the information about how the window should look, including
// size, position, whether the location, status and scrollbars
// should be displayed, is already set on the #WebKitWindowProperties
// of @web_view. See also webkit_web_view_get_window_properties().
func (x *WebView) ConnectReadyToShow(cb *func(WebView)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "ready-to-show", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) {
		fa := WebView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "ready-to-show", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Emitted when a new resource is going to be loaded. The @request parameter
// contains the #WebKitURIRequest that will be sent to the server.
// You can monitor the load operation by connecting to the different signals
// of @resource.
func (x *WebView) ConnectResourceLoadStarted(cb *func(WebView, uintptr, uintptr)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "resource-load-started", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, ResourceVarp uintptr, RequestVarp uintptr) {
		fa := WebView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ResourceVarp, RequestVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "resource-load-started", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Emitted after #WebKitWebView::ready-to-show on the newly
// created #WebKitWebView when JavaScript code calls
// &lt;function&gt;window.showModalDialog&lt;/function&gt;. The purpose of
// this signal is to allow the client application to prepare the
// new view to behave as modal. Once the signal is emitted a new
// main loop will be run to block user interaction in the parent
// #WebKitWebView until the new dialog is closed.
func (x *WebView) ConnectRunAsModal(cb *func(WebView)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "run-as-modal", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) {
		fa := WebView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "run-as-modal", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// This signal is emitted when the user interacts with a &lt;input
// type='color' /&gt; HTML element, requesting from WebKit to show
// a dialog to select a color. To let the application know the details of
// the color chooser, as well as to allow the client application to either
// cancel the request or perform an actual color selection, the signal will
// pass an instance of the #WebKitColorChooserRequest in the @request
// argument.
//
// It is possible to handle this request asynchronously by increasing the
// reference count of the request.
//
// The default signal handler will asynchronously run a regular
// #GtkColorChooser for the user to interact with.
func (x *WebView) ConnectRunColorChooser(cb *func(WebView, uintptr) bool) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "run-color-chooser", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, RequestVarp uintptr) bool {
		fa := WebView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, RequestVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "run-color-chooser", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// This signal is emitted when the user interacts with a &lt;input
// type='file' /&gt; HTML element, requesting from WebKit to show
// a dialog to select one or more files to be uploaded. To let the
// application know the details of the file chooser, as well as to
// allow the client application to either cancel the request or
// perform an actual selection of files, the signal will pass an
// instance of the #WebKitFileChooserRequest in the @request
// argument.
//
// The default signal handler will asynchronously run a regular
// #GtkFileChooserDialog for the user to interact with.
func (x *WebView) ConnectRunFileChooser(cb *func(WebView, uintptr) bool) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "run-file-chooser", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, RequestVarp uintptr) bool {
		fa := WebView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, RequestVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "run-file-chooser", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Emitted when JavaScript code calls &lt;function&gt;window.alert&lt;/function&gt;,
// &lt;function&gt;window.confirm&lt;/function&gt; or &lt;function&gt;window.prompt&lt;/function&gt;,
// or when &lt;function&gt;onbeforeunload&lt;/function&gt; event is fired.
// The @dialog parameter should be used to build the dialog.
// If the signal is not handled a different dialog will be built and shown depending
// on the dialog type:
// &lt;itemizedlist&gt;
// &lt;listitem&gt;&lt;para&gt;
//
//	%WEBKIT_SCRIPT_DIALOG_ALERT: message dialog with a single Close button.
//
// &lt;/para&gt;&lt;/listitem&gt;
// &lt;listitem&gt;&lt;para&gt;
//
//	%WEBKIT_SCRIPT_DIALOG_CONFIRM: message dialog with OK and Cancel buttons.
//
// &lt;/para&gt;&lt;/listitem&gt;
// &lt;listitem&gt;&lt;para&gt;
//
//	%WEBKIT_SCRIPT_DIALOG_PROMPT: message dialog with OK and Cancel buttons and
//	a text entry with the default text.
//
// &lt;/para&gt;&lt;/listitem&gt;
// &lt;listitem&gt;&lt;para&gt;
//
//	%WEBKIT_SCRIPT_DIALOG_BEFORE_UNLOAD_CONFIRM: message dialog with Stay and Leave buttons.
//
// &lt;/para&gt;&lt;/listitem&gt;
// &lt;/itemizedlist&gt;
//
// It is possible to handle the script dialog request asynchronously, by simply
// caling webkit_script_dialog_ref() on the @dialog argument and calling
// webkit_script_dialog_close() when done.
// If the last reference is removed on a #WebKitScriptDialog and the dialog has not been
// closed, webkit_script_dialog_close() will be called.
func (x *WebView) ConnectScriptDialog(cb *func(WebView, uintptr) bool) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "script-dialog", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, DialogVarp uintptr) bool {
		fa := WebView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, DialogVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "script-dialog", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// This signal is emitted when a notification should be presented to the
// user. The @notification is kept alive until either: 1) the web page cancels it
// or 2) a navigation happens.
//
// The default handler will emit a notification using libnotify, if built with
// support for it.
func (x *WebView) ConnectShowNotification(cb *func(WebView, uintptr) bool) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "show-notification", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, NotificationVarp uintptr) bool {
		fa := WebView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, NotificationVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "show-notification", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// This signal is emitted when a select element in @web_view needs to display a
// dropdown menu. This signal can be used to show a custom menu, using @menu to get
// the details of all items that should be displayed. The area of the element in the
// #WebKitWebView is given as @rectangle parameter, it can be used to position the
// menu.
// To handle this signal asynchronously you should keep a ref of the @menu.
//
// The default signal handler will pop up a #GtkMenu.
func (x *WebView) ConnectShowOptionMenu(cb *func(WebView, uintptr, uintptr) bool) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "show-option-menu", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, MenuVarp uintptr, RectangleVarp uintptr) bool {
		fa := WebView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, MenuVarp, RectangleVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "show-option-menu", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// This signal is emitted when a form is about to be submitted. The @request
// argument passed contains information about the text fields of the form. This
// is typically used to store login information that can be used later to
// pre-fill the form.
// The form will not be submitted until webkit_form_submission_request_submit() is called.
//
// It is possible to handle the form submission request asynchronously, by
// simply calling g_object_ref() on the @request argument and calling
// webkit_form_submission_request_submit() when done to continue with the form submission.
// If the last reference is removed on a #WebKitFormSubmissionRequest and the
// form has not been submitted, webkit_form_submission_request_submit() will be called.
func (x *WebView) ConnectSubmitForm(cb *func(WebView, uintptr)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "submit-form", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, RequestVarp uintptr) {
		fa := WebView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, RequestVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "submit-form", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// This signal is emitted when a #WebKitUserMessage is received from the
// #WebKitWebPage corresponding to @web_view. You can reply to the message
// using webkit_user_message_send_reply().
//
// You can handle the user message asynchronously by calling g_object_ref() on
// @message and returning %TRUE. If the last reference of @message is removed
// and the message has not been replied to, the operation in the #WebKitWebPage will
// finish with error %WEBKIT_USER_MESSAGE_UNHANDLED_MESSAGE.
func (x *WebView) ConnectUserMessageReceived(cb *func(WebView, uintptr) bool) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "user-message-received", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, MessageVarp uintptr) bool {
		fa := WebView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, MessageVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "user-message-received", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// This signal is emitted when the web process terminates abnormally due
// to @reason.
func (x *WebView) ConnectWebProcessTerminated(cb *func(WebView, WebProcessTerminationReason)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "web-process-terminated", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, ReasonVarp WebProcessTerminationReason) {
		fa := WebView{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ReasonVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "web-process-terminated", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// Requests the user's screen reader to announce the given message.
//
// This kind of notification is useful for messages that
// either have only a visual representation or that are not
// exposed visually at all, e.g. a notification about a
// successful operation.
//
// Also, by using this API, you can ensure that the message
// does not interrupts the user's current screen reader output.
func (x *WebView) Announce(MessageVar string, PriorityVar gtk.AccessibleAnnouncementPriority) {

	gtk.XGtkAccessibleAnnounce(x.GoPointer(), MessageVar, PriorityVar)

}

// Retrieves the accessible parent for an accessible object.
//
// This function returns `NULL` for top level widgets.
func (x *WebView) GetAccessibleParent() *gtk.AccessibleBase {
	var cls *gtk.AccessibleBase

	cret := gtk.XGtkAccessibleGetAccessibleParent(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the accessible role of an accessible object.
func (x *WebView) GetAccessibleRole() gtk.AccessibleRole {

	cret := gtk.XGtkAccessibleGetAccessibleRole(x.GoPointer())
	return cret
}

// Retrieves the implementation for the given accessible object.
func (x *WebView) GetAtContext() *gtk.ATContext {
	var cls *gtk.ATContext

	cret := gtk.XGtkAccessibleGetAtContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.ATContext{}
	cls.Ptr = cret
	return cls
}

// Queries the coordinates and dimensions of this accessible
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get the bounds from an ignored
// child widget.
func (x *WebView) GetBounds(XVar *int, YVar *int, WidthVar *int, HeightVar *int) bool {

	cret := gtk.XGtkAccessibleGetBounds(x.GoPointer(), XVar, YVar, WidthVar, HeightVar)
	return cret
}

// Retrieves the first accessible child of an accessible object.
func (x *WebView) GetFirstAccessibleChild() *gtk.AccessibleBase {
	var cls *gtk.AccessibleBase

	cret := gtk.XGtkAccessibleGetFirstAccessibleChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the next accessible sibling of an accessible object
func (x *WebView) GetNextAccessibleSibling() *gtk.AccessibleBase {
	var cls *gtk.AccessibleBase

	cret := gtk.XGtkAccessibleGetNextAccessibleSibling(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Queries a platform state, such as focus.
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get platform state from an ignored
// child widget, as is the case for `GtkText` wrappers.
func (x *WebView) GetPlatformState(StateVar gtk.AccessiblePlatformState) bool {

	cret := gtk.XGtkAccessibleGetPlatformState(x.GoPointer(), StateVar)
	return cret
}

// Resets the accessible property to its default value.
func (x *WebView) ResetProperty(PropertyVar gtk.AccessibleProperty) {

	gtk.XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible relation to its default value.
func (x *WebView) ResetRelation(RelationVar gtk.AccessibleRelation) {

	gtk.XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible state to its default value.
func (x *WebView) ResetState(StateVar gtk.AccessibleState) {

	gtk.XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Sets the parent and sibling of an accessible object.
//
// This function is meant to be used by accessible implementations that are
// not part of the widget hierarchy, and but act as a logical bridge between
// widgets. For instance, if a widget creates an object that holds metadata
// for each child, and you want that object to implement the `GtkAccessible`
// interface, you will use this function to ensure that the parent of each
// child widget is the metadata object, and the parent of each metadata
// object is the container widget.
func (x *WebView) SetAccessibleParent(ParentVar gtk.Accessible, NextSiblingVar gtk.Accessible) {

	gtk.XGtkAccessibleSetAccessibleParent(x.GoPointer(), ParentVar.GoPointer(), NextSiblingVar.GoPointer())

}

// Updates the next accessible sibling.
//
// That might be useful when a new child of a custom accessible
// is created, and it needs to be linked to a previous child.
func (x *WebView) UpdateNextAccessibleSibling(NewSiblingVar gtk.Accessible) {

	gtk.XGtkAccessibleUpdateNextAccessibleSibling(x.GoPointer(), NewSiblingVar.GoPointer())

}

// Informs ATs that the platform state has changed.
//
// This function should be used by `GtkAccessible` implementations that
// have a platform state but are not widgets. Widgets handle platform
// states automatically.
func (x *WebView) UpdatePlatformState(StateVar gtk.AccessiblePlatformState) {

	gtk.XGtkAccessibleUpdatePlatformState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *WebView) UpdateProperty(FirstPropertyVar gtk.AccessibleProperty, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *WebView) UpdatePropertyValue(NPropertiesVar int, PropertiesVar []gtk.AccessibleProperty, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by `NULL`, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *WebView) UpdateRelation(FirstRelationVar gtk.AccessibleRelation, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *WebView) UpdateRelationValue(NRelationsVar int, RelationsVar []gtk.AccessibleRelation, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states.
//
// See the [enum@Gtk.AccessibleState] documentation for the
// value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever
// an accessible state change must be communicated to assistive
// technologies.
//
// Example:
//
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *WebView) UpdateState(FirstStateVar gtk.AccessibleState, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *WebView) UpdateStateValue(NStatesVar int, StatesVar []gtk.AccessibleState, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the `&lt;object&gt;` tag used to construct the @buildable.
func (x *WebView) GetBuildableId() string {

	cret := gtk.XGtkBuildableGetBuildableId(x.GoPointer())
	return cret
}

func init() {
	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("WEBKIT") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xSnapshotOptionsGLibType, libs, "webkit_snapshot_options_get_type")

	core.PuregoSafeRegister(&xInsecureContentEventGLibType, libs, "webkit_insecure_content_event_get_type")

	core.PuregoSafeRegister(&xLoadEventGLibType, libs, "webkit_load_event_get_type")

	core.PuregoSafeRegister(&xMediaCaptureStateGLibType, libs, "webkit_media_capture_state_get_type")

	core.PuregoSafeRegister(&xPolicyDecisionTypeGLibType, libs, "webkit_policy_decision_type_get_type")

	core.PuregoSafeRegister(&xSaveModeGLibType, libs, "webkit_save_mode_get_type")

	core.PuregoSafeRegister(&xSnapshotRegionGLibType, libs, "webkit_snapshot_region_get_type")

	core.PuregoSafeRegister(&xWebExtensionModeGLibType, libs, "webkit_web_extension_mode_get_type")

	core.PuregoSafeRegister(&xWebProcessTerminationReasonGLibType, libs, "webkit_web_process_termination_reason_get_type")

	core.PuregoSafeRegister(&xWebViewGLibType, libs, "webkit_web_view_get_type")

	core.PuregoSafeRegister(&xNewWebView, libs, "webkit_web_view_new")

	core.PuregoSafeRegister(&xWebViewCallAsyncJavascriptFunction, libs, "webkit_web_view_call_async_javascript_function")
	core.PuregoSafeRegister(&xWebViewCallAsyncJavascriptFunctionFinish, libs, "webkit_web_view_call_async_javascript_function_finish")
	core.PuregoSafeRegister(&xWebViewCanExecuteEditingCommand, libs, "webkit_web_view_can_execute_editing_command")
	core.PuregoSafeRegister(&xWebViewCanExecuteEditingCommandFinish, libs, "webkit_web_view_can_execute_editing_command_finish")
	core.PuregoSafeRegister(&xWebViewCanGoBack, libs, "webkit_web_view_can_go_back")
	core.PuregoSafeRegister(&xWebViewCanGoForward, libs, "webkit_web_view_can_go_forward")
	core.PuregoSafeRegister(&xWebViewCanShowMimeType, libs, "webkit_web_view_can_show_mime_type")
	core.PuregoSafeRegister(&xWebViewDownloadUri, libs, "webkit_web_view_download_uri")
	core.PuregoSafeRegister(&xWebViewEvaluateJavascript, libs, "webkit_web_view_evaluate_javascript")
	core.PuregoSafeRegister(&xWebViewEvaluateJavascriptFinish, libs, "webkit_web_view_evaluate_javascript_finish")
	core.PuregoSafeRegister(&xWebViewExecuteEditingCommand, libs, "webkit_web_view_execute_editing_command")
	core.PuregoSafeRegister(&xWebViewExecuteEditingCommandWithArgument, libs, "webkit_web_view_execute_editing_command_with_argument")
	core.PuregoSafeRegister(&xWebViewGetAutomationPresentationType, libs, "webkit_web_view_get_automation_presentation_type")
	core.PuregoSafeRegister(&xWebViewGetBackForwardList, libs, "webkit_web_view_get_back_forward_list")
	core.PuregoSafeRegister(&xWebViewGetBackgroundColor, libs, "webkit_web_view_get_background_color")
	core.PuregoSafeRegister(&xWebViewGetCameraCaptureState, libs, "webkit_web_view_get_camera_capture_state")
	core.PuregoSafeRegister(&xWebViewGetContext, libs, "webkit_web_view_get_context")
	core.PuregoSafeRegister(&xWebViewGetCustomCharset, libs, "webkit_web_view_get_custom_charset")
	core.PuregoSafeRegister(&xWebViewGetDefaultContentSecurityPolicy, libs, "webkit_web_view_get_default_content_security_policy")
	core.PuregoSafeRegister(&xWebViewGetDisplayCaptureState, libs, "webkit_web_view_get_display_capture_state")
	core.PuregoSafeRegister(&xWebViewGetEditorState, libs, "webkit_web_view_get_editor_state")
	core.PuregoSafeRegister(&xWebViewGetEstimatedLoadProgress, libs, "webkit_web_view_get_estimated_load_progress")
	core.PuregoSafeRegister(&xWebViewGetFavicon, libs, "webkit_web_view_get_favicon")
	core.PuregoSafeRegister(&xWebViewGetFindController, libs, "webkit_web_view_get_find_controller")
	core.PuregoSafeRegister(&xWebViewGetInputMethodContext, libs, "webkit_web_view_get_input_method_context")
	core.PuregoSafeRegister(&xWebViewGetInspector, libs, "webkit_web_view_get_inspector")
	core.PuregoSafeRegister(&xWebViewGetIsMuted, libs, "webkit_web_view_get_is_muted")
	core.PuregoSafeRegister(&xWebViewGetIsWebProcessResponsive, libs, "webkit_web_view_get_is_web_process_responsive")
	core.PuregoSafeRegister(&xWebViewGetMainResource, libs, "webkit_web_view_get_main_resource")
	core.PuregoSafeRegister(&xWebViewGetMicrophoneCaptureState, libs, "webkit_web_view_get_microphone_capture_state")
	core.PuregoSafeRegister(&xWebViewGetNetworkSession, libs, "webkit_web_view_get_network_session")
	core.PuregoSafeRegister(&xWebViewGetPageId, libs, "webkit_web_view_get_page_id")
	core.PuregoSafeRegister(&xWebViewGetSessionState, libs, "webkit_web_view_get_session_state")
	core.PuregoSafeRegister(&xWebViewGetSettings, libs, "webkit_web_view_get_settings")
	core.PuregoSafeRegister(&xWebViewGetSnapshot, libs, "webkit_web_view_get_snapshot")
	core.PuregoSafeRegister(&xWebViewGetSnapshotFinish, libs, "webkit_web_view_get_snapshot_finish")
	core.PuregoSafeRegister(&xWebViewGetThemeColor, libs, "webkit_web_view_get_theme_color")
	core.PuregoSafeRegister(&xWebViewGetTitle, libs, "webkit_web_view_get_title")
	core.PuregoSafeRegister(&xWebViewGetTlsInfo, libs, "webkit_web_view_get_tls_info")
	core.PuregoSafeRegister(&xWebViewGetUri, libs, "webkit_web_view_get_uri")
	core.PuregoSafeRegister(&xWebViewGetUserContentManager, libs, "webkit_web_view_get_user_content_manager")
	core.PuregoSafeRegister(&xWebViewGetWebExtensionMode, libs, "webkit_web_view_get_web_extension_mode")
	core.PuregoSafeRegister(&xWebViewGetWebsitePolicies, libs, "webkit_web_view_get_website_policies")
	core.PuregoSafeRegister(&xWebViewGetWindowProperties, libs, "webkit_web_view_get_window_properties")
	core.PuregoSafeRegister(&xWebViewGetZoomLevel, libs, "webkit_web_view_get_zoom_level")
	core.PuregoSafeRegister(&xWebViewGoBack, libs, "webkit_web_view_go_back")
	core.PuregoSafeRegister(&xWebViewGoForward, libs, "webkit_web_view_go_forward")
	core.PuregoSafeRegister(&xWebViewGoToBackForwardListItem, libs, "webkit_web_view_go_to_back_forward_list_item")
	core.PuregoSafeRegister(&xWebViewIsControlledByAutomation, libs, "webkit_web_view_is_controlled_by_automation")
	core.PuregoSafeRegister(&xWebViewIsEditable, libs, "webkit_web_view_is_editable")
	core.PuregoSafeRegister(&xWebViewIsLoading, libs, "webkit_web_view_is_loading")
	core.PuregoSafeRegister(&xWebViewIsPlayingAudio, libs, "webkit_web_view_is_playing_audio")
	core.PuregoSafeRegister(&xWebViewLoadAlternateHtml, libs, "webkit_web_view_load_alternate_html")
	core.PuregoSafeRegister(&xWebViewLoadBytes, libs, "webkit_web_view_load_bytes")
	core.PuregoSafeRegister(&xWebViewLoadHtml, libs, "webkit_web_view_load_html")
	core.PuregoSafeRegister(&xWebViewLoadPlainText, libs, "webkit_web_view_load_plain_text")
	core.PuregoSafeRegister(&xWebViewLoadRequest, libs, "webkit_web_view_load_request")
	core.PuregoSafeRegister(&xWebViewLoadUri, libs, "webkit_web_view_load_uri")
	core.PuregoSafeRegister(&xWebViewReload, libs, "webkit_web_view_reload")
	core.PuregoSafeRegister(&xWebViewReloadBypassCache, libs, "webkit_web_view_reload_bypass_cache")
	core.PuregoSafeRegister(&xWebViewRestoreSessionState, libs, "webkit_web_view_restore_session_state")
	core.PuregoSafeRegister(&xWebViewSave, libs, "webkit_web_view_save")
	core.PuregoSafeRegister(&xWebViewSaveFinish, libs, "webkit_web_view_save_finish")
	core.PuregoSafeRegister(&xWebViewSaveToFile, libs, "webkit_web_view_save_to_file")
	core.PuregoSafeRegister(&xWebViewSaveToFileFinish, libs, "webkit_web_view_save_to_file_finish")
	core.PuregoSafeRegister(&xWebViewSendMessageToPage, libs, "webkit_web_view_send_message_to_page")
	core.PuregoSafeRegister(&xWebViewSendMessageToPageFinish, libs, "webkit_web_view_send_message_to_page_finish")
	core.PuregoSafeRegister(&xWebViewSetBackgroundColor, libs, "webkit_web_view_set_background_color")
	core.PuregoSafeRegister(&xWebViewSetCameraCaptureState, libs, "webkit_web_view_set_camera_capture_state")
	core.PuregoSafeRegister(&xWebViewSetCorsAllowlist, libs, "webkit_web_view_set_cors_allowlist")
	core.PuregoSafeRegister(&xWebViewSetCustomCharset, libs, "webkit_web_view_set_custom_charset")
	core.PuregoSafeRegister(&xWebViewSetDisplayCaptureState, libs, "webkit_web_view_set_display_capture_state")
	core.PuregoSafeRegister(&xWebViewSetEditable, libs, "webkit_web_view_set_editable")
	core.PuregoSafeRegister(&xWebViewSetInputMethodContext, libs, "webkit_web_view_set_input_method_context")
	core.PuregoSafeRegister(&xWebViewSetIsMuted, libs, "webkit_web_view_set_is_muted")
	core.PuregoSafeRegister(&xWebViewSetMicrophoneCaptureState, libs, "webkit_web_view_set_microphone_capture_state")
	core.PuregoSafeRegister(&xWebViewSetSettings, libs, "webkit_web_view_set_settings")
	core.PuregoSafeRegister(&xWebViewSetZoomLevel, libs, "webkit_web_view_set_zoom_level")
	core.PuregoSafeRegister(&xWebViewStopLoading, libs, "webkit_web_view_stop_loading")
	core.PuregoSafeRegister(&xWebViewTerminateWebProcess, libs, "webkit_web_view_terminate_web_process")
	core.PuregoSafeRegister(&xWebViewTryClose, libs, "webkit_web_view_try_close")

}
