// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package webkit

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// Type definition for a function that will be called back when an URI request is
// made for a user registered URI scheme.
type URISchemeRequestCallback func(uintptr, uintptr)

type WebContextClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass
}

func (x *WebContextClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Enum values used for determining the #WebKitWebContext cache model.
type CacheModel int

var xCacheModelGLibType func() types.GType

func CacheModelGLibType() types.GType {
	return xCacheModelGLibType()
}

const (

	// Disable the cache completely, which
	//   substantially reduces memory usage. Useful for applications that only
	//   access a single local file, with no navigation to other pages. No remote
	//   resources will be cached.
	CacheModelDocumentViewerValue CacheModel = 0
	// Improve document load speed substantially
	//   by caching a very large number of resources and previously viewed content.
	CacheModelWebBrowserValue CacheModel = 1
	// A cache model optimized for viewing
	//   a series of local files -- for example, a documentation viewer or a website
	//   designer. WebKit will cache a moderate number of resources.
	CacheModelDocumentBrowserValue CacheModel = 2
)

// Manages aspects common to all #WebKitWebView&lt;!-- --&gt;s
//
// The #WebKitWebContext manages all aspects common to all
// #WebKitWebView&lt;!-- --&gt;s.
//
// You can define the #WebKitCacheModel with
// webkit_web_context_set_cache_model(), depending on the needs of
// your application. You can access the #WebKitSecurityManager to specify
// the behaviour of your application regarding security using
// webkit_web_context_get_security_manager().
//
// It is also possible to change your preferred language or enable
// spell checking, using webkit_web_context_set_preferred_languages(),
// webkit_web_context_set_spell_checking_languages() and
// webkit_web_context_set_spell_checking_enabled().
//
// You can use webkit_web_context_register_uri_scheme() to register
// custom URI schemes, and manage several other settings.
//
// TLS certificate validation failure is now treated as a transport
// error by default. To handle TLS failures differently, you can
// connect to #WebKitWebView::load-failed-with-tls-errors.
// Alternatively, you can use webkit_web_context_set_tls_errors_policy()
// to set the policy %WEBKIT_TLS_ERRORS_POLICY_IGNORE; however, this is
// not appropriate for Internet applications.
type WebContext struct {
	gobject.Object
}

var xWebContextGLibType func() types.GType

func WebContextGLibType() types.GType {
	return xWebContextGLibType()
}

func WebContextNewFromInternalPtr(ptr uintptr) *WebContext {
	cls := &WebContext{}
	cls.Ptr = ptr
	return cls
}

var xNewWebContext func() uintptr

// Create a new #WebKitWebContext.
func NewWebContext() *WebContext {
	var cls *WebContext

	cret := xNewWebContext()

	if cret == 0 {
		return nil
	}
	cls = &WebContext{}
	cls.Ptr = cret
	return cls
}

var xWebContextAddPathToSandbox func(uintptr, string, bool)

// Adds a path to be mounted in the sandbox.
//
// @path must exist before any web process has been created. It is a fatal error
// to add paths after a web process has been spawned.
//
// Paths under `/sys`, `/proc`, and `/dev` are invalid. Attempting to
// add all of `/` is not valid. Since 2.40, adding the user's entire
// home directory or /home is also not valid.
//
// See also webkit_web_context_set_sandbox_enabled()
func (x *WebContext) AddPathToSandbox(PathVar string, ReadOnlyVar bool) {

	xWebContextAddPathToSandbox(x.GoPointer(), PathVar, ReadOnlyVar)

}

var xWebContextGetCacheModel func(uintptr) CacheModel

// Returns the current cache model.
//
// For more information about this
// value check the documentation of the function
// webkit_web_context_set_cache_model().
func (x *WebContext) GetCacheModel() CacheModel {

	cret := xWebContextGetCacheModel(x.GoPointer())
	return cret
}

var xWebContextGetGeolocationManager func(uintptr) uintptr

// Get the #WebKitGeolocationManager of @context.
func (x *WebContext) GetGeolocationManager() *GeolocationManager {
	var cls *GeolocationManager

	cret := xWebContextGetGeolocationManager(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &GeolocationManager{}
	cls.Ptr = cret
	return cls
}

var xWebContextGetNetworkSessionForAutomation func(uintptr) uintptr

// Get the #WebKitNetworkSession used for automation sessions started in @context.
func (x *WebContext) GetNetworkSessionForAutomation() *NetworkSession {
	var cls *NetworkSession

	cret := xWebContextGetNetworkSessionForAutomation(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &NetworkSession{}
	cls.Ptr = cret
	return cls
}

var xWebContextGetSecurityManager func(uintptr) uintptr

// Get the #WebKitSecurityManager of @context.
func (x *WebContext) GetSecurityManager() *SecurityManager {
	var cls *SecurityManager

	cret := xWebContextGetSecurityManager(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &SecurityManager{}
	cls.Ptr = cret
	return cls
}

var xWebContextGetSpellCheckingEnabled func(uintptr) bool

// Get whether spell checking feature is currently enabled.
func (x *WebContext) GetSpellCheckingEnabled() bool {

	cret := xWebContextGetSpellCheckingEnabled(x.GoPointer())
	return cret
}

var xWebContextGetSpellCheckingLanguages func(uintptr) []string

// Get the the list of spell checking languages.
//
// Get the the list of spell checking languages associated with
// @context, or %NULL if no languages have been previously set.
//
// See webkit_web_context_set_spell_checking_languages() for more
// details on the format of the languages in the list.
func (x *WebContext) GetSpellCheckingLanguages() []string {

	cret := xWebContextGetSpellCheckingLanguages(x.GoPointer())
	return cret
}

var xWebContextGetTimeZoneOverride func(uintptr) string

// Get the #WebKitWebContext:time-zone-override property.
func (x *WebContext) GetTimeZoneOverride() string {

	cret := xWebContextGetTimeZoneOverride(x.GoPointer())
	return cret
}

var xWebContextInitializeNotificationPermissions func(uintptr, *glib.List, *glib.List)

// Sets initial desktop notification permissions for the @context.
//
// @allowed_origins and @disallowed_origins must each be #GList of
// #WebKitSecurityOrigin objects representing origins that will,
// respectively, either always or never have permission to show desktop
// notifications. No #WebKitNotificationPermissionRequest will ever be
// generated for any of the security origins represented in
// @allowed_origins or @disallowed_origins. This function is necessary
// because some webpages proactively check whether they have permission
// to display notifications without ever creating a permission request.
//
// This function only affects web processes that have not already been
// created. The best time to call it is when handling
// #WebKitWebContext::initialize-notification-permissions so as to
// ensure that new web processes receive the most recent set of
// permissions.
func (x *WebContext) InitializeNotificationPermissions(AllowedOriginsVar *glib.List, DisallowedOriginsVar *glib.List) {

	xWebContextInitializeNotificationPermissions(x.GoPointer(), AllowedOriginsVar, DisallowedOriginsVar)

}

var xWebContextIsAutomationAllowed func(uintptr) bool

// Get whether automation is allowed in @context.
//
// See also webkit_web_context_set_automation_allowed().
func (x *WebContext) IsAutomationAllowed() bool {

	cret := xWebContextIsAutomationAllowed(x.GoPointer())
	return cret
}

var xWebContextRegisterUriScheme func(uintptr, string, uintptr, uintptr, uintptr)

// Register @scheme in @context.
//
// Register @scheme in @context, so that when an URI request with @scheme is made in the
// #WebKitWebContext, the #WebKitURISchemeRequestCallback registered will be called with a
// #WebKitURISchemeRequest.
// It is possible to handle URI scheme requests asynchronously, by calling g_object_ref() on the
// #WebKitURISchemeRequest and calling webkit_uri_scheme_request_finish() later
// when the data of the request is available or
// webkit_uri_scheme_request_finish_error() in case of error.
//
// ```c
// static void
// about_uri_scheme_request_cb (WebKitURISchemeRequest *request,
//
//	gpointer                user_data)
//
//	{
//	    GInputStream *stream;
//	    gsize         stream_length;
//	    const gchar  *path = webkit_uri_scheme_request_get_path (request);
//
//	    if (!g_strcmp0 (path, "memory")) {
//	        // Create a GInputStream with the contents of memory about page, and set its length to stream_length
//	    } else if (!g_strcmp0 (path, "applications")) {
//	        // Create a GInputStream with the contents of applications about page, and set its length to stream_length
//	    } else if (!g_strcmp0 (path, "example")) {
//	        gchar *contents = g_strdup_printf ("&lt;html&gt;&lt;body&gt;&lt;p&gt;Example about page&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;");
//	        stream_length = strlen (contents);
//	        stream = g_memory_input_stream_new_from_data (contents, stream_length, g_free);
//	    } else {
//	        GError *error = g_error_new (ABOUT_HANDLER_ERROR, ABOUT_HANDLER_ERROR_INVALID, "Invalid about:%s page.", path);
//	        webkit_uri_scheme_request_finish_error (request, error);
//	        g_error_free (error);
//	        return;
//	    }
//	    webkit_uri_scheme_request_finish (request, stream, stream_length, "text/html");
//	    g_object_unref (stream);
//	}
//
// ```
func (x *WebContext) RegisterUriScheme(SchemeVar string, CallbackVar *URISchemeRequestCallback, UserDataVar uintptr, UserDataDestroyFuncVar *glib.DestroyNotify) {

	xWebContextRegisterUriScheme(x.GoPointer(), SchemeVar, glib.NewCallback(CallbackVar), UserDataVar, glib.NewCallback(UserDataDestroyFuncVar))

}

var xWebContextSendMessageToAllExtensions func(uintptr, uintptr)

// Send @message to all web process extensions associated to @context.
//
// If @message is floating, it's consumed.
func (x *WebContext) SendMessageToAllExtensions(MessageVar *UserMessage) {

	xWebContextSendMessageToAllExtensions(x.GoPointer(), MessageVar.GoPointer())

}

var xWebContextSetAutomationAllowed func(uintptr, bool)

// Set whether automation is allowed in @context.
//
// When automation is enabled the browser could
// be controlled by another process by requesting an automation session. When a new automation
// session is requested the signal #WebKitWebContext::automation-started is emitted.
// Automation is disabled by default, so you need to explicitly call this method passing %TRUE
// to enable it.
//
// Note that only one #WebKitWebContext can have automation enabled, so this will do nothing
// if there's another #WebKitWebContext with automation already enabled.
func (x *WebContext) SetAutomationAllowed(AllowedVar bool) {

	xWebContextSetAutomationAllowed(x.GoPointer(), AllowedVar)

}

var xWebContextSetCacheModel func(uintptr, CacheModel)

// Specifies a usage model for WebViews.
//
// Specifies a usage model for WebViews, which WebKit will use to
// determine its caching behavior. All web views follow the cache
// model. This cache model determines the RAM and disk space to use
// for caching previously viewed content .
//
// Research indicates that users tend to browse within clusters of
// documents that hold resources in common, and to revisit previously
// visited documents. WebKit and the frameworks below it include
// built-in caches that take advantage of these patterns,
// substantially improving document load speed in browsing
// situations. The WebKit cache model controls the behaviors of all of
// these caches, including various WebCore caches.
//
// Browsers can improve document load speed substantially by
// specifying %WEBKIT_CACHE_MODEL_WEB_BROWSER. Applications without a
// browsing interface can reduce memory usage substantially by
// specifying %WEBKIT_CACHE_MODEL_DOCUMENT_VIEWER. The default value is
// %WEBKIT_CACHE_MODEL_WEB_BROWSER.
func (x *WebContext) SetCacheModel(CacheModelVar CacheModel) {

	xWebContextSetCacheModel(x.GoPointer(), CacheModelVar)

}

var xWebContextSetPreferredLanguages func(uintptr, []string)

// Set the list of preferred languages.
//
// Set the list of preferred languages, sorted from most desirable
// to least desirable. The list will be used in the following ways:
//
//   - Determining how to build the `Accept-Language` HTTP header that will be
//     included in the network requests started by the #WebKitWebContext.
//   - Setting the values of `navigator.language` and `navigator.languages`.
//   - The first item in the list sets the default locale for JavaScript
//     `Intl` functions.
func (x *WebContext) SetPreferredLanguages(LanguagesVar []string) {

	xWebContextSetPreferredLanguages(x.GoPointer(), LanguagesVar)

}

var xWebContextSetSpellCheckingEnabled func(uintptr, bool)

// Enable or disable the spell checking feature.
func (x *WebContext) SetSpellCheckingEnabled(EnabledVar bool) {

	xWebContextSetSpellCheckingEnabled(x.GoPointer(), EnabledVar)

}

var xWebContextSetSpellCheckingLanguages func(uintptr, []string)

// Set the list of spell checking languages to be used for spell
// checking.
//
// The locale string typically is in the form lang_COUNTRY, where lang
// is an ISO-639 language code, and COUNTRY is an ISO-3166 country code.
// For instance, sv_FI for Swedish as written in Finland or pt_BR
// for Portuguese as written in Brazil.
//
// You need to call this function with a valid list of languages at
// least once in order to properly enable the spell checking feature
// in WebKit.
func (x *WebContext) SetSpellCheckingLanguages(LanguagesVar []string) {

	xWebContextSetSpellCheckingLanguages(x.GoPointer(), LanguagesVar)

}

var xWebContextSetWebProcessExtensionsDirectory func(uintptr, string)

// Set the directory where WebKit will look for web process extensions.
//
// This method must be called before loading anything in this context,
// otherwise it will not have any effect. You can connect to
// #WebKitWebContext::initialize-web-process-extensions to call this method
// before anything is loaded.
//
// If your web process extension is installed to an unusual location,
// then you may also need to call webkit_web_context_add_path_to_sandbox().
func (x *WebContext) SetWebProcessExtensionsDirectory(DirectoryVar string) {

	xWebContextSetWebProcessExtensionsDirectory(x.GoPointer(), DirectoryVar)

}

var xWebContextSetWebProcessExtensionsInitializationUserData func(uintptr, *glib.Variant)

// Set user data to be passed to Web Extensions on initialization.
//
// The data will be passed to the
// #WebKitWebProcessExtensionInitializeWithUserDataFunction.
// This method must be called before loading anything in this context,
// otherwise it will not have any effect. You can connect to
// #WebKitWebContext::initialize-web-process-extensions to call this method
// before anything is loaded.
func (x *WebContext) SetWebProcessExtensionsInitializationUserData(UserDataVar *glib.Variant) {

	xWebContextSetWebProcessExtensionsInitializationUserData(x.GoPointer(), UserDataVar)

}

func (c *WebContext) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *WebContext) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// This signal is emitted when a new automation request is made.
// Note that it will never be emitted if automation is not enabled in @context,
// see webkit_web_context_set_automation_allowed() for more details.
func (x *WebContext) ConnectAutomationStarted(cb *func(WebContext, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "automation-started", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, SessionVarp uintptr) {
		fa := WebContext{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, SessionVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "automation-started", cbRefPtr)
}

// This signal is emitted when a #WebKitWebContext needs to set
// initial notification permissions for a web process. It is emitted
// when a new web process is about to be launched, and signals the
// most appropriate moment to use
// webkit_web_context_initialize_notification_permissions(). If no
// notification permissions have changed since the last time this
// signal was emitted, then there is no need to call
// webkit_web_context_initialize_notification_permissions() again.
func (x *WebContext) ConnectInitializeNotificationPermissions(cb *func(WebContext)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "initialize-notification-permissions", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := WebContext{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "initialize-notification-permissions", cbRefPtr)
}

// This signal is emitted when a new web process is about to be
// launched. It signals the most appropriate moment to use
// webkit_web_context_set_web_process_extensions_initialization_user_data()
// and webkit_web_context_set_web_process_extensions_directory().
func (x *WebContext) ConnectInitializeWebProcessExtensions(cb *func(WebContext)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "initialize-web-process-extensions", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := WebContext{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "initialize-web-process-extensions", cbRefPtr)
}

// This signal is emitted when a #WebKitUserMessage is received from a
// web process extension. You can reply to the message using
// webkit_user_message_send_reply().
//
// You can handle the user message asynchronously by calling g_object_ref() on
// @message and returning %TRUE.
func (x *WebContext) ConnectUserMessageReceived(cb *func(WebContext, uintptr) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "user-message-received", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, MessageVarp uintptr) bool {
		fa := WebContext{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, MessageVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "user-message-received", cbRefPtr)
}

var xWebContextGetDefault func() uintptr

// Gets the default web context.
func WebContextGetDefault() *WebContext {
	var cls *WebContext

	cret := xWebContextGetDefault()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &WebContext{}
	cls.Ptr = cret
	return cls
}

func init() {
	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("WEBKIT") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xCacheModelGLibType, libs, "webkit_cache_model_get_type")

	core.PuregoSafeRegister(&xWebContextGLibType, libs, "webkit_web_context_get_type")

	core.PuregoSafeRegister(&xNewWebContext, libs, "webkit_web_context_new")

	core.PuregoSafeRegister(&xWebContextAddPathToSandbox, libs, "webkit_web_context_add_path_to_sandbox")
	core.PuregoSafeRegister(&xWebContextGetCacheModel, libs, "webkit_web_context_get_cache_model")
	core.PuregoSafeRegister(&xWebContextGetGeolocationManager, libs, "webkit_web_context_get_geolocation_manager")
	core.PuregoSafeRegister(&xWebContextGetNetworkSessionForAutomation, libs, "webkit_web_context_get_network_session_for_automation")
	core.PuregoSafeRegister(&xWebContextGetSecurityManager, libs, "webkit_web_context_get_security_manager")
	core.PuregoSafeRegister(&xWebContextGetSpellCheckingEnabled, libs, "webkit_web_context_get_spell_checking_enabled")
	core.PuregoSafeRegister(&xWebContextGetSpellCheckingLanguages, libs, "webkit_web_context_get_spell_checking_languages")
	core.PuregoSafeRegister(&xWebContextGetTimeZoneOverride, libs, "webkit_web_context_get_time_zone_override")
	core.PuregoSafeRegister(&xWebContextInitializeNotificationPermissions, libs, "webkit_web_context_initialize_notification_permissions")
	core.PuregoSafeRegister(&xWebContextIsAutomationAllowed, libs, "webkit_web_context_is_automation_allowed")
	core.PuregoSafeRegister(&xWebContextRegisterUriScheme, libs, "webkit_web_context_register_uri_scheme")
	core.PuregoSafeRegister(&xWebContextSendMessageToAllExtensions, libs, "webkit_web_context_send_message_to_all_extensions")
	core.PuregoSafeRegister(&xWebContextSetAutomationAllowed, libs, "webkit_web_context_set_automation_allowed")
	core.PuregoSafeRegister(&xWebContextSetCacheModel, libs, "webkit_web_context_set_cache_model")
	core.PuregoSafeRegister(&xWebContextSetPreferredLanguages, libs, "webkit_web_context_set_preferred_languages")
	core.PuregoSafeRegister(&xWebContextSetSpellCheckingEnabled, libs, "webkit_web_context_set_spell_checking_enabled")
	core.PuregoSafeRegister(&xWebContextSetSpellCheckingLanguages, libs, "webkit_web_context_set_spell_checking_languages")
	core.PuregoSafeRegister(&xWebContextSetWebProcessExtensionsDirectory, libs, "webkit_web_context_set_web_process_extensions_directory")
	core.PuregoSafeRegister(&xWebContextSetWebProcessExtensionsInitializationUserData, libs, "webkit_web_context_set_web_process_extensions_initialization_user_data")

	core.PuregoSafeRegister(&xWebContextGetDefault, libs, "webkit_web_context_get_default")

}
