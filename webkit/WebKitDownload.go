// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package webkit

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type DownloadClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass
}

func (x *DownloadClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Object used to communicate with the application when downloading.
//
// #WebKitDownload carries information about a download request and
// response, including a #WebKitURIRequest and a #WebKitURIResponse
// objects. The application may use this object to control the
// download process, or to simply figure out what is to be downloaded,
// and handle the download process itself.
type Download struct {
	gobject.Object
}

var xDownloadGLibType func() types.GType

func DownloadGLibType() types.GType {
	return xDownloadGLibType()
}

func DownloadNewFromInternalPtr(ptr uintptr) *Download {
	cls := &Download{}
	cls.Ptr = ptr
	return cls
}

var xDownloadCancel func(uintptr)

// Cancels the download.
//
// When the ongoing download
// operation is effectively cancelled the signal
// #WebKitDownload::failed is emitted with
// %WEBKIT_DOWNLOAD_ERROR_CANCELLED_BY_USER error.
func (x *Download) Cancel() {

	xDownloadCancel(x.GoPointer())

}

var xDownloadGetAllowOverwrite func(uintptr) bool

// Returns the current value of the #WebKitDownload:allow-overwrite property.
//
// Returns the current value of the #WebKitDownload:allow-overwrite property,
// which determines whether the download will overwrite an existing file on
// disk, or if it will fail if the destination already exists.
func (x *Download) GetAllowOverwrite() bool {

	cret := xDownloadGetAllowOverwrite(x.GoPointer())
	return cret
}

var xDownloadGetDestination func(uintptr) string

// Obtains the destination to which the downloaded file will be written.
//
// You can connect to #WebKitDownload::created-destination to make
// sure this method returns a valid destination.
func (x *Download) GetDestination() string {

	cret := xDownloadGetDestination(x.GoPointer())
	return cret
}

var xDownloadGetElapsedTime func(uintptr) float64

// Gets the elapsed time in seconds, including any fractional part.
//
// If the download finished, had an error or was cancelled this is
// the time between its start and the event.
func (x *Download) GetElapsedTime() float64 {

	cret := xDownloadGetElapsedTime(x.GoPointer())
	return cret
}

var xDownloadGetEstimatedProgress func(uintptr) float64

// Gets the value of the #WebKitDownload:estimated-progress property.
// Gets the value of the #WebKitDownload:estimated-progress property.
// You can monitor the estimated progress of the download operation by
// connecting to the notify::estimated-progress signal of @download.
func (x *Download) GetEstimatedProgress() float64 {

	cret := xDownloadGetEstimatedProgress(x.GoPointer())
	return cret
}

var xDownloadGetReceivedDataLength func(uintptr) uint64

// Gets the length of the data already downloaded for @download.
//
// Gets the length of the data already downloaded for @download
// in bytes.
func (x *Download) GetReceivedDataLength() uint64 {

	cret := xDownloadGetReceivedDataLength(x.GoPointer())
	return cret
}

var xDownloadGetRequest func(uintptr) uintptr

// Retrieves the #WebKitURIRequest object that backs the download
// process.
func (x *Download) GetRequest() *URIRequest {
	var cls *URIRequest

	cret := xDownloadGetRequest(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &URIRequest{}
	cls.Ptr = cret
	return cls
}

var xDownloadGetResponse func(uintptr) uintptr

// Retrieves the #WebKitURIResponse object that backs the download process.
//
// Retrieves the #WebKitURIResponse object that backs the download
// process. This method returns %NULL if called before the response
// is received from the server. You can connect to notify::response
// signal to be notified when the response is received.
func (x *Download) GetResponse() *URIResponse {
	var cls *URIResponse

	cret := xDownloadGetResponse(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &URIResponse{}
	cls.Ptr = cret
	return cls
}

var xDownloadGetWebView func(uintptr) uintptr

// Get the #WebKitWebView that initiated the download.
func (x *Download) GetWebView() *WebView {
	var cls *WebView

	cret := xDownloadGetWebView(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &WebView{}
	cls.Ptr = cret
	return cls
}

var xDownloadSetAllowOverwrite func(uintptr, bool)

// Sets the #WebKitDownload:allow-overwrite property.
//
// Sets the #WebKitDownload:allow-overwrite property, which determines whether
// the download may overwrite an existing file on disk, or if it will fail if
// the destination already exists.
func (x *Download) SetAllowOverwrite(AllowedVar bool) {

	xDownloadSetAllowOverwrite(x.GoPointer(), AllowedVar)

}

var xDownloadSetDestination func(uintptr, string)

// Sets the destination to which the downloaded file will be written.
//
// This method should be called before the download transfer
// starts or it will not have any effect on the ongoing download
// operation. To set the destination using the filename suggested
// by the server connect to #WebKitDownload::decide-destination
// signal and call webkit_download_set_destination(). If you want to
// set a fixed destination that doesn't depend on the suggested
// filename you can connect to notify::response signal and call
// webkit_download_set_destination().
//
// If #WebKitDownload::decide-destination signal is not handled
// and destination is not set when the download transfer starts,
// the file will be saved with the filename suggested by the server in
// %G_USER_DIRECTORY_DOWNLOAD directory.
func (x *Download) SetDestination(DestinationVar string) {

	xDownloadSetDestination(x.GoPointer(), DestinationVar)

}

func (c *Download) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *Download) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyAllowOverwrite sets the "allow-overwrite" property.
// Whether or not the download is allowed to overwrite an existing file on
// disk. If this property is %FALSE and the destination already exists,
// the download will fail.
func (x *Download) SetPropertyAllowOverwrite(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("allow-overwrite", &v)
}

// GetPropertyAllowOverwrite gets the "allow-overwrite" property.
// Whether or not the download is allowed to overwrite an existing file on
// disk. If this property is %FALSE and the destination already exists,
// the download will fail.
func (x *Download) GetPropertyAllowOverwrite() bool {
	var v gobject.Value
	x.GetProperty("allow-overwrite", &v)
	return v.GetBoolean()
}

// GetPropertyDestination gets the "destination" property.
// The local path to where the download will be saved.
func (x *Download) GetPropertyDestination() string {
	var v gobject.Value
	x.GetProperty("destination", &v)
	return v.GetString()
}

// GetPropertyEstimatedProgress gets the "estimated-progress" property.
// An estimate of the percent completion for the download operation.
// This value will range from 0.0 to 1.0. The value is an estimate
// based on the total number of bytes expected to be received for
// a download.
// If you need a more accurate progress information you can connect to
// #WebKitDownload::received-data signal to track the progress.
func (x *Download) GetPropertyEstimatedProgress() float64 {
	var v gobject.Value
	x.GetProperty("estimated-progress", &v)
	return v.GetDouble()
}

// This signal is emitted after #WebKitDownload::decide-destination and before
// #WebKitDownload::received-data to notify that destination file has been
// created successfully at @destination.
func (x *Download) ConnectCreatedDestination(cb *func(Download, string)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "created-destination", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, DestinationVarp string) {
		fa := Download{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, DestinationVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "created-destination", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// This signal is emitted after response is received to
// decide a destination for the download using
// webkit_download_set_destination(). If this signal is not
// handled, the file will be downloaded to %G_USER_DIRECTORY_DOWNLOAD
// directory using @suggested_filename.
//
// Since 2.40, you may handle this signal asynchronously by
// returning %TRUE without calling webkit_download_set_destination().
// This indicates intent to eventually call webkit_download_set_destination().
// In this case, the download will not proceed until the destination is set
// or cancelled with webkit_download_cancel().
func (x *Download) ConnectDecideDestination(cb *func(Download, string) bool) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "decide-destination", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, SuggestedFilenameVarp string) bool {
		fa := Download{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, SuggestedFilenameVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "decide-destination", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// This signal is emitted when an error occurs during the download
// operation. The given @error, of the domain %WEBKIT_DOWNLOAD_ERROR,
// contains further details of the failure. If the download is cancelled
// with webkit_download_cancel(), this signal is emitted with error
// %WEBKIT_DOWNLOAD_ERROR_CANCELLED_BY_USER. The download operation finishes
// after an error and #WebKitDownload::finished signal is emitted after this one.
func (x *Download) ConnectFailed(cb *func(Download, uintptr)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "failed", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, ErrorVarp uintptr) {
		fa := Download{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ErrorVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "failed", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// This signal is emitted when download finishes successfully or due to an error.
// In case of errors #WebKitDownload::failed signal is emitted before this one.
func (x *Download) ConnectFinished(cb *func(Download)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "finished", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr) {
		fa := Download{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "finished", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

// This signal is emitted after response is received,
// every time new data has been written to the destination. It's
// useful to know the progress of the download operation.
func (x *Download) ConnectReceivedData(cb *func(Download, uint64)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "received-data", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, DataLengthVarp uint64) {
		fa := Download{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, DataLengthVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "received-data", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

func init() {
	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("WEBKIT") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xDownloadGLibType, libs, "webkit_download_get_type")

	core.PuregoSafeRegister(&xDownloadCancel, libs, "webkit_download_cancel")
	core.PuregoSafeRegister(&xDownloadGetAllowOverwrite, libs, "webkit_download_get_allow_overwrite")
	core.PuregoSafeRegister(&xDownloadGetDestination, libs, "webkit_download_get_destination")
	core.PuregoSafeRegister(&xDownloadGetElapsedTime, libs, "webkit_download_get_elapsed_time")
	core.PuregoSafeRegister(&xDownloadGetEstimatedProgress, libs, "webkit_download_get_estimated_progress")
	core.PuregoSafeRegister(&xDownloadGetReceivedDataLength, libs, "webkit_download_get_received_data_length")
	core.PuregoSafeRegister(&xDownloadGetRequest, libs, "webkit_download_get_request")
	core.PuregoSafeRegister(&xDownloadGetResponse, libs, "webkit_download_get_response")
	core.PuregoSafeRegister(&xDownloadGetWebView, libs, "webkit_download_get_web_view")
	core.PuregoSafeRegister(&xDownloadSetAllowOverwrite, libs, "webkit_download_set_allow_overwrite")
	core.PuregoSafeRegister(&xDownloadSetDestination, libs, "webkit_download_set_destination")

}
