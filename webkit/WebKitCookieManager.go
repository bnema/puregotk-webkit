// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package webkit

import (
	"structs"
	"unsafe"

	"github.com/bnema/puregotk-webkit/soup"
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type CookieManagerClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass
}

func (x *CookieManagerClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Enum values used to denote the cookie acceptance policies.
type CookieAcceptPolicy int

var xCookieAcceptPolicyGLibType func() types.GType

func CookieAcceptPolicyGLibType() types.GType {
	return xCookieAcceptPolicyGLibType()
}

const (

	// Accept all cookies unconditionally.
	CookiePolicyAcceptAlwaysValue CookieAcceptPolicy = 0
	// Reject all cookies unconditionally.
	CookiePolicyAcceptNeverValue CookieAcceptPolicy = 1
	// Accept only cookies set by the main document loaded.
	CookiePolicyAcceptNoThirdPartyValue CookieAcceptPolicy = 2
)

// Enum values used to denote the cookie persistent storage types.
type CookiePersistentStorage int

var xCookiePersistentStorageGLibType func() types.GType

func CookiePersistentStorageGLibType() types.GType {
	return xCookiePersistentStorageGLibType()
}

const (

	// Cookies are stored in a text
	//  file in the Mozilla "cookies.txt" format.
	CookiePersistentStorageTextValue CookiePersistentStorage = 0
	// Cookies are stored in a SQLite
	//  file in the current Mozilla format.
	CookiePersistentStorageSqliteValue CookiePersistentStorage = 1
)

// Defines how to handle cookies in a #WebKitWebContext.
//
// The WebKitCookieManager defines how to set up and handle cookies.
// You can get it from a #WebKitWebsiteDataManager with
// webkit_website_data_manager_get_cookie_manager(), and use it to set where to
// store cookies with webkit_cookie_manager_set_persistent_storage(),
// or to set the acceptance policy, with webkit_cookie_manager_get_accept_policy().
type CookieManager struct {
	gobject.Object
}

var xCookieManagerGLibType func() types.GType

func CookieManagerGLibType() types.GType {
	return xCookieManagerGLibType()
}

func CookieManagerNewFromInternalPtr(ptr uintptr) *CookieManager {
	cls := &CookieManager{}
	cls.Ptr = ptr
	return cls
}

var xCookieManagerAddCookie func(uintptr, *soup.Cookie, uintptr, uintptr, uintptr)

// Asynchronously add a #SoupCookie to the underlying storage.
//
// When the operation is finished, @callback will be called. You can then call
// webkit_cookie_manager_add_cookie_finish() to get the result of the operation.
func (x *CookieManager) AddCookie(CookieVar *soup.Cookie, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	xCookieManagerAddCookie(x.GoPointer(), CookieVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

var xCookieManagerAddCookieFinish func(uintptr, uintptr, **glib.Error) bool

// Finish an asynchronous operation started with webkit_cookie_manager_add_cookie().
func (x *CookieManager) AddCookieFinish(ResultVar gio.AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := xCookieManagerAddCookieFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xCookieManagerDeleteCookie func(uintptr, *soup.Cookie, uintptr, uintptr, uintptr)

// Asynchronously delete a #SoupCookie from the current session.
//
// When the operation is finished, @callback will be called. You can then call
// webkit_cookie_manager_delete_cookie_finish() to get the result of the operation.
func (x *CookieManager) DeleteCookie(CookieVar *soup.Cookie, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	xCookieManagerDeleteCookie(x.GoPointer(), CookieVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

var xCookieManagerDeleteCookieFinish func(uintptr, uintptr, **glib.Error) bool

// Finish an asynchronous operation started with webkit_cookie_manager_delete_cookie().
func (x *CookieManager) DeleteCookieFinish(ResultVar gio.AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := xCookieManagerDeleteCookieFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xCookieManagerGetAcceptPolicy func(uintptr, uintptr, uintptr, uintptr)

// Asynchronously get the cookie acceptance policy of @cookie_manager.
//
// Note that when policy was set to %WEBKIT_COOKIE_POLICY_ACCEPT_NO_THIRD_PARTY and
// ITP is enabled, this will return %WEBKIT_COOKIE_POLICY_ACCEPT_ALWAYS.
// See also webkit_website_data_manager_set_itp_enabled().
//
// When the operation is finished, @callback will be called. You can then call
// webkit_cookie_manager_get_accept_policy_finish() to get the result of the operation.
func (x *CookieManager) GetAcceptPolicy(CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	xCookieManagerGetAcceptPolicy(x.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

var xCookieManagerGetAcceptPolicyFinish func(uintptr, uintptr, **glib.Error) CookieAcceptPolicy

// Finish an asynchronous operation started with webkit_cookie_manager_get_accept_policy().
func (x *CookieManager) GetAcceptPolicyFinish(ResultVar gio.AsyncResult) (CookieAcceptPolicy, error) {
	var cerr *glib.Error

	cret := xCookieManagerGetAcceptPolicyFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xCookieManagerGetAllCookies func(uintptr, uintptr, uintptr, uintptr)

// Asynchronously get a list of #SoupCookie from @cookie_manager.
//
// When the operation is finished, @callback will be called. You can then call
// webkit_cookie_manager_get_all_cookies_finish() to get the result of the operation.
func (x *CookieManager) GetAllCookies(CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	xCookieManagerGetAllCookies(x.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

var xCookieManagerGetAllCookiesFinish func(uintptr, uintptr, **glib.Error) *glib.List

// Finish an asynchronous operation started with webkit_cookie_manager_get_all_cookies().
//
// The return value is a #GList of #SoupCookie instances which should be released
// with g_list_free_full() and soup_cookie_free().
func (x *CookieManager) GetAllCookiesFinish(ResultVar gio.AsyncResult) (*glib.List, error) {
	var cerr *glib.Error

	cret := xCookieManagerGetAllCookiesFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xCookieManagerGetCookies func(uintptr, string, uintptr, uintptr, uintptr)

// Asynchronously get a list of #SoupCookie from @cookie_manager.
//
// Asynchronously get a list of #SoupCookie from @cookie_manager associated with @uri, which
// must be either an HTTP or an HTTPS URL.
//
// When the operation is finished, @callback will be called. You can then call
// webkit_cookie_manager_get_cookies_finish() to get the result of the operation.
func (x *CookieManager) GetCookies(UriVar string, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	xCookieManagerGetCookies(x.GoPointer(), UriVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

var xCookieManagerGetCookiesFinish func(uintptr, uintptr, **glib.Error) *glib.List

// Finish an asynchronous operation started with webkit_cookie_manager_get_cookies().
//
// The return value is a #GList of #SoupCookie instances which should be released
// with g_list_free_full() and soup_cookie_free().
func (x *CookieManager) GetCookiesFinish(ResultVar gio.AsyncResult) (*glib.List, error) {
	var cerr *glib.Error

	cret := xCookieManagerGetCookiesFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xCookieManagerReplaceCookies func(uintptr, *glib.List, uintptr, uintptr, uintptr)

// Asynchronously replace all cookies in @cookie_manager with the given list of @cookies.
//
// When the operation is finished, @callback will be called. You can then call
// webkit_cookie_manager_replace_cookies_finish() to get the result of the operation.
func (x *CookieManager) ReplaceCookies(CookiesVar *glib.List, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	xCookieManagerReplaceCookies(x.GoPointer(), CookiesVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

var xCookieManagerReplaceCookiesFinish func(uintptr, uintptr, **glib.Error) bool

// Finish an asynchronous operation started with webkit_cookie_manager_replace_cookies().
func (x *CookieManager) ReplaceCookiesFinish(ResultVar gio.AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := xCookieManagerReplaceCookiesFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xCookieManagerSetAcceptPolicy func(uintptr, CookieAcceptPolicy)

// Set the cookie acceptance policy of @cookie_manager as @policy.
//
// Note that ITP has its own way to handle third-party cookies, so when it's enabled,
// and @policy is set to %WEBKIT_COOKIE_POLICY_ACCEPT_NO_THIRD_PARTY, %WEBKIT_COOKIE_POLICY_ACCEPT_ALWAYS
// will be used instead. Once disabled, the policy will be set back to %WEBKIT_COOKIE_POLICY_ACCEPT_NO_THIRD_PARTY.
// See also webkit_website_data_manager_set_itp_enabled().
func (x *CookieManager) SetAcceptPolicy(PolicyVar CookieAcceptPolicy) {

	xCookieManagerSetAcceptPolicy(x.GoPointer(), PolicyVar)

}

var xCookieManagerSetPersistentStorage func(uintptr, string, CookiePersistentStorage)

// Set non-session cookies.
//
// Set the @filename where non-session cookies are stored persistently using
// @storage as the format to read/write the cookies.
// Cookies are initially read from @filename to create an initial set of cookies.
// Then, non-session cookies will be written to @filename when the WebKitCookieManager::changed
// signal is emitted.
// By default, @cookie_manager doesn't store the cookies persistently, so you need to call this
// method to keep cookies saved across sessions.
//
// This method should never be called on a #WebKitCookieManager associated to an ephemeral #WebKitWebsiteDataManager.
func (x *CookieManager) SetPersistentStorage(FilenameVar string, StorageVar CookiePersistentStorage) {

	xCookieManagerSetPersistentStorage(x.GoPointer(), FilenameVar, StorageVar)

}

func (c *CookieManager) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *CookieManager) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// This signal is emitted when cookies are added, removed or modified.
func (x *CookieManager) ConnectChanged(cb *func(CookieManager)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "changed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := CookieManager{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "changed", cbRefPtr)
}

func init() {
	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("WEBKIT") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xCookieAcceptPolicyGLibType, libs, "webkit_cookie_accept_policy_get_type")

	core.PuregoSafeRegister(&xCookiePersistentStorageGLibType, libs, "webkit_cookie_persistent_storage_get_type")

	core.PuregoSafeRegister(&xCookieManagerGLibType, libs, "webkit_cookie_manager_get_type")

	core.PuregoSafeRegister(&xCookieManagerAddCookie, libs, "webkit_cookie_manager_add_cookie")
	core.PuregoSafeRegister(&xCookieManagerAddCookieFinish, libs, "webkit_cookie_manager_add_cookie_finish")
	core.PuregoSafeRegister(&xCookieManagerDeleteCookie, libs, "webkit_cookie_manager_delete_cookie")
	core.PuregoSafeRegister(&xCookieManagerDeleteCookieFinish, libs, "webkit_cookie_manager_delete_cookie_finish")
	core.PuregoSafeRegister(&xCookieManagerGetAcceptPolicy, libs, "webkit_cookie_manager_get_accept_policy")
	core.PuregoSafeRegister(&xCookieManagerGetAcceptPolicyFinish, libs, "webkit_cookie_manager_get_accept_policy_finish")
	core.PuregoSafeRegister(&xCookieManagerGetAllCookies, libs, "webkit_cookie_manager_get_all_cookies")
	core.PuregoSafeRegister(&xCookieManagerGetAllCookiesFinish, libs, "webkit_cookie_manager_get_all_cookies_finish")
	core.PuregoSafeRegister(&xCookieManagerGetCookies, libs, "webkit_cookie_manager_get_cookies")
	core.PuregoSafeRegister(&xCookieManagerGetCookiesFinish, libs, "webkit_cookie_manager_get_cookies_finish")
	core.PuregoSafeRegister(&xCookieManagerReplaceCookies, libs, "webkit_cookie_manager_replace_cookies")
	core.PuregoSafeRegister(&xCookieManagerReplaceCookiesFinish, libs, "webkit_cookie_manager_replace_cookies_finish")
	core.PuregoSafeRegister(&xCookieManagerSetAcceptPolicy, libs, "webkit_cookie_manager_set_accept_policy")
	core.PuregoSafeRegister(&xCookieManagerSetPersistentStorage, libs, "webkit_cookie_manager_set_persistent_storage")

}
