// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package webkit

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type WebInspectorClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass
}

func (x *WebInspectorClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Access to the WebKit inspector.
//
// The WebKit Inspector is a graphical tool to inspect and change the
// content of a #WebKitWebView. It also includes an interactive
// JavaScript debugger. Using this class one can get a #GtkWidget
// which can be embedded into an application to show the inspector.
//
// The inspector is available when the #WebKitSettings of the
// #WebKitWebView has set the #WebKitSettings:enable-developer-extras
// to true, otherwise no inspector is available.
//
// ```c
// // Enable the developer extras
// WebKitSettings *settings = webkit_web_view_get_settings (WEBKIT_WEB_VIEW(my_webview));
// g_object_set (G_OBJECT(settings), "enable-developer-extras", TRUE, NULL);
//
// // Load some data or reload to be able to inspect the page
// webkit_web_view_load_uri (WEBKIT_WEB_VIEW(my_webview), "http://www.gnome.org");
//
// // Show the inspector
// WebKitWebInspector *inspector = webkit_web_view_get_inspector (WEBKIT_WEB_VIEW(my_webview));
// webkit_web_inspector_show (WEBKIT_WEB_INSPECTOR(inspector));
// ```
type WebInspector struct {
	gobject.Object
}

var xWebInspectorGLibType func() types.GType

func WebInspectorGLibType() types.GType {
	return xWebInspectorGLibType()
}

func WebInspectorNewFromInternalPtr(ptr uintptr) *WebInspector {
	cls := &WebInspector{}
	cls.Ptr = ptr
	return cls
}

var xWebInspectorAttach func(uintptr)

// Request @inspector to be attached.
//
// The signal #WebKitWebInspector::attach
// will be emitted. If the inspector is already attached it does nothing.
func (x *WebInspector) Attach() {

	xWebInspectorAttach(x.GoPointer())

}

var xWebInspectorClose func(uintptr)

// Request @inspector to be closed.
func (x *WebInspector) Close() {

	xWebInspectorClose(x.GoPointer())

}

var xWebInspectorDetach func(uintptr)

// Request @inspector to be detached.
//
// The signal #WebKitWebInspector::detach
// will be emitted. If the inspector is already detached it does nothing.
func (x *WebInspector) Detach() {

	xWebInspectorDetach(x.GoPointer())

}

var xWebInspectorGetAttachedHeight func(uintptr) uint

// Get the height that the inspector view when attached.
//
// Get the height that the inspector view should have when
// it's attached. If the inspector view is not attached this
// returns 0.
func (x *WebInspector) GetAttachedHeight() uint {

	cret := xWebInspectorGetAttachedHeight(x.GoPointer())

	return cret
}

var xWebInspectorGetCanAttach func(uintptr) bool

// Whether the @inspector can be attached to the same window that contains
// the inspected view.
func (x *WebInspector) GetCanAttach() bool {

	cret := xWebInspectorGetCanAttach(x.GoPointer())

	return cret
}

var xWebInspectorGetInspectedUri func(uintptr) string

// Get the URI that is currently being inspected.
//
// This can be %NULL if
// nothing has been loaded yet in the inspected view, if the inspector
// has been closed or when inspected view was loaded from a HTML string
// instead of a URI.
func (x *WebInspector) GetInspectedUri() string {

	cret := xWebInspectorGetInspectedUri(x.GoPointer())

	return cret
}

var xWebInspectorGetWebView func(uintptr) uintptr

// Get the #WebKitWebViewBase used to display the inspector.
//
// This might be %NULL if the inspector hasn't been loaded yet,
// or it has been closed.
func (x *WebInspector) GetWebView() *WebViewBase {
	var cls *WebViewBase

	cret := xWebInspectorGetWebView(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &WebViewBase{}
	cls.Ptr = cret
	return cls
}

var xWebInspectorIsAttached func(uintptr) bool

// Whether the @inspector view is currently attached to the same window that contains
// the inspected view.
func (x *WebInspector) IsAttached() bool {

	cret := xWebInspectorIsAttached(x.GoPointer())

	return cret
}

var xWebInspectorShow func(uintptr)

// Request @inspector to be shown.
func (x *WebInspector) Show() {

	xWebInspectorShow(x.GoPointer())

}

func (c *WebInspector) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *WebInspector) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// GetPropertyAttachedHeight gets the "attached-height" property.
// The height that the inspector view should have when it is attached.
func (x *WebInspector) GetPropertyAttachedHeight() uint {
	var v gobject.Value
	x.GetProperty("attached-height", &v)
	return v.GetUint()
}

// GetPropertyCanAttach gets the "can-attach" property.
// Whether the @inspector can be attached to the same window that contains
// the inspected view.
func (x *WebInspector) GetPropertyCanAttach() bool {
	var v gobject.Value
	x.GetProperty("can-attach", &v)
	return v.GetBoolean()
}

// GetPropertyInspectedUri gets the "inspected-uri" property.
// The URI that is currently being inspected.
func (x *WebInspector) GetPropertyInspectedUri() string {
	var v gobject.Value
	x.GetProperty("inspected-uri", &v)
	return v.GetString()
}

// Emitted when the inspector is requested to be attached to the window
// where the inspected web view is.
// If this signal is not handled the inspector view will be automatically
// attached to the inspected view, so you only need to handle this signal
// if you want to attach the inspector view yourself (for example, to add
// the inspector view to a browser tab).
//
// To prevent the inspector view from being attached you can connect to this
// signal and simply return %TRUE.
func (x *WebInspector) ConnectAttach(cb *func(WebInspector) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "attach", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) bool {
		fa := WebInspector{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "attach", cbRefPtr)
}

// Emitted when the inspector should be shown.
//
// If the inspector is not attached the inspector window should be shown
// on top of any other windows.
// If the inspector is attached the inspector view should be made visible.
// For example, if the inspector view is attached using a tab in a browser
// window, the browser window should be raised and the tab containing the
// inspector view should be the active one.
// In both cases, if this signal is not handled, the default implementation
// calls gtk_window_present() on the current toplevel #GtkWindow of the
// inspector view.
func (x *WebInspector) ConnectBringToFront(cb *func(WebInspector) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "bring-to-front", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) bool {
		fa := WebInspector{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "bring-to-front", cbRefPtr)
}

// Emitted when the inspector page is closed. If you are using your own
// inspector window, you should connect to this signal and destroy your
// window.
func (x *WebInspector) ConnectClosed(cb *func(WebInspector)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "closed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := WebInspector{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "closed", cbRefPtr)
}

// Emitted when the inspector is requested to be detached from the window
// it is currently attached to. The inspector is detached when the inspector page
// is about to be closed, and this signal is emitted right before
// #WebKitWebInspector::closed, or when the user clicks on the detach button
// in the inspector view to show the inspector in a separate window. In this case
// the signal #WebKitWebInspector::open-window is emitted after this one.
//
// To prevent the inspector view from being detached you can connect to this
// signal and simply return %TRUE.
func (x *WebInspector) ConnectDetach(cb *func(WebInspector) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "detach", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) bool {
		fa := WebInspector{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "detach", cbRefPtr)
}

// Emitted when the inspector is requested to open in a separate window.
// If this signal is not handled, a #GtkWindow with the inspector will be
// created and shown, so you only need to handle this signal if you want
// to use your own window.
// This signal is emitted after #WebKitWebInspector::detach to show
// the inspector in a separate window after being detached.
//
// To prevent the inspector from being shown you can connect to this
// signal and simply return %TRUE
func (x *WebInspector) ConnectOpenWindow(cb *func(WebInspector) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "open-window", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) bool {
		fa := WebInspector{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "open-window", cbRefPtr)
}

func init() {
	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("WEBKIT") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xWebInspectorGLibType, libs, "webkit_web_inspector_get_type")

	core.PuregoSafeRegister(&xWebInspectorAttach, libs, "webkit_web_inspector_attach")
	core.PuregoSafeRegister(&xWebInspectorClose, libs, "webkit_web_inspector_close")
	core.PuregoSafeRegister(&xWebInspectorDetach, libs, "webkit_web_inspector_detach")
	core.PuregoSafeRegister(&xWebInspectorGetAttachedHeight, libs, "webkit_web_inspector_get_attached_height")
	core.PuregoSafeRegister(&xWebInspectorGetCanAttach, libs, "webkit_web_inspector_get_can_attach")
	core.PuregoSafeRegister(&xWebInspectorGetInspectedUri, libs, "webkit_web_inspector_get_inspected_uri")
	core.PuregoSafeRegister(&xWebInspectorGetWebView, libs, "webkit_web_inspector_get_web_view")
	core.PuregoSafeRegister(&xWebInspectorIsAttached, libs, "webkit_web_inspector_is_attached")
	core.PuregoSafeRegister(&xWebInspectorShow, libs, "webkit_web_inspector_show")

}
