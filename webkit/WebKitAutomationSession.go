// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package webkit

import (
	"fmt"
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type AutomationSessionClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass
}

func (x *AutomationSessionClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Enum values used for determining the automation browsing context presentation.
type AutomationBrowsingContextPresentation int

var xAutomationBrowsingContextPresentationGLibType func() types.GType

func AutomationBrowsingContextPresentationGLibType() types.GType {
	return xAutomationBrowsingContextPresentationGLibType()
}

const (

	// a window
	AutomationBrowsingContextPresentationWindowValue AutomationBrowsingContextPresentation = 0
	// a tab
	AutomationBrowsingContextPresentationTabValue AutomationBrowsingContextPresentation = 1
)

// Automation Session.
//
// WebKitAutomationSession represents an automation session of a WebKitWebContext.
// When a new session is requested, a WebKitAutomationSession is created and the signal
// WebKitWebContext::automation-started is emitted with the WebKitAutomationSession as
// argument. Then, the automation client can request the session to create a new
// #WebKitWebView to interact with it. When this happens the signal #WebKitAutomationSession::create-web-view
// is emitted.
type AutomationSession struct {
	gobject.Object
}

var xAutomationSessionGLibType func() types.GType

func AutomationSessionGLibType() types.GType {
	return xAutomationSessionGLibType()
}

func AutomationSessionNewFromInternalPtr(ptr uintptr) *AutomationSession {
	cls := &AutomationSession{}
	cls.Ptr = ptr
	return cls
}

var xAutomationSessionGetApplicationInfo func(uintptr) *ApplicationInfo

// Get the the previously set #WebKitAutomationSession.
//
// Get the #WebKitAutomationSession previously set with webkit_automation_session_set_application_info().
func (x *AutomationSession) GetApplicationInfo() *ApplicationInfo {

	cret := xAutomationSessionGetApplicationInfo(x.GoPointer())
	return cret
}

var xAutomationSessionGetId func(uintptr) string

// Get the unique identifier of a #WebKitAutomationSession
func (x *AutomationSession) GetId() string {

	cret := xAutomationSessionGetId(x.GoPointer())
	return cret
}

var xAutomationSessionSetApplicationInfo func(uintptr, *ApplicationInfo)

// Set the application information to @session.
//
// This information will be used by the driver service
// to match the requested capabilities with the actual application information. If this information
// is not provided to the session when a new automation session is requested, the creation might fail
// if the client requested a specific browser name or version. This will not have any effect when called
// after the automation session has been fully created, so this must be called in the callback of
// #WebKitWebContext::automation-started signal.
func (x *AutomationSession) SetApplicationInfo(InfoVar *ApplicationInfo) {

	xAutomationSessionSetApplicationInfo(x.GoPointer(), InfoVar)

}

func (c *AutomationSession) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *AutomationSession) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyId sets the "id" property.
// The session unique identifier.
func (x *AutomationSession) SetPropertyId(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("id", &v)
}

// GetPropertyId gets the "id" property.
// The session unique identifier.
func (x *AutomationSession) GetPropertyId() string {
	var v gobject.Value
	x.GetProperty("id", &v)
	return v.GetString()
}

// This signal is emitted when the automation client requests a new
// browsing context to interact with it. The callback handler should
// return a #WebKitWebView created with #WebKitWebView:is-controlled-by-automation
// construct property enabled and #WebKitWebView:automation-presentation-type construct
// property set if needed.
//
// If the signal is emitted with "tab" detail, the returned #WebKitWebView should be
// a new web view added to a new tab of the current browsing context window.
// If the signal is emitted with "window" detail, the returned #WebKitWebView should be
// a new web view added to a new window.
// When creating a new web view and there's an active browsing context, the new window
// or tab shouldn't be focused.
func (x *AutomationSession) ConnectCreateWebView(cb *func(AutomationSession) WebView) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "create-web-view", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) uintptr {
		fa := AutomationSession{}
		fa.Ptr = clsPtr
		cbFn := *cb

		CreateWebViewCls := cbFn(fa)
		return CreateWebViewCls.Ptr

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "create-web-view", cbRefPtr)
}

// ConnectCreateWebViewWithDetail connects to the "create-web-view" signal with a detail string.
// The detail is appended as "create-web-view::<detail>".
func (x *AutomationSession) ConnectCreateWebViewWithDetail(detail string, cb *func(AutomationSession) WebView) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	signalName := fmt.Sprintf("create-web-view::%s", detail)
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), signalName, cbRefPtr)
	}

	fcb := func(clsPtr uintptr) uintptr {
		fa := AutomationSession{}
		fa.Ptr = clsPtr
		cbFn := *cb

		CreateWebViewCls := cbFn(fa)
		return CreateWebViewCls.Ptr

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), signalName, cbRefPtr)
}

// This signal is emitted when the given automation session is about to finish.
// It allows clients to perform any cleanup tasks before the session is destroyed.
func (x *AutomationSession) ConnectWillClose(cb *func(AutomationSession)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "will-close", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := AutomationSession{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "will-close", cbRefPtr)
}

func init() {
	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("WEBKIT") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xAutomationBrowsingContextPresentationGLibType, libs, "webkit_automation_browsing_context_presentation_get_type")

	core.PuregoSafeRegister(&xAutomationSessionGLibType, libs, "webkit_automation_session_get_type")

	core.PuregoSafeRegister(&xAutomationSessionGetApplicationInfo, libs, "webkit_automation_session_get_application_info")
	core.PuregoSafeRegister(&xAutomationSessionGetId, libs, "webkit_automation_session_get_id")
	core.PuregoSafeRegister(&xAutomationSessionSetApplicationInfo, libs, "webkit_automation_session_set_application_info")

}
