// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package webkit

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type AuthenticationRequestClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass
}

func (x *AuthenticationRequestClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Enum values representing the authentication scheme.
type AuthenticationScheme int

var xAuthenticationSchemeGLibType func() types.GType

func AuthenticationSchemeGLibType() types.GType {
	return xAuthenticationSchemeGLibType()
}

const (

	// The default authentication scheme of WebKit.
	AuthenticationSchemeDefaultValue AuthenticationScheme = 1
	// Basic authentication scheme as defined in RFC 2617.
	AuthenticationSchemeHttpBasicValue AuthenticationScheme = 2
	// Digest authentication scheme as defined in RFC 2617.
	AuthenticationSchemeHttpDigestValue AuthenticationScheme = 3
	// HTML Form authentication.
	AuthenticationSchemeHtmlFormValue AuthenticationScheme = 4
	// NTLM Microsoft proprietary authentication scheme.
	AuthenticationSchemeNtlmValue AuthenticationScheme = 5
	// Negotiate (or SPNEGO) authentication scheme as defined in RFC 4559.
	AuthenticationSchemeNegotiateValue AuthenticationScheme = 6
	// Client Certificate Authentication (see RFC 2246).
	AuthenticationSchemeClientCertificateRequestedValue AuthenticationScheme = 7
	// Server Trust Authentication.
	AuthenticationSchemeServerTrustEvaluationRequestedValue AuthenticationScheme = 8
	// Client certificate PIN required for use. Since: 2.34
	AuthenticationSchemeClientCertificatePinRequestedValue AuthenticationScheme = 9
	// Authentication scheme unknown.
	AuthenticationSchemeUnknownValue AuthenticationScheme = 100
)

// Represents an authentication request.
//
// Whenever a client attempts to load a page protected by HTTP
// authentication, credentials will need to be provided to authorize access.
// To allow the client to decide how it wishes to handle authentication,
// WebKit will fire a #WebKitWebView::authenticate signal with a
// WebKitAuthenticationRequest object to provide client side
// authentication support. Credentials are exposed through the
// #WebKitCredential object.
//
// In case the client application does not wish
// to handle this signal WebKit will provide a default handler. To handle
// authentication asynchronously, simply increase the reference count of the
// WebKitAuthenticationRequest object.
type AuthenticationRequest struct {
	gobject.Object
}

var xAuthenticationRequestGLibType func() types.GType

func AuthenticationRequestGLibType() types.GType {
	return xAuthenticationRequestGLibType()
}

func AuthenticationRequestNewFromInternalPtr(ptr uintptr) *AuthenticationRequest {
	cls := &AuthenticationRequest{}
	cls.Ptr = ptr
	return cls
}

var xAuthenticationRequestAuthenticate func(uintptr, *Credential)

// Authenticate the #WebKitAuthenticationRequest.
//
// Authenticate the #WebKitAuthenticationRequest using the #WebKitCredential
// supplied. To continue without credentials, pass %NULL as @credential.
func (x *AuthenticationRequest) Authenticate(CredentialVar *Credential) {

	xAuthenticationRequestAuthenticate(x.GoPointer(), CredentialVar)

}

var xAuthenticationRequestCanSaveCredentials func(uintptr) bool

// Determine whether this #WebKitAuthenticationRequest should allow the storage of credentials.
//
// Determine whether the authentication method associated with this
// #WebKitAuthenticationRequest should allow the storage of credentials.
// This will return %FALSE if WebKit doesn't support credential storing,
// if private browsing is enabled, or if persistent credential storage has been
// disabled in #WebKitWebsiteDataManager, unless credentials saving has been
// explicitly enabled with webkit_authentication_request_set_can_save_credentials().
func (x *AuthenticationRequest) CanSaveCredentials() bool {

	cret := xAuthenticationRequestCanSaveCredentials(x.GoPointer())

	return cret
}

var xAuthenticationRequestCancel func(uintptr)

// Cancel the authentication challenge.
//
// This will also cancel the page loading and result in a
// #WebKitWebView::load-failed signal with a #WebKitNetworkError of type %WEBKIT_NETWORK_ERROR_CANCELLED being emitted.
func (x *AuthenticationRequest) Cancel() {

	xAuthenticationRequestCancel(x.GoPointer())

}

var xAuthenticationRequestGetCertificatePinFlags func(uintptr) gio.TlsPasswordFlags

// Get the #GTlsPasswordFlags of the %WEBKIT_AUTHENTICATION_SCHEME_CLIENT_CERTIFICATE_PIN_REQUESTED authentication challenge.
func (x *AuthenticationRequest) GetCertificatePinFlags() gio.TlsPasswordFlags {

	cret := xAuthenticationRequestGetCertificatePinFlags(x.GoPointer())

	return cret
}

var xAuthenticationRequestGetHost func(uintptr) string

// Get the host that this authentication challenge is applicable to.
func (x *AuthenticationRequest) GetHost() string {

	cret := xAuthenticationRequestGetHost(x.GoPointer())

	return cret
}

var xAuthenticationRequestGetPort func(uintptr) uint

// Get the port that this authentication challenge is applicable to.
func (x *AuthenticationRequest) GetPort() uint {

	cret := xAuthenticationRequestGetPort(x.GoPointer())

	return cret
}

var xAuthenticationRequestGetProposedCredential func(uintptr) *Credential

// Get the #WebKitCredential of the proposed authentication challenge.
//
// Get the #WebKitCredential of the proposed authentication challenge that was
// stored from a previous session. The client can use this directly for
// authentication or construct their own #WebKitCredential.
func (x *AuthenticationRequest) GetProposedCredential() *Credential {

	cret := xAuthenticationRequestGetProposedCredential(x.GoPointer())

	return cret
}

var xAuthenticationRequestGetRealm func(uintptr) string

// Get the realm that this authentication challenge is applicable to.
func (x *AuthenticationRequest) GetRealm() string {

	cret := xAuthenticationRequestGetRealm(x.GoPointer())

	return cret
}

var xAuthenticationRequestGetScheme func(uintptr) AuthenticationScheme

// Get the authentication scheme of the authentication challenge.
func (x *AuthenticationRequest) GetScheme() AuthenticationScheme {

	cret := xAuthenticationRequestGetScheme(x.GoPointer())

	return cret
}

var xAuthenticationRequestGetSecurityOrigin func(uintptr) *SecurityOrigin

// Get the #WebKitSecurityOrigin that this authentication challenge is applicable to.
func (x *AuthenticationRequest) GetSecurityOrigin() *SecurityOrigin {

	cret := xAuthenticationRequestGetSecurityOrigin(x.GoPointer())

	return cret
}

var xAuthenticationRequestIsForProxy func(uintptr) bool

// Determine whether the authentication challenge is associated with a proxy server.
//
// Determine whether the authentication challenge is associated with a proxy server rather than an "origin" server.
func (x *AuthenticationRequest) IsForProxy() bool {

	cret := xAuthenticationRequestIsForProxy(x.GoPointer())

	return cret
}

var xAuthenticationRequestIsRetry func(uintptr) bool

// Determine whether this this is a first attempt or a retry for this authentication challenge.
func (x *AuthenticationRequest) IsRetry() bool {

	cret := xAuthenticationRequestIsRetry(x.GoPointer())

	return cret
}

var xAuthenticationRequestSetCanSaveCredentials func(uintptr, bool)

// Set whether the authentication method associated with @request
// should allow the storage of credentials.
//
// Set whether the authentication method associated with @request
// should allow the storage of credentials.
// This should be used by applications handling their own credentials
// storage to indicate that it should be supported even when internal
// credential storage is disabled or unsupported.
// Note that storing of credentials will not be allowed on ephemeral
// sessions in any case.
func (x *AuthenticationRequest) SetCanSaveCredentials(EnabledVar bool) {

	xAuthenticationRequestSetCanSaveCredentials(x.GoPointer(), EnabledVar)

}

var xAuthenticationRequestSetProposedCredential func(uintptr, *Credential)

// Set the #WebKitCredential of the proposed authentication challenge.
//
// Set the #WebKitCredential of the proposed authentication challenge that was
// stored from a previous session. This should only be used by applications handling
// their own credential storage. (When using the default WebKit credential storage,
// webkit_authentication_request_get_proposed_credential() already contains previously-stored
// credentials.)
// Passing a %NULL @credential will clear the proposed credential.
func (x *AuthenticationRequest) SetProposedCredential(CredentialVar *Credential) {

	xAuthenticationRequestSetProposedCredential(x.GoPointer(), CredentialVar)

}

func (c *AuthenticationRequest) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *AuthenticationRequest) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// This signal is emitted when the user authentication request succeeded.
// Applications handling their own credential storage should connect to
// this signal to save the credentials.
func (x *AuthenticationRequest) ConnectAuthenticated(cb *func(AuthenticationRequest, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "authenticated", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, CredentialVarp uintptr) {
		fa := AuthenticationRequest{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, CredentialVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "authenticated", cbRefPtr)
}

// This signal is emitted when the user authentication request is
// cancelled. It allows the application to dismiss its authentication
// dialog in case of page load failure for example.
func (x *AuthenticationRequest) ConnectCancelled(cb *func(AuthenticationRequest)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "cancelled", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := AuthenticationRequest{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "cancelled", cbRefPtr)
}

func init() {
	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("WEBKIT") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xAuthenticationSchemeGLibType, libs, "webkit_authentication_scheme_get_type")

	core.PuregoSafeRegister(&xAuthenticationRequestGLibType, libs, "webkit_authentication_request_get_type")

	core.PuregoSafeRegister(&xAuthenticationRequestAuthenticate, libs, "webkit_authentication_request_authenticate")
	core.PuregoSafeRegister(&xAuthenticationRequestCanSaveCredentials, libs, "webkit_authentication_request_can_save_credentials")
	core.PuregoSafeRegister(&xAuthenticationRequestCancel, libs, "webkit_authentication_request_cancel")
	core.PuregoSafeRegister(&xAuthenticationRequestGetCertificatePinFlags, libs, "webkit_authentication_request_get_certificate_pin_flags")
	core.PuregoSafeRegister(&xAuthenticationRequestGetHost, libs, "webkit_authentication_request_get_host")
	core.PuregoSafeRegister(&xAuthenticationRequestGetPort, libs, "webkit_authentication_request_get_port")
	core.PuregoSafeRegister(&xAuthenticationRequestGetProposedCredential, libs, "webkit_authentication_request_get_proposed_credential")
	core.PuregoSafeRegister(&xAuthenticationRequestGetRealm, libs, "webkit_authentication_request_get_realm")
	core.PuregoSafeRegister(&xAuthenticationRequestGetScheme, libs, "webkit_authentication_request_get_scheme")
	core.PuregoSafeRegister(&xAuthenticationRequestGetSecurityOrigin, libs, "webkit_authentication_request_get_security_origin")
	core.PuregoSafeRegister(&xAuthenticationRequestIsForProxy, libs, "webkit_authentication_request_is_for_proxy")
	core.PuregoSafeRegister(&xAuthenticationRequestIsRetry, libs, "webkit_authentication_request_is_retry")
	core.PuregoSafeRegister(&xAuthenticationRequestSetCanSaveCredentials, libs, "webkit_authentication_request_set_can_save_credentials")
	core.PuregoSafeRegister(&xAuthenticationRequestSetProposedCredential, libs, "webkit_authentication_request_set_proposed_credential")

}
