// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package soup

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type AuthClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass

	SchemeName uintptr

	Strength uint

	xUpdate uintptr

	xGetProtectionSpace uintptr

	xAuthenticate uintptr

	xIsAuthenticated uintptr

	xGetAuthorization uintptr

	xIsReady uintptr

	xCanAuthenticate uintptr

	Padding [6]uintptr
}

func (x *AuthClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideUpdate sets the "update" callback function.
func (x *AuthClass) OverrideUpdate(cb func(*Auth, *Message, *glib.HashTable) bool) {
	if cb == nil {
		x.xUpdate = 0
	} else {
		x.xUpdate = purego.NewCallback(func(AuthVarp uintptr, MsgVarp uintptr, AuthHeaderVarp *glib.HashTable) bool {
			return cb(AuthNewFromInternalPtr(AuthVarp), MessageNewFromInternalPtr(MsgVarp), AuthHeaderVarp)
		})
	}
}

// GetUpdate gets the "update" callback function.
func (x *AuthClass) GetUpdate() func(*Auth, *Message, *glib.HashTable) bool {
	if x.xUpdate == 0 {
		return nil
	}
	var rawCallback func(AuthVarp uintptr, MsgVarp uintptr, AuthHeaderVarp *glib.HashTable) bool
	purego.RegisterFunc(&rawCallback, x.xUpdate)
	return func(AuthVar *Auth, MsgVar *Message, AuthHeaderVar *glib.HashTable) bool {
		return rawCallback(AuthVar.GoPointer(), MsgVar.GoPointer(), AuthHeaderVar)
	}
}

// OverrideGetProtectionSpace sets the "get_protection_space" callback function.
func (x *AuthClass) OverrideGetProtectionSpace(cb func(*Auth, *glib.Uri) *glib.SList) {
	if cb == nil {
		x.xGetProtectionSpace = 0
	} else {
		x.xGetProtectionSpace = purego.NewCallback(func(AuthVarp uintptr, SourceUriVarp *glib.Uri) *glib.SList {
			return cb(AuthNewFromInternalPtr(AuthVarp), SourceUriVarp)
		})
	}
}

// GetGetProtectionSpace gets the "get_protection_space" callback function.
func (x *AuthClass) GetGetProtectionSpace() func(*Auth, *glib.Uri) *glib.SList {
	if x.xGetProtectionSpace == 0 {
		return nil
	}
	var rawCallback func(AuthVarp uintptr, SourceUriVarp *glib.Uri) *glib.SList
	purego.RegisterFunc(&rawCallback, x.xGetProtectionSpace)
	return func(AuthVar *Auth, SourceUriVar *glib.Uri) *glib.SList {
		return rawCallback(AuthVar.GoPointer(), SourceUriVar)
	}
}

// OverrideAuthenticate sets the "authenticate" callback function.
func (x *AuthClass) OverrideAuthenticate(cb func(*Auth, string, string)) {
	if cb == nil {
		x.xAuthenticate = 0
	} else {
		x.xAuthenticate = purego.NewCallback(func(AuthVarp uintptr, UsernameVarp string, PasswordVarp string) {
			cb(AuthNewFromInternalPtr(AuthVarp), UsernameVarp, PasswordVarp)
		})
	}
}

// GetAuthenticate gets the "authenticate" callback function.
func (x *AuthClass) GetAuthenticate() func(*Auth, string, string) {
	if x.xAuthenticate == 0 {
		return nil
	}
	var rawCallback func(AuthVarp uintptr, UsernameVarp string, PasswordVarp string)
	purego.RegisterFunc(&rawCallback, x.xAuthenticate)
	return func(AuthVar *Auth, UsernameVar string, PasswordVar string) {
		rawCallback(AuthVar.GoPointer(), UsernameVar, PasswordVar)
	}
}

// OverrideIsAuthenticated sets the "is_authenticated" callback function.
func (x *AuthClass) OverrideIsAuthenticated(cb func(*Auth) bool) {
	if cb == nil {
		x.xIsAuthenticated = 0
	} else {
		x.xIsAuthenticated = purego.NewCallback(func(AuthVarp uintptr) bool {
			return cb(AuthNewFromInternalPtr(AuthVarp))
		})
	}
}

// GetIsAuthenticated gets the "is_authenticated" callback function.
func (x *AuthClass) GetIsAuthenticated() func(*Auth) bool {
	if x.xIsAuthenticated == 0 {
		return nil
	}
	var rawCallback func(AuthVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xIsAuthenticated)
	return func(AuthVar *Auth) bool {
		return rawCallback(AuthVar.GoPointer())
	}
}

// OverrideGetAuthorization sets the "get_authorization" callback function.
func (x *AuthClass) OverrideGetAuthorization(cb func(*Auth, *Message) string) {
	if cb == nil {
		x.xGetAuthorization = 0
	} else {
		x.xGetAuthorization = purego.NewCallback(func(AuthVarp uintptr, MsgVarp uintptr) string {
			return cb(AuthNewFromInternalPtr(AuthVarp), MessageNewFromInternalPtr(MsgVarp))
		})
	}
}

// GetGetAuthorization gets the "get_authorization" callback function.
func (x *AuthClass) GetGetAuthorization() func(*Auth, *Message) string {
	if x.xGetAuthorization == 0 {
		return nil
	}
	var rawCallback func(AuthVarp uintptr, MsgVarp uintptr) string
	purego.RegisterFunc(&rawCallback, x.xGetAuthorization)
	return func(AuthVar *Auth, MsgVar *Message) string {
		return rawCallback(AuthVar.GoPointer(), MsgVar.GoPointer())
	}
}

// OverrideIsReady sets the "is_ready" callback function.
func (x *AuthClass) OverrideIsReady(cb func(*Auth, *Message) bool) {
	if cb == nil {
		x.xIsReady = 0
	} else {
		x.xIsReady = purego.NewCallback(func(AuthVarp uintptr, MsgVarp uintptr) bool {
			return cb(AuthNewFromInternalPtr(AuthVarp), MessageNewFromInternalPtr(MsgVarp))
		})
	}
}

// GetIsReady gets the "is_ready" callback function.
func (x *AuthClass) GetIsReady() func(*Auth, *Message) bool {
	if x.xIsReady == 0 {
		return nil
	}
	var rawCallback func(AuthVarp uintptr, MsgVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xIsReady)
	return func(AuthVar *Auth, MsgVar *Message) bool {
		return rawCallback(AuthVar.GoPointer(), MsgVar.GoPointer())
	}
}

// OverrideCanAuthenticate sets the "can_authenticate" callback function.
func (x *AuthClass) OverrideCanAuthenticate(cb func(*Auth) bool) {
	if cb == nil {
		x.xCanAuthenticate = 0
	} else {
		x.xCanAuthenticate = purego.NewCallback(func(AuthVarp uintptr) bool {
			return cb(AuthNewFromInternalPtr(AuthVarp))
		})
	}
}

// GetCanAuthenticate gets the "can_authenticate" callback function.
func (x *AuthClass) GetCanAuthenticate() func(*Auth) bool {
	if x.xCanAuthenticate == 0 {
		return nil
	}
	var rawCallback func(AuthVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xCanAuthenticate)
	return func(AuthVar *Auth) bool {
		return rawCallback(AuthVar.GoPointer())
	}
}

// The abstract base class for handling authentication.
//
// Specific HTTP Authentication mechanisms are implemented by its subclasses,
// but applications never need to be aware of the specific subclasses being
// used.
//
// #SoupAuth objects store the authentication data associated with a given bit
// of web space. They are created automatically by [class@Session].
type Auth struct {
	gobject.Object
}

var xAuthGLibType func() types.GType

func AuthGLibType() types.GType {
	return xAuthGLibType()
}

func AuthNewFromInternalPtr(ptr uintptr) *Auth {
	cls := &Auth{}
	cls.Ptr = ptr
	return cls
}

var xNewAuth func(types.GType, uintptr, string) uintptr

// Creates a new #SoupAuth of type @type with the information from
// @msg and @auth_header.
//
// This is called by [class@Session]; you will normally not create auths
// yourself.
func NewAuth(TypeVar types.GType, MsgVar *Message, AuthHeaderVar string) *Auth {
	var cls *Auth

	cret := xNewAuth(TypeVar, MsgVar.GoPointer(), AuthHeaderVar)

	if cret == 0 {
		return nil
	}
	cls = &Auth{}
	cls.Ptr = cret
	return cls
}

var xAuthAuthenticate func(uintptr, string, string)

// Call this on an auth to authenticate it.
//
// Normally this will cause the auth's message to be requeued with the new
// authentication info.
func (x *Auth) Authenticate(UsernameVar string, PasswordVar string) {

	xAuthAuthenticate(x.GoPointer(), UsernameVar, PasswordVar)

}

var xAuthCanAuthenticate func(uintptr) bool

// Tests if @auth is able to authenticate by providing credentials to the
// [method@Auth.authenticate].
func (x *Auth) CanAuthenticate() bool {

	cret := xAuthCanAuthenticate(x.GoPointer())

	return cret
}

var xAuthCancel func(uintptr)

// Call this on an auth to cancel it.
//
// You need to cancel an auth to complete an asynchronous authenticate operation
// when no credentials are provided ([method@Auth.authenticate] is not called).
// The #SoupAuth will be cancelled on dispose if it hans't been authenticated.
func (x *Auth) Cancel() {

	xAuthCancel(x.GoPointer())

}

var xAuthFreeProtectionSpace func(uintptr, *glib.SList)

// Frees @space.
func (x *Auth) FreeProtectionSpace(SpaceVar *glib.SList) {

	xAuthFreeProtectionSpace(x.GoPointer(), SpaceVar)

}

var xAuthGetAuthority func(uintptr) string

// Returns the authority (host:port) that @auth is associated with.
func (x *Auth) GetAuthority() string {

	cret := xAuthGetAuthority(x.GoPointer())

	return cret
}

var xAuthGetAuthorization func(uintptr, uintptr) string

// Generates an appropriate "Authorization" header for @msg.
//
// (The session will only call this if [method@Auth.is_authenticated] returned
// %TRUE.)
func (x *Auth) GetAuthorization(MsgVar *Message) string {

	cret := xAuthGetAuthorization(x.GoPointer(), MsgVar.GoPointer())

	return cret
}

var xAuthGetInfo func(uintptr) string

// Gets an opaque identifier for @auth.
//
// The identifier can be used as a hash key or the like. #SoupAuth objects from
// the same server with the same identifier refer to the same authentication
// domain (eg, the URLs associated with them take the same usernames and
// passwords).
func (x *Auth) GetInfo() string {

	cret := xAuthGetInfo(x.GoPointer())

	return cret
}

var xAuthGetProtectionSpace func(uintptr, *glib.Uri) *glib.SList

// Returns a list of paths on the server which @auth extends over.
//
// (All subdirectories of these paths are also assumed to be part
// of @auth's protection space, unless otherwise discovered not to
// be.)
func (x *Auth) GetProtectionSpace(SourceUriVar *glib.Uri) *glib.SList {

	cret := xAuthGetProtectionSpace(x.GoPointer(), SourceUriVar)

	return cret
}

var xAuthGetRealm func(uintptr) string

// Returns @auth's realm.
//
// This is an identifier that distinguishes separate authentication spaces on a
// given server, and may be some string that is meaningful to the user.
// (Although it is probably not localized.)
func (x *Auth) GetRealm() string {

	cret := xAuthGetRealm(x.GoPointer())

	return cret
}

var xAuthGetSchemeName func(uintptr) string

// soup_auth_get_scheme_name: (attributes org.gtk.Method.get_property=scheme-name)
// Returns @auth's scheme name. (Eg, "Basic", "Digest", or "NTLM")
func (x *Auth) GetSchemeName() string {

	cret := xAuthGetSchemeName(x.GoPointer())

	return cret
}

var xAuthIsAuthenticated func(uintptr) bool

// Tests if @auth has been given a username and password.
func (x *Auth) IsAuthenticated() bool {

	cret := xAuthIsAuthenticated(x.GoPointer())

	return cret
}

var xAuthIsCancelled func(uintptr) bool

// Tests if @auth has been cancelled
func (x *Auth) IsCancelled() bool {

	cret := xAuthIsCancelled(x.GoPointer())

	return cret
}

var xAuthIsForProxy func(uintptr) bool

// Tests whether or not @auth is associated with a proxy server rather
// than an "origin" server.
func (x *Auth) IsForProxy() bool {

	cret := xAuthIsForProxy(x.GoPointer())

	return cret
}

var xAuthIsReady func(uintptr, uintptr) bool

// Tests if @auth is ready to make a request for @msg with.
//
// For most auths, this is equivalent to [method@Auth.is_authenticated], but for
// some auth types (eg, NTLM), the auth may be sendable (eg, as an
// authentication request) even before it is authenticated.
func (x *Auth) IsReady(MsgVar *Message) bool {

	cret := xAuthIsReady(x.GoPointer(), MsgVar.GoPointer())

	return cret
}

var xAuthUpdate func(uintptr, uintptr, string) bool

// Updates @auth with the information from @msg and @auth_header,
// possibly un-authenticating it.
//
// As with [ctor@Auth.new], this is normally only used by [class@Session].
func (x *Auth) Update(MsgVar *Message, AuthHeaderVar string) bool {

	cret := xAuthUpdate(x.GoPointer(), MsgVar.GoPointer(), AuthHeaderVar)

	return cret
}

func (c *Auth) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *Auth) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyAuthority sets the "authority" property.
// The authority (host:port) being authenticated to.
func (x *Auth) SetPropertyAuthority(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("authority", &v)
}

// GetPropertyAuthority gets the "authority" property.
// The authority (host:port) being authenticated to.
func (x *Auth) GetPropertyAuthority() string {
	var v gobject.Value
	x.GetProperty("authority", &v)
	return v.GetString()
}

// GetPropertyIsAuthenticated gets the "is-authenticated" property.
// Whether or not the auth has been authenticated.
func (x *Auth) GetPropertyIsAuthenticated() bool {
	var v gobject.Value
	x.GetProperty("is-authenticated", &v)
	return v.GetBoolean()
}

// GetPropertyIsCancelled gets the "is-cancelled" property.
// Whether or not the auth has been cancelled.
func (x *Auth) GetPropertyIsCancelled() bool {
	var v gobject.Value
	x.GetProperty("is-cancelled", &v)
	return v.GetBoolean()
}

// SetPropertyIsForProxy sets the "is-for-proxy" property.
// Whether or not the auth is for a proxy server.
func (x *Auth) SetPropertyIsForProxy(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("is-for-proxy", &v)
}

// GetPropertyIsForProxy gets the "is-for-proxy" property.
// Whether or not the auth is for a proxy server.
func (x *Auth) GetPropertyIsForProxy() bool {
	var v gobject.Value
	x.GetProperty("is-for-proxy", &v)
	return v.GetBoolean()
}

// SetPropertyRealm sets the "realm" property.
// The authentication realm.
func (x *Auth) SetPropertyRealm(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("realm", &v)
}

// GetPropertyRealm gets the "realm" property.
// The authentication realm.
func (x *Auth) GetPropertyRealm() string {
	var v gobject.Value
	x.GetProperty("realm", &v)
	return v.GetString()
}

// GetPropertySchemeName gets the "scheme-name" property.
// The authentication scheme name.
func (x *Auth) GetPropertySchemeName() string {
	var v gobject.Value
	x.GetProperty("scheme-name", &v)
	return v.GetString()
}

func init() {
	core.SetPackageName("SOUP", "libsoup-3.0")
	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("SOUP") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xAuthGLibType, libs, "soup_auth_get_type")

	core.PuregoSafeRegister(&xNewAuth, libs, "soup_auth_new")

	core.PuregoSafeRegister(&xAuthAuthenticate, libs, "soup_auth_authenticate")
	core.PuregoSafeRegister(&xAuthCanAuthenticate, libs, "soup_auth_can_authenticate")
	core.PuregoSafeRegister(&xAuthCancel, libs, "soup_auth_cancel")
	core.PuregoSafeRegister(&xAuthFreeProtectionSpace, libs, "soup_auth_free_protection_space")
	core.PuregoSafeRegister(&xAuthGetAuthority, libs, "soup_auth_get_authority")
	core.PuregoSafeRegister(&xAuthGetAuthorization, libs, "soup_auth_get_authorization")
	core.PuregoSafeRegister(&xAuthGetInfo, libs, "soup_auth_get_info")
	core.PuregoSafeRegister(&xAuthGetProtectionSpace, libs, "soup_auth_get_protection_space")
	core.PuregoSafeRegister(&xAuthGetRealm, libs, "soup_auth_get_realm")
	core.PuregoSafeRegister(&xAuthGetSchemeName, libs, "soup_auth_get_scheme_name")
	core.PuregoSafeRegister(&xAuthIsAuthenticated, libs, "soup_auth_is_authenticated")
	core.PuregoSafeRegister(&xAuthIsCancelled, libs, "soup_auth_is_cancelled")
	core.PuregoSafeRegister(&xAuthIsForProxy, libs, "soup_auth_is_for_proxy")
	core.PuregoSafeRegister(&xAuthIsReady, libs, "soup_auth_is_ready")
	core.PuregoSafeRegister(&xAuthUpdate, libs, "soup_auth_update")

}
