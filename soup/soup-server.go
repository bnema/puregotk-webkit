// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package soup

import (
	"runtime"
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// A callback used to handle requests to a [class@Server].
//
// @path and @query contain the likewise-named components of the
// Request-URI, subject to certain assumptions. By default,
// [class@Server] decodes all percent-encoding in the URI path, such that
// `"/foo%2Fbar"` is treated the same as `"/foo/bar"`. If your
// server is serving resources in some non-POSIX-filesystem namespace,
// you may want to distinguish those as two distinct paths. In that
// case, you can set the [property@Server:raw-paths] property when creating
// the [class@Server], and it will leave those characters undecoded.
//
// @query contains the query component of the Request-URI parsed according to
// the rules for HTML form handling. Although this is the only commonly-used
// query string format in HTTP, there is nothing that actually requires that
// HTTP URIs use that format; if your server needs to use some other format, you
// can just ignore @query, and call [method@Message.get_uri] and parse the URI's
// query field yourself.
//
// See [method@Server.add_handler] and [method@Server.add_early_handler]
// for details of what handlers can/should do.
type ServerCallback func(uintptr, uintptr, string, *glib.HashTable, uintptr)

// A callback used to handle WebSocket requests to a #SoupServer.
//
// The callback will be invoked after sending the handshake response back to the
// client (and is only invoked if the handshake was successful).
//
// @path contains the path of the Request-URI, subject to the same
// rules as [callback@ServerCallback] `(qv)`.
type ServerWebsocketCallback func(uintptr, uintptr, string, uintptr, uintptr)

type ServerClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass

	xRequestStarted uintptr

	xRequestRead uintptr

	xRequestFinished uintptr

	xRequestAborted uintptr

	Padding [6]uintptr
}

func (x *ServerClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideRequestStarted sets the "request_started" callback function.
func (x *ServerClass) OverrideRequestStarted(cb func(*Server, *ServerMessage)) {
	if cb == nil {
		x.xRequestStarted = 0
	} else {
		x.xRequestStarted = purego.NewCallback(func(ServerVarp uintptr, MsgVarp uintptr) {
			cb(ServerNewFromInternalPtr(ServerVarp), ServerMessageNewFromInternalPtr(MsgVarp))
		})
	}
}

// GetRequestStarted gets the "request_started" callback function.
func (x *ServerClass) GetRequestStarted() func(*Server, *ServerMessage) {
	if x.xRequestStarted == 0 {
		return nil
	}
	var rawCallback func(ServerVarp uintptr, MsgVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xRequestStarted)
	return func(ServerVar *Server, MsgVar *ServerMessage) {
		rawCallback(ServerVar.GoPointer(), MsgVar.GoPointer())
	}
}

// OverrideRequestRead sets the "request_read" callback function.
func (x *ServerClass) OverrideRequestRead(cb func(*Server, *ServerMessage)) {
	if cb == nil {
		x.xRequestRead = 0
	} else {
		x.xRequestRead = purego.NewCallback(func(ServerVarp uintptr, MsgVarp uintptr) {
			cb(ServerNewFromInternalPtr(ServerVarp), ServerMessageNewFromInternalPtr(MsgVarp))
		})
	}
}

// GetRequestRead gets the "request_read" callback function.
func (x *ServerClass) GetRequestRead() func(*Server, *ServerMessage) {
	if x.xRequestRead == 0 {
		return nil
	}
	var rawCallback func(ServerVarp uintptr, MsgVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xRequestRead)
	return func(ServerVar *Server, MsgVar *ServerMessage) {
		rawCallback(ServerVar.GoPointer(), MsgVar.GoPointer())
	}
}

// OverrideRequestFinished sets the "request_finished" callback function.
func (x *ServerClass) OverrideRequestFinished(cb func(*Server, *ServerMessage)) {
	if cb == nil {
		x.xRequestFinished = 0
	} else {
		x.xRequestFinished = purego.NewCallback(func(ServerVarp uintptr, MsgVarp uintptr) {
			cb(ServerNewFromInternalPtr(ServerVarp), ServerMessageNewFromInternalPtr(MsgVarp))
		})
	}
}

// GetRequestFinished gets the "request_finished" callback function.
func (x *ServerClass) GetRequestFinished() func(*Server, *ServerMessage) {
	if x.xRequestFinished == 0 {
		return nil
	}
	var rawCallback func(ServerVarp uintptr, MsgVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xRequestFinished)
	return func(ServerVar *Server, MsgVar *ServerMessage) {
		rawCallback(ServerVar.GoPointer(), MsgVar.GoPointer())
	}
}

// OverrideRequestAborted sets the "request_aborted" callback function.
func (x *ServerClass) OverrideRequestAborted(cb func(*Server, *ServerMessage)) {
	if cb == nil {
		x.xRequestAborted = 0
	} else {
		x.xRequestAborted = purego.NewCallback(func(ServerVarp uintptr, MsgVarp uintptr) {
			cb(ServerNewFromInternalPtr(ServerVarp), ServerMessageNewFromInternalPtr(MsgVarp))
		})
	}
}

// GetRequestAborted gets the "request_aborted" callback function.
func (x *ServerClass) GetRequestAborted() func(*Server, *ServerMessage) {
	if x.xRequestAborted == 0 {
		return nil
	}
	var rawCallback func(ServerVarp uintptr, MsgVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xRequestAborted)
	return func(ServerVar *Server, MsgVar *ServerMessage) {
		rawCallback(ServerVar.GoPointer(), MsgVar.GoPointer())
	}
}

// Options to pass to [method@Server.listen], etc.
//
// %SOUP_SERVER_LISTEN_IPV4_ONLY and %SOUP_SERVER_LISTEN_IPV6_ONLY
// only make sense with [method@Server.listen_all] and
// [method@Server.listen_local], not plain [method@Server.listen] (which
// simply listens on whatever kind of socket you give it). And you
// cannot specify both of them in a single call.
type ServerListenOptions int

var xServerListenOptionsGLibType func() types.GType

func ServerListenOptionsGLibType() types.GType {
	return xServerListenOptionsGLibType()
}

const (

	// Listen for https connections rather
	//   than plain http.
	ServerListenHttpsValue ServerListenOptions = 1
	// Only listen on IPv4 interfaces.
	ServerListenIpv4OnlyValue ServerListenOptions = 2
	// Only listen on IPv6 interfaces.
	ServerListenIpv6OnlyValue ServerListenOptions = 4
)

// #SoupServer provides a basic implementation of an HTTP server. The
// recommended usage of this server is for internal use, tasks like
// a mock server for tests, a private service for IPC, etc. It is not
// recommended to be exposed to untrusted clients as it may be vulnerable
// to denial of service attacks or other exploits.
//
// To begin, create a server using [ctor@Server.new]. Add at least one
// handler by calling [method@Server.add_handler] or
// [method@Server.add_early_handler]; the handler will be called to
// process any requests underneath the path you pass. (If you want all
// requests to go to the same handler, just pass "/" (or %NULL) for
// the path.)
//
// When a new connection is accepted (or a new request is started on
// an existing persistent connection), the #SoupServer will emit
// [signal@Server::request-started] and then begin processing the request
// as described below, but note that once the message is assigned a
// status-code, then callbacks after that point will be
// skipped. Note also that it is not defined when the callbacks happen
// relative to various [class@ServerMessage] signals.
//
// Once the headers have been read, #SoupServer will check if there is
// a [class@AuthDomain] `(qv)` covering the Request-URI; if so, and if the
// message does not contain suitable authorization, then the
// [class@AuthDomain] will set a status of %SOUP_STATUS_UNAUTHORIZED on
// the message.
//
// After checking for authorization, #SoupServer will look for "early"
// handlers (added with [method@Server.add_early_handler]) matching the
// Request-URI. If one is found, it will be run; in particular, this
// can be used to connect to signals to do a streaming read of the
// request body.
//
// (At this point, if the request headers contain `Expect:
// 100-continue`, and a status code has been set, then
// #SoupServer will skip the remaining steps and return the response.
// If the request headers contain `Expect:
// 100-continue` and no status code has been set,
// #SoupServer will return a %SOUP_STATUS_CONTINUE status before
// continuing.)
//
// The server will then read in the response body (if present). At
// this point, if there are no handlers at all defined for the
// Request-URI, then the server will return %SOUP_STATUS_NOT_FOUND to
// the client.
//
// Otherwise (assuming no previous step assigned a status to the
// message) any "normal" handlers (added with
// [method@Server.add_handler]) for the message's Request-URI will be
// run.
//
// Then, if the path has a WebSocket handler registered (and has
// not yet been assigned a status), #SoupServer will attempt to
// validate the WebSocket handshake, filling in the response and
// setting a status of %SOUP_STATUS_SWITCHING_PROTOCOLS or
// %SOUP_STATUS_BAD_REQUEST accordingly.
//
// If the message still has no status code at this point (and has not
// been paused with [method@ServerMessage.pause]), then it will be
// given a status of %SOUP_STATUS_INTERNAL_SERVER_ERROR (because at
// least one handler ran, but returned without assigning a status).
//
// Finally, the server will emit [signal@Server::request-finished] (or
// [signal@Server::request-aborted] if an I/O error occurred before
// handling was completed).
//
// If you want to handle the special "*" URI (eg, "OPTIONS *"), you
// must explicitly register a handler for "*"; the default handler
// will not be used for that case.
//
// If you want to process https connections in addition to (or instead
// of) http connections, you can set the [property@Server:tls-certificate]
// property.
//
// Once the server is set up, make one or more calls to
// [method@Server.listen], [method@Server.listen_local], or
// [method@Server.listen_all] to tell it where to listen for
// connections. (All ports on a #SoupServer use the same handlers; if
// you need to handle some ports differently, such as returning
// different data for http and https, you'll need to create multiple
// `SoupServer`s, or else check the passed-in URI in the handler
// function.).
//
// #SoupServer will begin processing connections as soon as you return
// to (or start) the main loop for the current thread-default
// [struct@GLib.MainContext].
type Server struct {
	gobject.Object
}

var xServerGLibType func() types.GType

func ServerGLibType() types.GType {
	return xServerGLibType()
}

func ServerNewFromInternalPtr(ptr uintptr) *Server {
	cls := &Server{}
	cls.Ptr = ptr
	return cls
}

var xNewServer func(string, ...interface{}) uintptr

// Creates a new #SoupServer.
//
// This is exactly equivalent to calling [ctor@GObject.Object.new] and
// specifying %SOUP_TYPE_SERVER as the type.
func NewServer(Optname1Var string, varArgs ...interface{}) *Server {
	var cls *Server

	cret := xNewServer(Optname1Var, varArgs...)

	if cret == 0 {
		return nil
	}
	cls = &Server{}
	cls.Ptr = cret
	return cls
}

var xServerAcceptIostream func(uintptr, uintptr, uintptr, uintptr, **glib.Error) bool

// Adds a new client stream to the @server.
func (x *Server) AcceptIostream(StreamVar *gio.IOStream, LocalAddrVar *gio.SocketAddress, RemoteAddrVar *gio.SocketAddress) (bool, error) {
	var cerr *glib.Error

	cret := xServerAcceptIostream(x.GoPointer(), StreamVar.GoPointer(), LocalAddrVar.GoPointer(), RemoteAddrVar.GoPointer(), &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xServerAddAuthDomain func(uintptr, uintptr)

// Adds an authentication domain to @server.
//
// Each auth domain will have the chance to require authentication for each
// request that comes in; normally auth domains will require authentication for
// requests on certain paths that they have been set up to watch, or that meet
// other criteria set by the caller. If an auth domain determines that a request
// requires authentication (and the request doesn't contain authentication),
// @server will automatically reject the request with an appropriate status (401
// Unauthorized or 407 Proxy Authentication Required). If the request used the
// SoupServer:100-continue Expectation, @server will reject it before the
// request body is sent.
func (x *Server) AddAuthDomain(AuthDomainVar *AuthDomain) {

	xServerAddAuthDomain(x.GoPointer(), AuthDomainVar.GoPointer())

}

var xServerAddEarlyHandler func(uintptr, uintptr, uintptr, uintptr, uintptr)

// Adds an "early" handler to @server for requests prefixed by @path.
//
// Note that "normal" and "early" handlers are matched up together, so if you
// add a normal handler for "/foo" and an early handler for "/foo/bar", then a
// request to "/foo/bar" (or any path below it) will run only the early handler.
// (But if you add both handlers at the same path, then both will get run.)
//
// For requests under @path (that have not already been assigned a
// status code by a [class@AuthDomain] or a signal handler), @callback
// will be invoked after receiving the request headers, but before
// receiving the request body; the message's method and
// request-headers properties will be set.
//
// Early handlers are generally used for processing requests with request bodies
// in a streaming fashion. If you determine that the request will contain a
// message body, normally you would call [method@MessageBody.set_accumulate] on
// the message's request-body to turn off request-body accumulation, and connect
// to the message's [signal@ServerMessage::got-chunk] signal to process each
// chunk as it comes in.
//
// To complete the message processing after the full message body has
// been read, you can either also connect to [signal@ServerMessage::got-body],
// or else you can register a non-early handler for @path as well. As
// long as you have not set the status-code by the time
// [signal@ServerMessage::got-body] is emitted, the non-early handler will be
// run as well.
func (x *Server) AddEarlyHandler(PathVar *string, CallbackVar *ServerCallback, UserDataVar uintptr, DestroyVar *glib.DestroyNotify) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 string, arg3 *glib.HashTable, arg4 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2, arg3, arg4)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CallbackVarPtr, CallbackVarRef, CallbackVar)
		}
	}

	var DestroyVarRef uintptr
	if DestroyVar != nil {
		DestroyVarPtr := uintptr(unsafe.Pointer(DestroyVar))
		if cbRefPtr, ok := glib.GetCallback(DestroyVarPtr); ok {
			DestroyVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *DestroyVar
				cbFn(arg0)
			}
			DestroyVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(DestroyVarPtr, DestroyVarRef, DestroyVar)
		}
	}

	PathVarPtr, PathVarBytes := core.NullableStringToPtr(PathVar)

	xServerAddEarlyHandler(x.GoPointer(), PathVarPtr, CallbackVarRef, UserDataVar, DestroyVarRef)

	runtime.KeepAlive(PathVarBytes)

}

var xServerAddHandler func(uintptr, uintptr, uintptr, uintptr, uintptr)

// Adds a handler to @server for requests prefixed by @path.
//
// If @path is %NULL or "/", then this will be the default handler for all
// requests that don't have a more specific handler. (Note though that if you
// want to handle requests to the special "*" URI, you must explicitly register
// a handler for "*"; the default handler will not be used for that case.)
//
// For requests under @path (that have not already been assigned a
// status code by a [class@AuthDomain], an early server handler, or a
// signal handler), @callback will be invoked after receiving the
// request body; the [class@ServerMessage]'s method, request-headers,
// and request-body properties will be set.
//
// After determining what to do with the request, the callback must at a minimum
// call [method@ServerMessage.set_status] on the message to set the response
// status code. Additionally, it may set response headers and/or fill in the
// response body.
//
// If the callback cannot fully fill in the response before returning
// (eg, if it needs to wait for information from a database, or
// another network server), it should call [method@ServerMessage.pause]
// to tell @server to not send the response right away. When the
// response is ready, call [method@ServerMessage.unpause] to cause it
// to be sent.
//
// To send the response body a bit at a time using "chunked" encoding, first
// call [method@MessageHeaders.set_encoding] to set %SOUP_ENCODING_CHUNKED on
// the response-headers. Then call [method@MessageBody.append] (or
// [method@MessageBody.append_bytes])) to append each chunk as it becomes ready,
// and [method@ServerMessage.unpause] to make sure it's running. (The server
// will automatically pause the message if it is using chunked encoding but no
// more chunks are available.) When you are done, call
// [method@MessageBody.complete] to indicate that no more chunks are coming.
func (x *Server) AddHandler(PathVar *string, CallbackVar *ServerCallback, UserDataVar uintptr, DestroyVar *glib.DestroyNotify) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 string, arg3 *glib.HashTable, arg4 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2, arg3, arg4)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CallbackVarPtr, CallbackVarRef, CallbackVar)
		}
	}

	var DestroyVarRef uintptr
	if DestroyVar != nil {
		DestroyVarPtr := uintptr(unsafe.Pointer(DestroyVar))
		if cbRefPtr, ok := glib.GetCallback(DestroyVarPtr); ok {
			DestroyVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *DestroyVar
				cbFn(arg0)
			}
			DestroyVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(DestroyVarPtr, DestroyVarRef, DestroyVar)
		}
	}

	PathVarPtr, PathVarBytes := core.NullableStringToPtr(PathVar)

	xServerAddHandler(x.GoPointer(), PathVarPtr, CallbackVarRef, UserDataVar, DestroyVarRef)

	runtime.KeepAlive(PathVarBytes)

}

var xServerAddWebsocketExtension func(uintptr, types.GType)

// Add support for a WebSocket extension of the given @extension_type.
//
// When a WebSocket client requests an extension of @extension_type,
// a new [class@WebsocketExtension] of type @extension_type will be created
// to handle the request.
//
// Note that [class@WebsocketExtensionDeflate] is supported by default, use
// [method@Server.remove_websocket_extension] if you want to disable it.
func (x *Server) AddWebsocketExtension(ExtensionTypeVar types.GType) {

	xServerAddWebsocketExtension(x.GoPointer(), ExtensionTypeVar)

}

var xServerAddWebsocketHandler func(uintptr, uintptr, uintptr, []string, uintptr, uintptr, uintptr)

// Adds a WebSocket handler to @server for requests prefixed by @path.
//
// If @path is %NULL or "/", then this will be the default handler for all
// requests that don't have a more specific handler.
//
// When a path has a WebSocket handler registered, @server will check
// incoming requests for WebSocket handshakes after all other handlers
// have run (unless some earlier handler has already set a status code
// on the message), and update the request's status, response headers,
// and response body accordingly.
//
// If @origin is non-%NULL, then only requests containing a matching
// "Origin" header will be accepted. If @protocols is non-%NULL, then
// only requests containing a compatible "Sec-WebSocket-Protocols"
// header will be accepted. More complicated requirements can be
// handled by adding a normal handler to @path, and having it perform
// whatever checks are needed and
// setting a failure status code if the handshake should be rejected.
func (x *Server) AddWebsocketHandler(PathVar *string, OriginVar *string, ProtocolsVar []string, CallbackVar *ServerWebsocketCallback, UserDataVar uintptr, DestroyVar *glib.DestroyNotify) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 string, arg3 uintptr, arg4 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2, arg3, arg4)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CallbackVarPtr, CallbackVarRef, CallbackVar)
		}
	}

	var DestroyVarRef uintptr
	if DestroyVar != nil {
		DestroyVarPtr := uintptr(unsafe.Pointer(DestroyVar))
		if cbRefPtr, ok := glib.GetCallback(DestroyVarPtr); ok {
			DestroyVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *DestroyVar
				cbFn(arg0)
			}
			DestroyVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(DestroyVarPtr, DestroyVarRef, DestroyVar)
		}
	}

	PathVarPtr, PathVarBytes := core.NullableStringToPtr(PathVar)

	OriginVarPtr, OriginVarBytes := core.NullableStringToPtr(OriginVar)

	xServerAddWebsocketHandler(x.GoPointer(), PathVarPtr, OriginVarPtr, ProtocolsVar, CallbackVarRef, UserDataVar, DestroyVarRef)

	runtime.KeepAlive(PathVarBytes)

	runtime.KeepAlive(OriginVarBytes)

}

var xServerDisconnect func(uintptr)

// Closes and frees @server's listening sockets.
//
// Note that if there are currently requests in progress on @server, that they
// will continue to be processed if @server's [struct@GLib.MainContext] is still
// running.
//
// You can call [method@Server.listen], etc, after calling this function
// if you want to start listening again.
func (x *Server) Disconnect() {

	xServerDisconnect(x.GoPointer())

}

var xServerGetListeners func(uintptr) *glib.SList

// Gets @server's list of listening sockets.
//
// You should treat these sockets as read-only; writing to or
// modifiying any of these sockets may cause @server to malfunction.
func (x *Server) GetListeners() *glib.SList {

	cret := xServerGetListeners(x.GoPointer())

	return cret
}

var xServerGetTlsAuthMode func(uintptr) gio.TlsAuthenticationMode

// Gets the @server SSL/TLS client authentication mode.
func (x *Server) GetTlsAuthMode() gio.TlsAuthenticationMode {

	cret := xServerGetTlsAuthMode(x.GoPointer())

	return cret
}

var xServerGetTlsCertificate func(uintptr) uintptr

// Gets the @server SSL/TLS certificate.
func (x *Server) GetTlsCertificate() *gio.TlsCertificate {
	var cls *gio.TlsCertificate

	cret := xServerGetTlsCertificate(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.TlsCertificate{}
	cls.Ptr = cret
	return cls
}

var xServerGetTlsDatabase func(uintptr) uintptr

// Gets the @server SSL/TLS database.
func (x *Server) GetTlsDatabase() *gio.TlsDatabase {
	var cls *gio.TlsDatabase

	cret := xServerGetTlsDatabase(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.TlsDatabase{}
	cls.Ptr = cret
	return cls
}

var xServerGetUris func(uintptr) *glib.SList

// Gets a list of URIs corresponding to the interfaces @server is
// listening on.
//
// These will contain IP addresses, not hostnames, and will also indicate
// whether the given listener is http or https.
//
// Note that if you used [method@Server.listen_all] the returned URIs will use
// the addresses `0.0.0.0` and `::`, rather than actually returning separate
// URIs for each interface on the system.
func (x *Server) GetUris() *glib.SList {

	cret := xServerGetUris(x.GoPointer())

	return cret
}

var xServerIsHttps func(uintptr) bool

// Checks whether @server is capable of https.
//
// In order for a server to run https, you must call
// [method@Server.set_tls_certificate], or set the
// [property@Server:tls-certificate] property, to provide it with a
// certificate to use.
//
// If you are using the deprecated single-listener APIs, then a return value of
// %TRUE indicates that the #SoupServer serves https exclusively. If you are
// using [method@Server.listen], etc, then a %TRUE return value merely indicates
// that the server is *able* to do https, regardless of whether it actually
// currently is or not. Use [method@Server.get_uris] to see if it currently has
// any https listeners.
func (x *Server) IsHttps() bool {

	cret := xServerIsHttps(x.GoPointer())

	return cret
}

var xServerListen func(uintptr, uintptr, ServerListenOptions, **glib.Error) bool

// Attempts to set up @server to listen for connections on @address.
//
// If @options includes %SOUP_SERVER_LISTEN_HTTPS, and @server has
// been configured for TLS, then @server will listen for https
// connections on this port. Otherwise it will listen for plain http.
//
// You may call this method (along with the other "listen" methods)
// any number of times on a server, if you want to listen on multiple
// ports, or set up both http and https service.
//
// After calling this method, @server will begin accepting and processing
// connections as soon as the appropriate [struct@GLib.MainContext] is run.
//
// Note that this API does not make use of dual IPv4/IPv6 sockets; if
// @address is an IPv6 address, it will only accept IPv6 connections.
// You must configure IPv4 listening separately.
func (x *Server) Listen(AddressVar *gio.SocketAddress, OptionsVar ServerListenOptions) (bool, error) {
	var cerr *glib.Error

	cret := xServerListen(x.GoPointer(), AddressVar.GoPointer(), OptionsVar, &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xServerListenAll func(uintptr, uint, ServerListenOptions, **glib.Error) bool

// Attempts to set up @server to listen for connections on all interfaces
// on the system.
//
// That is, it listens on the addresses `0.0.0.0` and/or `::`, depending on
// whether @options includes %SOUP_SERVER_LISTEN_IPV4_ONLY,
// %SOUP_SERVER_LISTEN_IPV6_ONLY, or neither.) If @port is specified, @server
// will listen on that port. If it is 0, @server will find an unused port to
// listen on. (In that case, you can use [method@Server.get_uris] to find out
// what port it ended up choosing.
//
// See [method@Server.listen] for more details.
func (x *Server) ListenAll(PortVar uint, OptionsVar ServerListenOptions) (bool, error) {
	var cerr *glib.Error

	cret := xServerListenAll(x.GoPointer(), PortVar, OptionsVar, &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xServerListenLocal func(uintptr, uint, ServerListenOptions, **glib.Error) bool

// Attempts to set up @server to listen for connections on "localhost".
//
// That is, `127.0.0.1` and/or `::1`, depending on whether @options includes
// %SOUP_SERVER_LISTEN_IPV4_ONLY, %SOUP_SERVER_LISTEN_IPV6_ONLY, or neither). If
// @port is specified, @server will listen on that port. If it is 0, @server
// will find an unused port to listen on. (In that case, you can use
// [method@Server.get_uris] to find out what port it ended up choosing.
//
// See [method@Server.listen] for more details.
func (x *Server) ListenLocal(PortVar uint, OptionsVar ServerListenOptions) (bool, error) {
	var cerr *glib.Error

	cret := xServerListenLocal(x.GoPointer(), PortVar, OptionsVar, &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xServerListenSocket func(uintptr, uintptr, ServerListenOptions, **glib.Error) bool

// Attempts to set up @server to listen for connections on @socket.
//
// See [method@Server.listen] for more details.
func (x *Server) ListenSocket(SocketVar *gio.Socket, OptionsVar ServerListenOptions) (bool, error) {
	var cerr *glib.Error

	cret := xServerListenSocket(x.GoPointer(), SocketVar.GoPointer(), OptionsVar, &cerr)

	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xServerPauseMessage func(uintptr, uintptr)

// Pauses I/O on @msg.
//
// This can be used when you need to return from the server handler without
// having the full response ready yet. Use [method@Server.unpause_message] to
// resume I/O.
//
// This must only be called on a [class@ServerMessage] which was created by the
// #SoupServer and are currently doing I/O, such as those passed into a
// [callback@ServerCallback] or emitted in a [signal@Server::request-read]
// signal.
func (x *Server) PauseMessage(MsgVar *ServerMessage) {

	xServerPauseMessage(x.GoPointer(), MsgVar.GoPointer())

}

var xServerRemoveAuthDomain func(uintptr, uintptr)

// Removes @auth_domain from @server.
func (x *Server) RemoveAuthDomain(AuthDomainVar *AuthDomain) {

	xServerRemoveAuthDomain(x.GoPointer(), AuthDomainVar.GoPointer())

}

var xServerRemoveHandler func(uintptr, string)

// Removes all handlers (early and normal) registered at @path.
func (x *Server) RemoveHandler(PathVar string) {

	xServerRemoveHandler(x.GoPointer(), PathVar)

}

var xServerRemoveWebsocketExtension func(uintptr, types.GType)

// Removes support for WebSocket extension of type @extension_type (or any subclass of
// @extension_type) from @server.
func (x *Server) RemoveWebsocketExtension(ExtensionTypeVar types.GType) {

	xServerRemoveWebsocketExtension(x.GoPointer(), ExtensionTypeVar)

}

var xServerSetTlsAuthMode func(uintptr, gio.TlsAuthenticationMode)

// Sets @server's #GTlsAuthenticationMode to use for SSL/TLS client authentication.
func (x *Server) SetTlsAuthMode(ModeVar gio.TlsAuthenticationMode) {

	xServerSetTlsAuthMode(x.GoPointer(), ModeVar)

}

var xServerSetTlsCertificate func(uintptr, uintptr)

// Sets @server up to do https, using the given SSL/TLS @certificate.
func (x *Server) SetTlsCertificate(CertificateVar *gio.TlsCertificate) {

	xServerSetTlsCertificate(x.GoPointer(), CertificateVar.GoPointer())

}

var xServerSetTlsDatabase func(uintptr, uintptr)

// Sets @server's #GTlsDatabase to use for validating SSL/TLS client certificates.
func (x *Server) SetTlsDatabase(TlsDatabaseVar *gio.TlsDatabase) {

	xServerSetTlsDatabase(x.GoPointer(), TlsDatabaseVar.GoPointer())

}

var xServerUnpauseMessage func(uintptr, uintptr)

// Resumes I/O on @msg.
//
// Use this to resume after calling [method@Server.pause_message], or after
// adding a new chunk to a chunked response.
//
// I/O won't actually resume until you return to the main loop.
//
// This must only be called on a [class@ServerMessage] which was created by the
// #SoupServer and are currently doing I/O, such as those passed into a
// [callback@ServerCallback] or emitted in a [signal@Server::request-read]
// signal.
func (x *Server) UnpauseMessage(MsgVar *ServerMessage) {

	xServerUnpauseMessage(x.GoPointer(), MsgVar.GoPointer())

}

func (c *Server) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *Server) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyRawPaths sets the "raw-paths" property.
// If %TRUE, percent-encoding in the Request-URI path will not be
// automatically decoded.
func (x *Server) SetPropertyRawPaths(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("raw-paths", &v)
}

// GetPropertyRawPaths gets the "raw-paths" property.
// If %TRUE, percent-encoding in the Request-URI path will not be
// automatically decoded.
func (x *Server) GetPropertyRawPaths() bool {
	var v gobject.Value
	x.GetProperty("raw-paths", &v)
	return v.GetBoolean()
}

// SetPropertyServerHeader sets the "server-header" property.
// Server header.
//
// If non-%NULL, the value to use for the "Server" header on
// [class@ServerMessage]s processed by this server.
//
// The Server header is the server equivalent of the
// User-Agent header, and provides information about the
// server and its components. It contains a list of one or
// more product tokens, separated by whitespace, with the most
// significant product token coming first. The tokens must be
// brief, ASCII, and mostly alphanumeric (although "-", "_",
// and "." are also allowed), and may optionally include a "/"
// followed by a version string. You may also put comments,
// enclosed in parentheses, between or after the tokens.
//
// Some HTTP server implementations intentionally do not use
// version numbers in their Server header, so that
// installations running older versions of the server don't
// end up advertising their vulnerability to specific security
// holes.
//
// As with [property@Session:user_agent], if you set a
// [property@Server:server-header] property that has trailing
// whitespace, #SoupServer will append its own product token (eg,
// `libsoup/2.3.2`) to the end of the header for you.
func (x *Server) SetPropertyServerHeader(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("server-header", &v)
}

// GetPropertyServerHeader gets the "server-header" property.
// Server header.
//
// If non-%NULL, the value to use for the "Server" header on
// [class@ServerMessage]s processed by this server.
//
// The Server header is the server equivalent of the
// User-Agent header, and provides information about the
// server and its components. It contains a list of one or
// more product tokens, separated by whitespace, with the most
// significant product token coming first. The tokens must be
// brief, ASCII, and mostly alphanumeric (although "-", "_",
// and "." are also allowed), and may optionally include a "/"
// followed by a version string. You may also put comments,
// enclosed in parentheses, between or after the tokens.
//
// Some HTTP server implementations intentionally do not use
// version numbers in their Server header, so that
// installations running older versions of the server don't
// end up advertising their vulnerability to specific security
// holes.
//
// As with [property@Session:user_agent], if you set a
// [property@Server:server-header] property that has trailing
// whitespace, #SoupServer will append its own product token (eg,
// `libsoup/2.3.2`) to the end of the header for you.
func (x *Server) GetPropertyServerHeader() string {
	var v gobject.Value
	x.GetProperty("server-header", &v)
	return v.GetString()
}

// Emitted when processing has failed for a message.
//
// This could mean either that it could not be read (if
// [signal@Server::request-read] has not been emitted for it yet), or that
// the response could not be written back (if [signal@Server::request-read]
// has been emitted but [signal@Server::request-finished] has not been).
//
// @message is in an undefined state when this signal is
// emitted; the signal exists primarily to allow the server to
// free any state that it may have allocated in
// [signal@Server::request-started].
func (x *Server) ConnectRequestAborted(cb *func(Server, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "request-aborted", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, MessageVarp uintptr) {
		fa := Server{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, MessageVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "request-aborted", cbRefPtr)
}

// Emitted when the server has finished writing a response to
// a request.
func (x *Server) ConnectRequestFinished(cb *func(Server, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "request-finished", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, MessageVarp uintptr) {
		fa := Server{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, MessageVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "request-finished", cbRefPtr)
}

// Emitted when the server has successfully read a request.
//
// @message will have all of its request-side information
// filled in, and if the message was authenticated, @client
// will have information about that. This signal is emitted
// before any (non-early) handlers are called for the message,
// and if it sets the message's #status_code, then normal
// handler processing will be skipped.
func (x *Server) ConnectRequestRead(cb *func(Server, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "request-read", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, MessageVarp uintptr) {
		fa := Server{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, MessageVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "request-read", cbRefPtr)
}

// Emitted when the server has started reading a new request.
//
// @message will be completely blank; not even the
// Request-Line will have been read yet. About the only thing
// you can usefully do with it is connect to its signals.
//
// If the request is read successfully, this will eventually
// be followed by a [signal@Server::request_read signal]. If a
// response is then sent, the request processing will end with
// a [signal@Server::request-finished] signal. If a network error
// occurs, the processing will instead end with
// [signal@Server::request-aborted].
func (x *Server) ConnectRequestStarted(cb *func(Server, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "request-started", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, MessageVarp uintptr) {
		fa := Server{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, MessageVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "request-started", cbRefPtr)
}

func init() {
	core.SetPackageName("SOUP", "libsoup-3.0")
	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("SOUP") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xServerListenOptionsGLibType, libs, "soup_server_listen_options_get_type")

	core.PuregoSafeRegister(&xServerGLibType, libs, "soup_server_get_type")

	core.PuregoSafeRegister(&xNewServer, libs, "soup_server_new")

	core.PuregoSafeRegister(&xServerAcceptIostream, libs, "soup_server_accept_iostream")
	core.PuregoSafeRegister(&xServerAddAuthDomain, libs, "soup_server_add_auth_domain")
	core.PuregoSafeRegister(&xServerAddEarlyHandler, libs, "soup_server_add_early_handler")
	core.PuregoSafeRegister(&xServerAddHandler, libs, "soup_server_add_handler")
	core.PuregoSafeRegister(&xServerAddWebsocketExtension, libs, "soup_server_add_websocket_extension")
	core.PuregoSafeRegister(&xServerAddWebsocketHandler, libs, "soup_server_add_websocket_handler")
	core.PuregoSafeRegister(&xServerDisconnect, libs, "soup_server_disconnect")
	core.PuregoSafeRegister(&xServerGetListeners, libs, "soup_server_get_listeners")
	core.PuregoSafeRegister(&xServerGetTlsAuthMode, libs, "soup_server_get_tls_auth_mode")
	core.PuregoSafeRegister(&xServerGetTlsCertificate, libs, "soup_server_get_tls_certificate")
	core.PuregoSafeRegister(&xServerGetTlsDatabase, libs, "soup_server_get_tls_database")
	core.PuregoSafeRegister(&xServerGetUris, libs, "soup_server_get_uris")
	core.PuregoSafeRegister(&xServerIsHttps, libs, "soup_server_is_https")
	core.PuregoSafeRegister(&xServerListen, libs, "soup_server_listen")
	core.PuregoSafeRegister(&xServerListenAll, libs, "soup_server_listen_all")
	core.PuregoSafeRegister(&xServerListenLocal, libs, "soup_server_listen_local")
	core.PuregoSafeRegister(&xServerListenSocket, libs, "soup_server_listen_socket")
	core.PuregoSafeRegister(&xServerPauseMessage, libs, "soup_server_pause_message")
	core.PuregoSafeRegister(&xServerRemoveAuthDomain, libs, "soup_server_remove_auth_domain")
	core.PuregoSafeRegister(&xServerRemoveHandler, libs, "soup_server_remove_handler")
	core.PuregoSafeRegister(&xServerRemoveWebsocketExtension, libs, "soup_server_remove_websocket_extension")
	core.PuregoSafeRegister(&xServerSetTlsAuthMode, libs, "soup_server_set_tls_auth_mode")
	core.PuregoSafeRegister(&xServerSetTlsCertificate, libs, "soup_server_set_tls_certificate")
	core.PuregoSafeRegister(&xServerSetTlsDatabase, libs, "soup_server_set_tls_database")
	core.PuregoSafeRegister(&xServerUnpauseMessage, libs, "soup_server_unpause_message")

}
