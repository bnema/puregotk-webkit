// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package soup

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

const (
	// The set of #GUriFlags libsoup expects all #GUri to use.
	HTTP_URI_FLAGS int = 482
)

// Enum values passed to [func@uri_copy] to indicate the components of
// the URI that should be updated with the given values.
type URIComponent int

var xURIComponentGLibType func() types.GType

func URIComponentGLibType() types.GType {
	return xURIComponentGLibType()
}

const (

	// no component
	UriNoneValue URIComponent = 0
	// the URI scheme component
	UriSchemeValue URIComponent = 1
	// the URI user component
	UriUserValue URIComponent = 2
	// the URI password component
	UriPasswordValue URIComponent = 3
	// the URI authentication parameters component
	UriAuthParamsValue URIComponent = 4
	// the URI host component
	UriHostValue URIComponent = 5
	// the URI port component
	UriPortValue URIComponent = 6
	// the URI path component
	UriPathValue URIComponent = 7
	// the URI query component
	UriQueryValue URIComponent = 8
	// the URI fragment component
	UriFragmentValue URIComponent = 9
)

var xUriCopy func(*glib.Uri, URIComponent, ...interface{}) uintptr

// As of 3.4.0 this will detect the default ports of HTTP(s) and WS(S)
// URIs when copying and set it to the default port of the new scheme.
// So for example copying `http://localhost:80` while changing the scheme to https
// will result in `https://localhost:443`.
//
// Return a copy of @uri with the given components updated.
func UriCopy(UriVar *glib.Uri, FirstComponentVar URIComponent, varArgs ...interface{}) *glib.Uri {

	cret := xUriCopy(UriVar, FirstComponentVar, varArgs...)
	if cret == 0 {
		return nil
	}
	return (*glib.Uri)(unsafe.Pointer(cret))

}

var xUriDecodeDataUri func(string, string) uintptr

// Decodes the given data URI and returns its contents and @content_type.
func UriDecodeDataUri(UriVar string, ContentTypeVar string) *glib.Bytes {

	cret := xUriDecodeDataUri(UriVar, ContentTypeVar)
	if cret == 0 {
		return nil
	}
	return (*glib.Bytes)(unsafe.Pointer(cret))

}

var xUriEqual func(*glib.Uri, *glib.Uri) bool

// Tests whether or not @uri1 and @uri2 are equal in all parts.
func UriEqual(Uri1Var *glib.Uri, Uri2Var *glib.Uri) bool {

	cret := xUriEqual(Uri1Var, Uri2Var)
	return cret
}

func init() {
	core.SetPackageName("SOUP", "libsoup-3.0")
	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("SOUP") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xURIComponentGLibType, libs, "soup_uri_component_get_type")

	core.PuregoSafeRegister(&xUriCopy, libs, "soup_uri_copy")
	core.PuregoSafeRegister(&xUriDecodeDataUri, libs, "soup_uri_decode_data_uri")
	core.PuregoSafeRegister(&xUriEqual, libs, "soup_uri_equal")

}
