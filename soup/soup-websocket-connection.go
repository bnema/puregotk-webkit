// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package soup

import (
	"runtime"
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// The abstract base class for [class@WebsocketConnection].
type WebsocketConnectionClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass
}

func (x *WebsocketConnectionClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// The WebSocket Protocol
//
// Provides support for the [WebSocket](http://tools.ietf.org/html/rfc6455)
// protocol.
//
// To connect to a WebSocket server, create a [class@Session] and call
// [method@Session.websocket_connect_async]. To accept WebSocket
// connections, create a [class@Server] and add a handler to it with
// [method@Server.add_websocket_handler].
//
// (Lower-level support is available via
// [func@websocket_client_prepare_handshake] and
// [func@websocket_client_verify_handshake], for handling the client side of the
// WebSocket handshake, and [func@websocket_server_process_handshake] for
// handling the server side.)
//
// #SoupWebsocketConnection handles the details of WebSocket communication. You
// can use [method@WebsocketConnection.send_text] and
// [method@WebsocketConnection.send_binary] to send data, and the
// [signal@WebsocketConnection::message] signal to receive data.
// (#SoupWebsocketConnection currently only supports asynchronous I/O.)
type WebsocketConnection struct {
	gobject.Object
}

var xWebsocketConnectionGLibType func() types.GType

func WebsocketConnectionGLibType() types.GType {
	return xWebsocketConnectionGLibType()
}

func WebsocketConnectionNewFromInternalPtr(ptr uintptr) *WebsocketConnection {
	cls := &WebsocketConnection{}
	cls.Ptr = ptr
	return cls
}

var xNewWebsocketConnection func(uintptr, *glib.Uri, WebsocketConnectionType, uintptr, uintptr, *glib.List) uintptr

// Creates a #SoupWebsocketConnection on @stream with the given active @extensions.
//
// This should be called after completing the handshake to begin using the WebSocket
// protocol.
func NewWebsocketConnection(StreamVar *gio.IOStream, UriVar *glib.Uri, TypeVar WebsocketConnectionType, OriginVar *string, ProtocolVar *string, ExtensionsVar *glib.List) *WebsocketConnection {
	var cls *WebsocketConnection

	OriginVarPtr, OriginVarBytes := core.NullableStringToPtr(OriginVar)

	ProtocolVarPtr, ProtocolVarBytes := core.NullableStringToPtr(ProtocolVar)

	cret := xNewWebsocketConnection(StreamVar.GoPointer(), UriVar, TypeVar, OriginVarPtr, ProtocolVarPtr, ExtensionsVar)

	runtime.KeepAlive(OriginVarBytes)

	runtime.KeepAlive(ProtocolVarBytes)

	if cret == 0 {
		return nil
	}
	cls = &WebsocketConnection{}
	cls.Ptr = cret
	return cls
}

var xWebsocketConnectionClose func(uintptr, uint16, uintptr)

// Close the connection in an orderly fashion.
//
// Note that until the [signal@WebsocketConnection::closed] signal fires, the connection
// is not yet completely closed. The close message is not even sent until the
// main loop runs.
//
// The @code and @data are sent to the peer along with the close request.
// If @code is %SOUP_WEBSOCKET_CLOSE_NO_STATUS a close message with no body
// (without code and data) is sent.
// Note that the @data must be UTF-8 valid.
func (x *WebsocketConnection) Close(CodeVar uint16, DataVar *string) {

	DataVarPtr, DataVarBytes := core.NullableStringToPtr(DataVar)

	xWebsocketConnectionClose(x.GoPointer(), CodeVar, DataVarPtr)

	runtime.KeepAlive(DataVarBytes)

}

var xWebsocketConnectionGetCloseCode func(uintptr) uint16

// Get the close code received from the WebSocket peer.
//
// This only becomes valid once the WebSocket is in the
// %SOUP_WEBSOCKET_STATE_CLOSED state. The value will often be in the
// [enum@WebsocketCloseCode] enumeration, but may also be an application
// defined close code.
func (x *WebsocketConnection) GetCloseCode() uint16 {

	cret := xWebsocketConnectionGetCloseCode(x.GoPointer())

	return cret
}

var xWebsocketConnectionGetCloseData func(uintptr) string

// Get the close data received from the WebSocket peer.
//
// This only becomes valid once the WebSocket is in the
// %SOUP_WEBSOCKET_STATE_CLOSED state. The data may be freed once
// the main loop is run, so copy it if you need to keep it around.
func (x *WebsocketConnection) GetCloseData() string {

	cret := xWebsocketConnectionGetCloseData(x.GoPointer())

	return cret
}

var xWebsocketConnectionGetConnectionType func(uintptr) WebsocketConnectionType

// Get the connection type (client/server) of the connection.
func (x *WebsocketConnection) GetConnectionType() WebsocketConnectionType {

	cret := xWebsocketConnectionGetConnectionType(x.GoPointer())

	return cret
}

var xWebsocketConnectionGetExtensions func(uintptr) *glib.List

// Get the extensions chosen via negotiation with the peer.
func (x *WebsocketConnection) GetExtensions() *glib.List {

	cret := xWebsocketConnectionGetExtensions(x.GoPointer())

	return cret
}

var xWebsocketConnectionGetIoStream func(uintptr) uintptr

// Get the I/O stream the WebSocket is communicating over.
func (x *WebsocketConnection) GetIoStream() *gio.IOStream {
	var cls *gio.IOStream

	cret := xWebsocketConnectionGetIoStream(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.IOStream{}
	cls.Ptr = cret
	return cls
}

var xWebsocketConnectionGetKeepaliveInterval func(uintptr) uint

// Gets the keepalive interval in seconds or 0 if disabled.
func (x *WebsocketConnection) GetKeepaliveInterval() uint {

	cret := xWebsocketConnectionGetKeepaliveInterval(x.GoPointer())

	return cret
}

var xWebsocketConnectionGetKeepalivePongTimeout func(uintptr) uint

// Gets the keepalive pong timeout in seconds or 0 if disabled.
func (x *WebsocketConnection) GetKeepalivePongTimeout() uint {

	cret := xWebsocketConnectionGetKeepalivePongTimeout(x.GoPointer())

	return cret
}

var xWebsocketConnectionGetMaxIncomingPayloadSize func(uintptr) uint64

// Gets the maximum payload size allowed for incoming packets.
func (x *WebsocketConnection) GetMaxIncomingPayloadSize() uint64 {

	cret := xWebsocketConnectionGetMaxIncomingPayloadSize(x.GoPointer())

	return cret
}

var xWebsocketConnectionGetOrigin func(uintptr) string

// Get the origin of the WebSocket.
func (x *WebsocketConnection) GetOrigin() string {

	cret := xWebsocketConnectionGetOrigin(x.GoPointer())

	return cret
}

var xWebsocketConnectionGetProtocol func(uintptr) string

// Get the protocol chosen via negotiation with the peer.
func (x *WebsocketConnection) GetProtocol() string {

	cret := xWebsocketConnectionGetProtocol(x.GoPointer())

	return cret
}

var xWebsocketConnectionGetState func(uintptr) WebsocketState

// Get the current state of the WebSocket.
func (x *WebsocketConnection) GetState() WebsocketState {

	cret := xWebsocketConnectionGetState(x.GoPointer())

	return cret
}

var xWebsocketConnectionGetUri func(uintptr) *glib.Uri

// Get the URI of the WebSocket.
//
// For servers this represents the address of the WebSocket, and
// for clients it is the address connected to.
func (x *WebsocketConnection) GetUri() *glib.Uri {

	cret := xWebsocketConnectionGetUri(x.GoPointer())

	return cret
}

var xWebsocketConnectionSendBinary func(uintptr, []byte, uint)

// Send a binary message to the peer.
//
// If @length is 0, @data may be %NULL.
//
// The message is queued to be sent and will be sent when the main loop
// is run.
func (x *WebsocketConnection) SendBinary(DataVar []byte, LengthVar uint) {

	xWebsocketConnectionSendBinary(x.GoPointer(), DataVar, LengthVar)

}

var xWebsocketConnectionSendMessage func(uintptr, WebsocketDataType, *glib.Bytes)

// Send a message of the given @type to the peer. Note that this method,
// allows to send text messages containing %NULL characters.
//
// The message is queued to be sent and will be sent when the main loop
// is run.
func (x *WebsocketConnection) SendMessage(TypeVar WebsocketDataType, MessageVar *glib.Bytes) {

	xWebsocketConnectionSendMessage(x.GoPointer(), TypeVar, MessageVar)

}

var xWebsocketConnectionSendText func(uintptr, string)

// Send a %NULL-terminated text (UTF-8) message to the peer.
//
// If you need to send text messages containing %NULL characters use
// [method@WebsocketConnection.send_message] instead.
//
// The message is queued to be sent and will be sent when the main loop
// is run.
func (x *WebsocketConnection) SendText(TextVar string) {

	xWebsocketConnectionSendText(x.GoPointer(), TextVar)

}

var xWebsocketConnectionSetKeepaliveInterval func(uintptr, uint)

// Sets the interval in seconds on when to send a ping message which will serve
// as a keepalive message.
//
// If set to 0 the keepalive message is disabled.
func (x *WebsocketConnection) SetKeepaliveInterval(IntervalVar uint) {

	xWebsocketConnectionSetKeepaliveInterval(x.GoPointer(), IntervalVar)

}

var xWebsocketConnectionSetKeepalivePongTimeout func(uintptr, uint)

// Set the timeout in seconds for when the absence of a pong from a keepalive
// ping is assumed to be caused by a faulty connection.
//
// If set to 0 then the absence of pongs from keepalive pings is ignored.
func (x *WebsocketConnection) SetKeepalivePongTimeout(PongTimeoutVar uint) {

	xWebsocketConnectionSetKeepalivePongTimeout(x.GoPointer(), PongTimeoutVar)

}

var xWebsocketConnectionSetMaxIncomingPayloadSize func(uintptr, uint64)

// Sets the maximum payload size allowed for incoming packets.
//
// It does not limit the outgoing packet size.
func (x *WebsocketConnection) SetMaxIncomingPayloadSize(MaxIncomingPayloadSizeVar uint64) {

	xWebsocketConnectionSetMaxIncomingPayloadSize(x.GoPointer(), MaxIncomingPayloadSizeVar)

}

func (c *WebsocketConnection) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *WebsocketConnection) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyExtensions sets the "extensions" property.
// List of [class@WebsocketExtension] objects that are active in the connection.
func (x *WebsocketConnection) SetPropertyExtensions(value uintptr) {
	var v gobject.Value
	v.Init(gobject.TypePointerVal)
	v.SetPointer(value)
	x.SetProperty("extensions", &v)
}

// GetPropertyExtensions gets the "extensions" property.
// List of [class@WebsocketExtension] objects that are active in the connection.
func (x *WebsocketConnection) GetPropertyExtensions() uintptr {
	var v gobject.Value
	x.GetProperty("extensions", &v)
	return v.GetPointer()
}

// SetPropertyKeepaliveInterval sets the "keepalive-interval" property.
// Interval in seconds on when to send a ping message which will
// serve as a keepalive message.
//
// If set to 0 the keepalive message is disabled.
func (x *WebsocketConnection) SetPropertyKeepaliveInterval(value uint) {
	var v gobject.Value
	v.Init(gobject.TypeUintVal)
	v.SetUint(value)
	x.SetProperty("keepalive-interval", &v)
}

// GetPropertyKeepaliveInterval gets the "keepalive-interval" property.
// Interval in seconds on when to send a ping message which will
// serve as a keepalive message.
//
// If set to 0 the keepalive message is disabled.
func (x *WebsocketConnection) GetPropertyKeepaliveInterval() uint {
	var v gobject.Value
	x.GetProperty("keepalive-interval", &v)
	return v.GetUint()
}

// SetPropertyKeepalivePongTimeout sets the "keepalive-pong-timeout" property.
// Timeout in seconds for when the absence of a pong from a keepalive
// ping is assumed to be caused by a faulty connection. The WebSocket
// will be transitioned to a closed state when this happens.
//
// If set to 0 then the absence of pongs from keepalive pings is
// ignored.
func (x *WebsocketConnection) SetPropertyKeepalivePongTimeout(value uint) {
	var v gobject.Value
	v.Init(gobject.TypeUintVal)
	v.SetUint(value)
	x.SetProperty("keepalive-pong-timeout", &v)
}

// GetPropertyKeepalivePongTimeout gets the "keepalive-pong-timeout" property.
// Timeout in seconds for when the absence of a pong from a keepalive
// ping is assumed to be caused by a faulty connection. The WebSocket
// will be transitioned to a closed state when this happens.
//
// If set to 0 then the absence of pongs from keepalive pings is
// ignored.
func (x *WebsocketConnection) GetPropertyKeepalivePongTimeout() uint {
	var v gobject.Value
	x.GetProperty("keepalive-pong-timeout", &v)
	return v.GetUint()
}

// SetPropertyMaxIncomingPayloadSize sets the "max-incoming-payload-size" property.
// The maximum payload size for incoming packets.
//
// The protocol expects or 0 to not limit it.
func (x *WebsocketConnection) SetPropertyMaxIncomingPayloadSize(value uint64) {
	var v gobject.Value
	v.Init(gobject.TypeUint64Val)
	v.SetUint64(value)
	x.SetProperty("max-incoming-payload-size", &v)
}

// GetPropertyMaxIncomingPayloadSize gets the "max-incoming-payload-size" property.
// The maximum payload size for incoming packets.
//
// The protocol expects or 0 to not limit it.
func (x *WebsocketConnection) GetPropertyMaxIncomingPayloadSize() uint64 {
	var v gobject.Value
	x.GetProperty("max-incoming-payload-size", &v)
	return v.GetUint64()
}

// SetPropertyOrigin sets the "origin" property.
// The client's Origin.
func (x *WebsocketConnection) SetPropertyOrigin(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("origin", &v)
}

// GetPropertyOrigin gets the "origin" property.
// The client's Origin.
func (x *WebsocketConnection) GetPropertyOrigin() string {
	var v gobject.Value
	x.GetProperty("origin", &v)
	return v.GetString()
}

// SetPropertyProtocol sets the "protocol" property.
// The chosen protocol, or %NULL if a protocol was not agreed
// upon.
func (x *WebsocketConnection) SetPropertyProtocol(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("protocol", &v)
}

// GetPropertyProtocol gets the "protocol" property.
// The chosen protocol, or %NULL if a protocol was not agreed
// upon.
func (x *WebsocketConnection) GetPropertyProtocol() string {
	var v gobject.Value
	x.GetProperty("protocol", &v)
	return v.GetString()
}

// SetPropertyUri sets the "uri" property.
// The URI of the WebSocket.
//
// For servers this represents the address of the WebSocket,
// and for clients it is the address connected to.
func (x *WebsocketConnection) SetPropertyUri(value uintptr) {
	var v gobject.Value
	v.Init(gobject.TypePointerVal)
	v.SetPointer(value)
	x.SetProperty("uri", &v)
}

// GetPropertyUri gets the "uri" property.
// The URI of the WebSocket.
//
// For servers this represents the address of the WebSocket,
// and for clients it is the address connected to.
func (x *WebsocketConnection) GetPropertyUri() uintptr {
	var v gobject.Value
	x.GetProperty("uri", &v)
	return v.GetPointer()
}

// Emitted when the connection has completely closed.
//
// This happens either due to an orderly close from the peer, one
// initiated via [method@WebsocketConnection.close] or a fatal error
// condition that caused a close.
//
// This signal will be emitted once.
func (x *WebsocketConnection) ConnectClosed(cb *func(WebsocketConnection)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "closed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := WebsocketConnection{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "closed", cbRefPtr)
}

// This signal will be emitted during an orderly close.
func (x *WebsocketConnection) ConnectClosing(cb *func(WebsocketConnection)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "closing", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := WebsocketConnection{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "closing", cbRefPtr)
}

// Emitted when an error occurred on the WebSocket.
//
// This may be fired multiple times. Fatal errors will be followed by
// the [signal@WebsocketConnection::closed] signal being emitted.
func (x *WebsocketConnection) ConnectError(cb *func(WebsocketConnection, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "error", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ErrorVarp uintptr) {
		fa := WebsocketConnection{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ErrorVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "error", cbRefPtr)
}

// Emitted when we receive a message from the peer.
//
// As a convenience, the @message data will always be
// %NULL-terminated, but the NUL byte will not be included in
// the length count.
func (x *WebsocketConnection) ConnectMessage(cb *func(WebsocketConnection, int, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "message", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, TypeVarp int, MessageVarp uintptr) {
		fa := WebsocketConnection{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, TypeVarp, MessageVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "message", cbRefPtr)
}

// Emitted when we receive a Pong frame (solicited or
// unsolicited) from the peer.
//
// As a convenience, the @message data will always be
// %NULL-terminated, but the NUL byte will not be included in
// the length count.
func (x *WebsocketConnection) ConnectPong(cb *func(WebsocketConnection, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "pong", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, MessageVarp uintptr) {
		fa := WebsocketConnection{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, MessageVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "pong", cbRefPtr)
}

func init() {
	core.SetPackageName("SOUP", "libsoup-3.0")
	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("SOUP") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xWebsocketConnectionGLibType, libs, "soup_websocket_connection_get_type")

	core.PuregoSafeRegister(&xNewWebsocketConnection, libs, "soup_websocket_connection_new")

	core.PuregoSafeRegister(&xWebsocketConnectionClose, libs, "soup_websocket_connection_close")
	core.PuregoSafeRegister(&xWebsocketConnectionGetCloseCode, libs, "soup_websocket_connection_get_close_code")
	core.PuregoSafeRegister(&xWebsocketConnectionGetCloseData, libs, "soup_websocket_connection_get_close_data")
	core.PuregoSafeRegister(&xWebsocketConnectionGetConnectionType, libs, "soup_websocket_connection_get_connection_type")
	core.PuregoSafeRegister(&xWebsocketConnectionGetExtensions, libs, "soup_websocket_connection_get_extensions")
	core.PuregoSafeRegister(&xWebsocketConnectionGetIoStream, libs, "soup_websocket_connection_get_io_stream")
	core.PuregoSafeRegister(&xWebsocketConnectionGetKeepaliveInterval, libs, "soup_websocket_connection_get_keepalive_interval")
	core.PuregoSafeRegister(&xWebsocketConnectionGetKeepalivePongTimeout, libs, "soup_websocket_connection_get_keepalive_pong_timeout")
	core.PuregoSafeRegister(&xWebsocketConnectionGetMaxIncomingPayloadSize, libs, "soup_websocket_connection_get_max_incoming_payload_size")
	core.PuregoSafeRegister(&xWebsocketConnectionGetOrigin, libs, "soup_websocket_connection_get_origin")
	core.PuregoSafeRegister(&xWebsocketConnectionGetProtocol, libs, "soup_websocket_connection_get_protocol")
	core.PuregoSafeRegister(&xWebsocketConnectionGetState, libs, "soup_websocket_connection_get_state")
	core.PuregoSafeRegister(&xWebsocketConnectionGetUri, libs, "soup_websocket_connection_get_uri")
	core.PuregoSafeRegister(&xWebsocketConnectionSendBinary, libs, "soup_websocket_connection_send_binary")
	core.PuregoSafeRegister(&xWebsocketConnectionSendMessage, libs, "soup_websocket_connection_send_message")
	core.PuregoSafeRegister(&xWebsocketConnectionSendText, libs, "soup_websocket_connection_send_text")
	core.PuregoSafeRegister(&xWebsocketConnectionSetKeepaliveInterval, libs, "soup_websocket_connection_set_keepalive_interval")
	core.PuregoSafeRegister(&xWebsocketConnectionSetKeepalivePongTimeout, libs, "soup_websocket_connection_set_keepalive_pong_timeout")
	core.PuregoSafeRegister(&xWebsocketConnectionSetMaxIncomingPayloadSize, libs, "soup_websocket_connection_set_max_incoming_payload_size")

}
