// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package soup

import (
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
)

var xHeaderContains func(string, string) bool

// Parses @header to see if it contains the token @token (matched
// case-insensitively).
//
// Note that this can't be used with lists that have qvalues.
func HeaderContains(HeaderVar string, TokenVar string) bool {

	cret := xHeaderContains(HeaderVar, TokenVar)
	return cret
}

var xHeaderFreeList func(*glib.SList)

// Frees @list.
func HeaderFreeList(ListVar *glib.SList) {

	xHeaderFreeList(ListVar)

}

var xHeaderFreeParamList func(*glib.HashTable)

// Frees @param_list.
func HeaderFreeParamList(ParamListVar *glib.HashTable) {

	xHeaderFreeParamList(ParamListVar)

}

var xHeaderGStringAppendParam func(*glib.String, string, uintptr)

// Appends something like `name=value` to @string, taking care to quote @value
// if needed, and if so, to escape any quotes or backslashes in @value.
//
// Alternatively, if @value is a non-ASCII UTF-8 string, it will be
// appended using RFC5987 syntax. Although in theory this is supposed
// to work anywhere in HTTP that uses this style of parameter, in
// reality, it can only be used portably with the Content-Disposition
// "filename" parameter.
//
// If @value is %NULL, this will just append @name to @string.
func HeaderGStringAppendParam(StringVar *glib.String, NameVar string, ValueVar *string) {

	ValueVarPtr := core.GStrdupNullable(ValueVar)
	defer core.GFreeNullable(ValueVarPtr)

	xHeaderGStringAppendParam(StringVar, NameVar, ValueVarPtr)

}

var xHeaderGStringAppendParamQuoted func(*glib.String, string, string)

// Appends something like `name="value"` to
// @string, taking care to escape any quotes or backslashes in @value.
//
// If @value is (non-ASCII) UTF-8, this will instead use RFC 5987
// encoding, just like [func@header_g_string_append_param].
func HeaderGStringAppendParamQuoted(StringVar *glib.String, NameVar string, ValueVar string) {

	xHeaderGStringAppendParamQuoted(StringVar, NameVar, ValueVar)

}

var xHeaderParseList func(string) *glib.SList

// Parses a header whose content is described by RFC2616 as `#something`.
//
// "something" does not itself contain commas, except as part of quoted-strings.
func HeaderParseList(HeaderVar string) *glib.SList {

	cret := xHeaderParseList(HeaderVar)
	return cret
}

var xHeaderParseParamList func(string) *glib.HashTable

// Parses a header which is a comma-delimited list of something like:
// `token [ "=" ( token | quoted-string ) ]`.
//
// Tokens that don't have an associated value will still be added to
// the resulting hash table, but with a %NULL value.
//
// This also handles RFC5987 encoding (which in HTTP is mostly used
// for giving UTF8-encoded filenames in the Content-Disposition
// header).
func HeaderParseParamList(HeaderVar string) *glib.HashTable {

	cret := xHeaderParseParamList(HeaderVar)
	return cret
}

var xHeaderParseParamListStrict func(string) *glib.HashTable

// A strict version of [func@header_parse_param_list]
// that bails out if there are duplicate parameters.
//
// Note that this function will treat RFC5987-encoded
// parameters as duplicated if an ASCII version is also
// present. For header fields that might contain
// RFC5987-encoded parameters, use
// [func@header_parse_param_list] instead.
func HeaderParseParamListStrict(HeaderVar string) *glib.HashTable {

	cret := xHeaderParseParamListStrict(HeaderVar)
	return cret
}

var xHeaderParseQualityList func(string, **glib.SList) *glib.SList

// Parses a header whose content is a list of items with optional
// "qvalue"s (eg, Accept, Accept-Charset, Accept-Encoding,
// Accept-Language, TE).
//
// If @unacceptable is not %NULL, then on return, it will contain the
// items with qvalue 0. Either way, those items will be removed from
// the main list.
func HeaderParseQualityList(HeaderVar string, UnacceptableVar **glib.SList) *glib.SList {

	cret := xHeaderParseQualityList(HeaderVar, UnacceptableVar)
	return cret
}

var xHeaderParseSemiParamList func(string) *glib.HashTable

// Parses a header which is a semicolon-delimited list of something
// like: `token [ "=" ( token | quoted-string ) ]`.
//
// Tokens that don't have an associated value will still be added to
// the resulting hash table, but with a %NULL value.
//
// This also handles RFC5987 encoding (which in HTTP is mostly used
// for giving UTF8-encoded filenames in the Content-Disposition
// header).
func HeaderParseSemiParamList(HeaderVar string) *glib.HashTable {

	cret := xHeaderParseSemiParamList(HeaderVar)
	return cret
}

var xHeaderParseSemiParamListStrict func(string) *glib.HashTable

// A strict version of [func@header_parse_semi_param_list]
// that bails out if there are duplicate parameters.
//
// Note that this function will treat RFC5987-encoded
// parameters as duplicated if an ASCII version is also
// present. For header fields that might contain
// RFC5987-encoded parameters, use
// [func@header_parse_semi_param_list] instead.
func HeaderParseSemiParamListStrict(HeaderVar string) *glib.HashTable {

	cret := xHeaderParseSemiParamListStrict(HeaderVar)
	return cret
}

var xHeadersParse func(string, int, *MessageHeaders) bool

// Parses the headers of an HTTP request or response in @str and
// stores the results in @dest.
//
// Beware that @dest may be modified even on failure.
//
// This is a low-level method; normally you would use
// [func@headers_parse_request] or [func@headers_parse_response].
func HeadersParse(StrVar string, LenVar int, DestVar *MessageHeaders) bool {

	cret := xHeadersParse(StrVar, LenVar, DestVar)
	return cret
}

var xHeadersParseRequest func(string, int, *MessageHeaders, *string, *string, *HTTPVersion) uint

// Parses the headers of an HTTP request in @str and stores the
// results in @req_method, @req_path, @ver, and @req_headers.
//
// Beware that @req_headers may be modified even on failure.
func HeadersParseRequest(StrVar string, LenVar int, ReqHeadersVar *MessageHeaders, ReqMethodVar *string, ReqPathVar *string, VerVar *HTTPVersion) uint {

	cret := xHeadersParseRequest(StrVar, LenVar, ReqHeadersVar, ReqMethodVar, ReqPathVar, VerVar)
	return cret
}

var xHeadersParseResponse func(string, int, *MessageHeaders, *HTTPVersion, *uint, *string) bool

// Parses the headers of an HTTP response in @str and stores the
// results in @ver, @status_code, @reason_phrase, and @headers.
//
// Beware that @headers may be modified even on failure.
func HeadersParseResponse(StrVar string, LenVar int, HeadersVar *MessageHeaders, VerVar *HTTPVersion, StatusCodeVar *uint, ReasonPhraseVar *string) bool {

	cret := xHeadersParseResponse(StrVar, LenVar, HeadersVar, VerVar, StatusCodeVar, ReasonPhraseVar)
	return cret
}

var xHeadersParseStatusLine func(string, *HTTPVersion, *uint, *string) bool

// Parses the HTTP Status-Line string in @status_line into @ver,
// @status_code, and @reason_phrase.
//
// @status_line must be terminated by either "\0" or "\r\n".
func HeadersParseStatusLine(StatusLineVar string, VerVar *HTTPVersion, StatusCodeVar *uint, ReasonPhraseVar *string) bool {

	cret := xHeadersParseStatusLine(StatusLineVar, VerVar, StatusCodeVar, ReasonPhraseVar)
	return cret
}

func init() {
	core.SetPackageName("SOUP", "libsoup-3.0")
	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("SOUP") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xHeaderContains, libs, "soup_header_contains")
	core.PuregoSafeRegister(&xHeaderFreeList, libs, "soup_header_free_list")
	core.PuregoSafeRegister(&xHeaderFreeParamList, libs, "soup_header_free_param_list")
	core.PuregoSafeRegister(&xHeaderGStringAppendParam, libs, "soup_header_g_string_append_param")
	core.PuregoSafeRegister(&xHeaderGStringAppendParamQuoted, libs, "soup_header_g_string_append_param_quoted")
	core.PuregoSafeRegister(&xHeaderParseList, libs, "soup_header_parse_list")
	core.PuregoSafeRegister(&xHeaderParseParamList, libs, "soup_header_parse_param_list")
	core.PuregoSafeRegister(&xHeaderParseParamListStrict, libs, "soup_header_parse_param_list_strict")
	core.PuregoSafeRegister(&xHeaderParseQualityList, libs, "soup_header_parse_quality_list")
	core.PuregoSafeRegister(&xHeaderParseSemiParamList, libs, "soup_header_parse_semi_param_list")
	core.PuregoSafeRegister(&xHeaderParseSemiParamListStrict, libs, "soup_header_parse_semi_param_list_strict")
	core.PuregoSafeRegister(&xHeadersParse, libs, "soup_headers_parse")
	core.PuregoSafeRegister(&xHeadersParseRequest, libs, "soup_headers_parse_request")
	core.PuregoSafeRegister(&xHeadersParseResponse, libs, "soup_headers_parse_response")
	core.PuregoSafeRegister(&xHeadersParseStatusLine, libs, "soup_headers_parse_status_line")

}
