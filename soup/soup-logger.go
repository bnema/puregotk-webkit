// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package soup

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// The prototype for a logging filter.
//
// The filter callback will be invoked for each request or response, and should
// analyze it and return a [enum@LoggerLogLevel] value indicating how much of
// the message to log.
type LoggerFilter func(uintptr, uintptr, uintptr) LoggerLogLevel

// The prototype for a custom printing callback.
//
// @level indicates what kind of information is being printed. Eg, it
// will be %SOUP_LOGGER_LOG_HEADERS if @data is header data.
//
// @direction is either '&lt;', '&gt;', or ' ', and @data is the single line
// to print; the printer is expected to add a terminating newline.
//
// To get the effect of the default printer, you would do:
//
// ```c
// printf ("%c %s\n", direction, data);
// ```
type LoggerPrinter func(uintptr, LoggerLogLevel, byte, string, uintptr)

type LoggerClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass
}

func (x *LoggerClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Describes the level of logging output to provide.
type LoggerLogLevel int

var xLoggerLogLevelGLibType func() types.GType

func LoggerLogLevelGLibType() types.GType {
	return xLoggerLogLevelGLibType()
}

const (

	// No logging
	LoggerLogNoneValue LoggerLogLevel = 0
	// Log the Request-Line or Status-Line and
	//   the Soup-Debug pseudo-headers
	LoggerLogMinimalValue LoggerLogLevel = 1
	// Log the full request/response headers
	LoggerLogHeadersValue LoggerLogLevel = 2
	// Log the full headers and request/response bodies
	LoggerLogBodyValue LoggerLogLevel = 3
)

// Debug logging support
//
// #SoupLogger watches a [class@Session] and logs the HTTP traffic that
// it generates, for debugging purposes. Many applications use an
// environment variable to determine whether or not to use
// #SoupLogger, and to determine the amount of debugging output.
//
// To use #SoupLogger, first create a logger with [ctor@Logger.new], optionally
// configure it with [method@Logger.set_request_filter],
// [method@Logger.set_response_filter], and [method@Logger.set_printer], and
// then attach it to a session (or multiple sessions) with
// [method@Session.add_feature].
//
// By default, the debugging output is sent to `stdout`, and looks something
// like:
//
// ```
// &gt; POST /unauth HTTP/1.1
// &gt; Soup-Debug-Timestamp: 1200171744
// &gt; Soup-Debug: SoupSession 1 (0x612190), SoupMessage 1 (0x617000), GSocket 1 (0x612220)
// &gt; Host: localhost
// &gt; Content-Type: text/plain
// &gt; Connection: close
//
// &amp;lt; HTTP/1.1 201 Created
// &amp;lt; Soup-Debug-Timestamp: 1200171744
// &amp;lt; Soup-Debug: SoupMessage 1 (0x617000)
// &amp;lt; Date: Sun, 12 Jan 2008 21:02:24 GMT
// &amp;lt; Content-Length: 0
// ```
//
// The `Soup-Debug-Timestamp` line gives the time (as a `time_t`) when the
// request was sent, or the response fully received.
//
// The `Soup-Debug` line gives further debugging information about the
// [class@Session], [class@Message], and [class@Gio.Socket] involved; the hex
// numbers are the addresses of the objects in question (which may be useful if
// you are running in a debugger). The decimal IDs are simply counters that
// uniquely identify objects across the lifetime of the #SoupLogger. In
// particular, this can be used to identify when multiple messages are sent
// across the same connection.
//
// Currently, the request half of the message is logged just before
// the first byte of the request gets written to the network (from the
// [signal@Message::starting] signal).
//
// The response is logged just after the last byte of the response body is read
// from the network (from the [signal@Message::got-body] or
// [signal@Message::got-informational] signal), which means that the
// [signal@Message::got-headers] signal, and anything triggered off it (such as
// #SoupMessage::authenticate) will be emitted *before* the response headers are
// actually logged.
//
// If the response doesn't happen to trigger the [signal@Message::got-body] nor
// [signal@Message::got-informational] signals due to, for example, a
// cancellation before receiving the last byte of the response body, the
// response will still be logged on the event of the [signal@Message::finished]
// signal.
type Logger struct {
	gobject.Object
}

var xLoggerGLibType func() types.GType

func LoggerGLibType() types.GType {
	return xLoggerGLibType()
}

func LoggerNewFromInternalPtr(ptr uintptr) *Logger {
	cls := &Logger{}
	cls.Ptr = ptr
	return cls
}

var xNewLogger func(LoggerLogLevel) uintptr

// Creates a new #SoupLogger with the given debug level.
//
// If you need finer control over what message parts are and aren't
// logged, use [method@Logger.set_request_filter] and
// [method@Logger.set_response_filter].
func NewLogger(LevelVar LoggerLogLevel) *Logger {
	var cls *Logger

	cret := xNewLogger(LevelVar)

	if cret == 0 {
		return nil
	}
	cls = &Logger{}
	cls.Ptr = cret
	return cls
}

var xLoggerGetMaxBodySize func(uintptr) int

// Get the maximum body size for @logger.
func (x *Logger) GetMaxBodySize() int {

	cret := xLoggerGetMaxBodySize(x.GoPointer())

	return cret
}

var xLoggerSetMaxBodySize func(uintptr, int)

// Sets the maximum body size for @logger (-1 means no limit).
func (x *Logger) SetMaxBodySize(MaxBodySizeVar int) {

	xLoggerSetMaxBodySize(x.GoPointer(), MaxBodySizeVar)

}

var xLoggerSetPrinter func(uintptr, uintptr, uintptr, uintptr)

// Sets up an alternate log printing routine, if you don't want
// the log to go to `stdout`.
func (x *Logger) SetPrinter(PrinterVar *LoggerPrinter, PrinterDataVar uintptr, DestroyVar *glib.DestroyNotify) {

	var PrinterVarRef uintptr
	if PrinterVar != nil {
		PrinterVarPtr := uintptr(unsafe.Pointer(PrinterVar))
		if cbRefPtr, ok := glib.GetCallback(PrinterVarPtr); ok {
			PrinterVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 LoggerLogLevel, arg2 byte, arg3 string, arg4 uintptr) {
				cbFn := *PrinterVar
				cbFn(arg0, arg1, arg2, arg3, arg4)
			}
			PrinterVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(PrinterVarPtr, PrinterVarRef, PrinterVar)
		}
	}

	var DestroyVarRef uintptr
	if DestroyVar != nil {
		DestroyVarPtr := uintptr(unsafe.Pointer(DestroyVar))
		if cbRefPtr, ok := glib.GetCallback(DestroyVarPtr); ok {
			DestroyVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *DestroyVar
				cbFn(arg0)
			}
			DestroyVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(DestroyVarPtr, DestroyVarRef, DestroyVar)
		}
	}

	xLoggerSetPrinter(x.GoPointer(), PrinterVarRef, PrinterDataVar, DestroyVarRef)

}

var xLoggerSetRequestFilter func(uintptr, uintptr, uintptr, uintptr)

// Sets up a filter to determine the log level for a given request.
//
// For each HTTP request @logger will invoke @request_filter to
// determine how much (if any) of that request to log. (If you do not
// set a request filter, @logger will just always log requests at the
// level passed to [ctor@Logger.new].)
func (x *Logger) SetRequestFilter(RequestFilterVar *LoggerFilter, FilterDataVar uintptr, DestroyVar *glib.DestroyNotify) {

	var RequestFilterVarRef uintptr
	if RequestFilterVar != nil {
		RequestFilterVarPtr := uintptr(unsafe.Pointer(RequestFilterVar))
		if cbRefPtr, ok := glib.GetCallback(RequestFilterVarPtr); ok {
			RequestFilterVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) LoggerLogLevel {
				cbFn := *RequestFilterVar
				return cbFn(arg0, arg1, arg2)
			}
			RequestFilterVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(RequestFilterVarPtr, RequestFilterVarRef, RequestFilterVar)
		}
	}

	var DestroyVarRef uintptr
	if DestroyVar != nil {
		DestroyVarPtr := uintptr(unsafe.Pointer(DestroyVar))
		if cbRefPtr, ok := glib.GetCallback(DestroyVarPtr); ok {
			DestroyVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *DestroyVar
				cbFn(arg0)
			}
			DestroyVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(DestroyVarPtr, DestroyVarRef, DestroyVar)
		}
	}

	xLoggerSetRequestFilter(x.GoPointer(), RequestFilterVarRef, FilterDataVar, DestroyVarRef)

}

var xLoggerSetResponseFilter func(uintptr, uintptr, uintptr, uintptr)

// Sets up a filter to determine the log level for a given response.
//
// For each HTTP response @logger will invoke @response_filter to
// determine how much (if any) of that response to log. (If you do not
// set a response filter, @logger will just always log responses at
// the level passed to [ctor@Logger.new].)
func (x *Logger) SetResponseFilter(ResponseFilterVar *LoggerFilter, FilterDataVar uintptr, DestroyVar *glib.DestroyNotify) {

	var ResponseFilterVarRef uintptr
	if ResponseFilterVar != nil {
		ResponseFilterVarPtr := uintptr(unsafe.Pointer(ResponseFilterVar))
		if cbRefPtr, ok := glib.GetCallback(ResponseFilterVarPtr); ok {
			ResponseFilterVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) LoggerLogLevel {
				cbFn := *ResponseFilterVar
				return cbFn(arg0, arg1, arg2)
			}
			ResponseFilterVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(ResponseFilterVarPtr, ResponseFilterVarRef, ResponseFilterVar)
		}
	}

	var DestroyVarRef uintptr
	if DestroyVar != nil {
		DestroyVarPtr := uintptr(unsafe.Pointer(DestroyVar))
		if cbRefPtr, ok := glib.GetCallback(DestroyVarPtr); ok {
			DestroyVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *DestroyVar
				cbFn(arg0)
			}
			DestroyVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(DestroyVarPtr, DestroyVarRef, DestroyVar)
		}
	}

	xLoggerSetResponseFilter(x.GoPointer(), ResponseFilterVarRef, FilterDataVar, DestroyVarRef)

}

func (c *Logger) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *Logger) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyMaxBodySize sets the "max-body-size" property.
// If [property@Logger:level] is %SOUP_LOGGER_LOG_BODY, this gives
// the maximum number of bytes of the body that will be logged.
// (-1 means "no limit".)
func (x *Logger) SetPropertyMaxBodySize(value int) {
	var v gobject.Value
	v.Init(gobject.TypeIntVal)
	v.SetInt(value)
	x.SetProperty("max-body-size", &v)
}

// GetPropertyMaxBodySize gets the "max-body-size" property.
// If [property@Logger:level] is %SOUP_LOGGER_LOG_BODY, this gives
// the maximum number of bytes of the body that will be logged.
// (-1 means "no limit".)
func (x *Logger) GetPropertyMaxBodySize() int {
	var v gobject.Value
	x.GetProperty("max-body-size", &v)
	return v.GetInt()
}

func init() {
	core.SetPackageName("SOUP", "libsoup-3.0")
	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("SOUP") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xLoggerLogLevelGLibType, libs, "soup_logger_log_level_get_type")

	core.PuregoSafeRegister(&xLoggerGLibType, libs, "soup_logger_get_type")

	core.PuregoSafeRegister(&xNewLogger, libs, "soup_logger_new")

	core.PuregoSafeRegister(&xLoggerGetMaxBodySize, libs, "soup_logger_get_max_body_size")
	core.PuregoSafeRegister(&xLoggerSetMaxBodySize, libs, "soup_logger_set_max_body_size")
	core.PuregoSafeRegister(&xLoggerSetPrinter, libs, "soup_logger_set_printer")
	core.PuregoSafeRegister(&xLoggerSetRequestFilter, libs, "soup_logger_set_request_filter")
	core.PuregoSafeRegister(&xLoggerSetResponseFilter, libs, "soup_logger_set_response_filter")

}
