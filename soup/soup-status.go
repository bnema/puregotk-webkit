// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package soup

import (
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// Indicates the HTTP protocol version being used.
type HTTPVersion int

var xHTTPVersionGLibType func() types.GType

func HTTPVersionGLibType() types.GType {
	return xHTTPVersionGLibType()
}

const (

	// HTTP 1.0 (RFC 1945)
	Http10Value HTTPVersion = 0
	// HTTP 1.1 (RFC 2616)
	Http11Value HTTPVersion = 1
	// HTTP 2.0 (RFC 7540)
	Http20Value HTTPVersion = 2
)

// These represent the known HTTP status code values, plus various
// network and internal errors.
//
// Note that no libsoup functions take or return this type directly;
// any function that works with status codes will accept unrecognized
// status codes as well.
type Status int

var xStatusGLibType func() types.GType

func StatusGLibType() types.GType {
	return xStatusGLibType()
}

const (

	// No status available. (Eg, the message has not
	// been sent yet)
	StatusNoneValue Status = 0
	// 100 Continue (HTTP)
	StatusContinueValue Status = 100
	// 101 Switching Protocols (HTTP)
	StatusSwitchingProtocolsValue Status = 101
	// 102 Processing (WebDAV)
	StatusProcessingValue Status = 102
	// 200 Success (HTTP). Also used by many lower-level
	// soup routines to indicate success.
	StatusOkValue Status = 200
	// 201 Created (HTTP)
	StatusCreatedValue Status = 201
	// 202 Accepted (HTTP)
	StatusAcceptedValue Status = 202
	// 203 Non-Authoritative Information
	// (HTTP)
	StatusNonAuthoritativeValue Status = 203
	// 204 No Content (HTTP)
	StatusNoContentValue Status = 204
	// 205 Reset Content (HTTP)
	StatusResetContentValue Status = 205
	// 206 Partial Content (HTTP)
	StatusPartialContentValue Status = 206
	// 207 Multi-Status (WebDAV)
	StatusMultiStatusValue Status = 207
	// 300 Multiple Choices (HTTP)
	StatusMultipleChoicesValue Status = 300
	// 301 Moved Permanently (HTTP)
	StatusMovedPermanentlyValue Status = 301
	// 302 Found (HTTP)
	StatusFoundValue Status = 302
	// 302 Moved Temporarily (old name,
	// RFC 2068)
	StatusMovedTemporarilyValue Status = 302
	// 303 See Other (HTTP)
	StatusSeeOtherValue Status = 303
	// 304 Not Modified (HTTP)
	StatusNotModifiedValue Status = 304
	// 305 Use Proxy (HTTP)
	StatusUseProxyValue Status = 305
	// 306 [Unused] (HTTP)
	StatusNotAppearingInThisProtocolValue Status = 306
	// 307 Temporary Redirect (HTTP)
	StatusTemporaryRedirectValue Status = 307
	// 308 Permanent Redirect (HTTP)
	StatusPermanentRedirectValue Status = 308
	// 400 Bad Request (HTTP)
	StatusBadRequestValue Status = 400
	// 401 Unauthorized (HTTP)
	StatusUnauthorizedValue Status = 401
	// 402 Payment Required (HTTP)
	StatusPaymentRequiredValue Status = 402
	// 403 Forbidden (HTTP)
	StatusForbiddenValue Status = 403
	// 404 Not Found (HTTP)
	StatusNotFoundValue Status = 404
	// 405 Method Not Allowed (HTTP)
	StatusMethodNotAllowedValue Status = 405
	// 406 Not Acceptable (HTTP)
	StatusNotAcceptableValue Status = 406
	// 407 Proxy Authentication
	// Required (HTTP)
	StatusProxyAuthenticationRequiredValue Status = 407
	// shorter alias for
	// %SOUP_STATUS_PROXY_AUTHENTICATION_REQUIRED
	StatusProxyUnauthorizedValue Status = 407
	// 408 Request Timeout (HTTP)
	StatusRequestTimeoutValue Status = 408
	// 409 Conflict (HTTP)
	StatusConflictValue Status = 409
	// 410 Gone (HTTP)
	StatusGoneValue Status = 410
	// 411 Length Required (HTTP)
	StatusLengthRequiredValue Status = 411
	// 412 Precondition Failed (HTTP)
	StatusPreconditionFailedValue Status = 412
	// 413 Request Entity Too Large
	// (HTTP)
	StatusRequestEntityTooLargeValue Status = 413
	// 414 Request-URI Too Long (HTTP)
	StatusRequestUriTooLongValue Status = 414
	// 415 Unsupported Media Type
	// (HTTP)
	StatusUnsupportedMediaTypeValue Status = 415
	// 416 Requested Range
	// Not Satisfiable (HTTP)
	StatusRequestedRangeNotSatisfiableValue Status = 416
	// shorter alias for
	// %SOUP_STATUS_REQUESTED_RANGE_NOT_SATISFIABLE
	StatusInvalidRangeValue Status = 416
	// 417 Expectation Failed (HTTP)
	StatusExpectationFailedValue Status = 417
	// 421 Misdirected Request
	StatusMisdirectedRequestValue Status = 421
	// 422 Unprocessable Entity
	// (WebDAV)
	StatusUnprocessableEntityValue Status = 422
	// 423 Locked (WebDAV)
	StatusLockedValue Status = 423
	// 424 Failed Dependency (WebDAV)
	StatusFailedDependencyValue Status = 424
	// 500 Internal Server Error
	// (HTTP)
	StatusInternalServerErrorValue Status = 500
	// 501 Not Implemented (HTTP)
	StatusNotImplementedValue Status = 501
	// 502 Bad Gateway (HTTP)
	StatusBadGatewayValue Status = 502
	// 503 Service Unavailable (HTTP)
	StatusServiceUnavailableValue Status = 503
	// 504 Gateway Timeout (HTTP)
	StatusGatewayTimeoutValue Status = 504
	// 505 HTTP Version Not
	// Supported (HTTP)
	StatusHttpVersionNotSupportedValue Status = 505
	// 507 Insufficient Storage
	// (WebDAV)
	StatusInsufficientStorageValue Status = 507
	// 510 Not Extended (RFC 2774)
	StatusNotExtendedValue Status = 510
)

var xStatusGetPhrase func(uint) string

// Looks up the stock HTTP description of @status_code.
//
// *There is no reason for you to ever use this
// function.* If you wanted the textual description for the
// [property@Message:status-code] of a given [class@Message], you should just
// look at the message's [property@Message:reason-phrase]. However, you
// should only do that for use in debugging messages; HTTP reason
// phrases are not localized, and are not generally very descriptive
// anyway, and so they should never be presented to the user directly.
// Instead, you should create you own error messages based on the
// status code, and on what you were trying to do.
func StatusGetPhrase(StatusCodeVar uint) string {

	cret := xStatusGetPhrase(StatusCodeVar)
	return cret
}

func init() {
	core.SetPackageName("SOUP", "libsoup-3.0")
	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("SOUP") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xHTTPVersionGLibType, libs, "soup_http_version_get_type")

	core.PuregoSafeRegister(&xStatusGLibType, libs, "soup_status_get_type")

	core.PuregoSafeRegister(&xStatusGetPhrase, libs, "soup_status_get_phrase")

}
