// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package soup

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// The prototype for a #SoupAuthDomain filter.
//
// See [method@AuthDomain.set_filter] for details.
type AuthDomainFilter func(uintptr, uintptr, uintptr) bool

// The prototype for a #SoupAuthDomain generic authentication callback.
//
// The callback should look up the user's password, call
// [method@AuthDomain.check_password], and use the return value from that method
// as its own return value.
//
// In general, for security reasons, it is preferable to use the
// auth-domain-specific auth callbacks (eg,
// [callback@AuthDomainBasicAuthCallback] and
// [callback@AuthDomainDigestAuthCallback]), because they don't require
// keeping a cleartext password database. Most users will use the same
// password for many different sites, meaning if any site with a
// cleartext password database is compromised, accounts on other
// servers might be compromised as well. For many of the cases where
// [class@Server] is used, this is not really relevant, but it may still
// be worth considering.
type AuthDomainGenericAuthCallback func(uintptr, uintptr, string, uintptr) bool

type AuthDomainClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass

	xAccepts uintptr

	xChallenge uintptr

	xCheckPassword uintptr

	Padding [6]uintptr
}

func (x *AuthDomainClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideAccepts sets the "accepts" callback function.
func (x *AuthDomainClass) OverrideAccepts(cb func(*AuthDomain, *ServerMessage, string) string) {
	if cb == nil {
		x.xAccepts = 0
	} else {
		x.xAccepts = purego.NewCallback(func(DomainVarp uintptr, MsgVarp uintptr, HeaderVarp string) string {
			return cb(AuthDomainNewFromInternalPtr(DomainVarp), ServerMessageNewFromInternalPtr(MsgVarp), HeaderVarp)
		})
	}
}

// GetAccepts gets the "accepts" callback function.
func (x *AuthDomainClass) GetAccepts() func(*AuthDomain, *ServerMessage, string) string {
	if x.xAccepts == 0 {
		return nil
	}
	var rawCallback func(DomainVarp uintptr, MsgVarp uintptr, HeaderVarp string) string
	purego.RegisterFunc(&rawCallback, x.xAccepts)
	return func(DomainVar *AuthDomain, MsgVar *ServerMessage, HeaderVar string) string {
		return rawCallback(DomainVar.GoPointer(), MsgVar.GoPointer(), HeaderVar)
	}
}

// OverrideChallenge sets the "challenge" callback function.
func (x *AuthDomainClass) OverrideChallenge(cb func(*AuthDomain, *ServerMessage) string) {
	if cb == nil {
		x.xChallenge = 0
	} else {
		x.xChallenge = purego.NewCallback(func(DomainVarp uintptr, MsgVarp uintptr) string {
			return cb(AuthDomainNewFromInternalPtr(DomainVarp), ServerMessageNewFromInternalPtr(MsgVarp))
		})
	}
}

// GetChallenge gets the "challenge" callback function.
func (x *AuthDomainClass) GetChallenge() func(*AuthDomain, *ServerMessage) string {
	if x.xChallenge == 0 {
		return nil
	}
	var rawCallback func(DomainVarp uintptr, MsgVarp uintptr) string
	purego.RegisterFunc(&rawCallback, x.xChallenge)
	return func(DomainVar *AuthDomain, MsgVar *ServerMessage) string {
		return rawCallback(DomainVar.GoPointer(), MsgVar.GoPointer())
	}
}

// OverrideCheckPassword sets the "check_password" callback function.
func (x *AuthDomainClass) OverrideCheckPassword(cb func(*AuthDomain, *ServerMessage, string, string) bool) {
	if cb == nil {
		x.xCheckPassword = 0
	} else {
		x.xCheckPassword = purego.NewCallback(func(DomainVarp uintptr, MsgVarp uintptr, UsernameVarp string, PasswordVarp string) bool {
			return cb(AuthDomainNewFromInternalPtr(DomainVarp), ServerMessageNewFromInternalPtr(MsgVarp), UsernameVarp, PasswordVarp)
		})
	}
}

// GetCheckPassword gets the "check_password" callback function.
func (x *AuthDomainClass) GetCheckPassword() func(*AuthDomain, *ServerMessage, string, string) bool {
	if x.xCheckPassword == 0 {
		return nil
	}
	var rawCallback func(DomainVarp uintptr, MsgVarp uintptr, UsernameVarp string, PasswordVarp string) bool
	purego.RegisterFunc(&rawCallback, x.xCheckPassword)
	return func(DomainVar *AuthDomain, MsgVar *ServerMessage, UsernameVar string, PasswordVar string) bool {
		return rawCallback(DomainVar.GoPointer(), MsgVar.GoPointer(), UsernameVar, PasswordVar)
	}
}

// Server-side authentication.
//
// A #SoupAuthDomain manages authentication for all or part of a
// [class@Server]. To make a server require authentication, first create
// an appropriate subclass of #SoupAuthDomain, and then add it to the
// server with [method@Server.add_auth_domain].
//
// In order for an auth domain to have any effect, you must add one or more
// paths to it (via [method@AuthDomain.add_path]). To require authentication for
// all ordinary requests, add the path `"/"`. (Note that this does not include
// the special `"*"` URI (eg, "OPTIONS *"), which must be added as a separate
// path if you want to cover it.)
//
// If you need greater control over which requests should and shouldn't be
// authenticated, add paths covering everything you *might* want authenticated,
// and then use a filter ([method@AuthDomain.set_filter] to bypass
// authentication for those requests that don't need it.
type AuthDomain struct {
	gobject.Object
}

var xAuthDomainGLibType func() types.GType

func AuthDomainGLibType() types.GType {
	return xAuthDomainGLibType()
}

func AuthDomainNewFromInternalPtr(ptr uintptr) *AuthDomain {
	cls := &AuthDomain{}
	cls.Ptr = ptr
	return cls
}

var xAuthDomainAccepts func(uintptr, uintptr) string

// Checks if @msg contains appropriate authorization for @domain to
// accept it.
//
// Mirroring [method@AuthDomain.covers], this does not check whether or not
// @domain *cares* if @msg is authorized.
//
// This is used by [class@Server] internally and is probably of no use to
// anyone else.
func (x *AuthDomain) Accepts(MsgVar *ServerMessage) string {

	cret := xAuthDomainAccepts(x.GoPointer(), MsgVar.GoPointer())

	return cret
}

var xAuthDomainAddPath func(uintptr, string)

// Adds @path to @domain.
//
// Requests under @path on @domain's server will require authentication (unless
// overridden by [method@AuthDomain.remove_path] or
// [method@AuthDomain.set_filter]).
func (x *AuthDomain) AddPath(PathVar string) {

	xAuthDomainAddPath(x.GoPointer(), PathVar)

}

var xAuthDomainChallenge func(uintptr, uintptr)

// Adds a "WWW-Authenticate" or "Proxy-Authenticate" header to @msg.
//
// It requests that the client authenticate, and sets @msg's status accordingly.
//
// This is used by [class@Server] internally and is probably of no use to
// anyone else.
func (x *AuthDomain) Challenge(MsgVar *ServerMessage) {

	xAuthDomainChallenge(x.GoPointer(), MsgVar.GoPointer())

}

var xAuthDomainCheckPassword func(uintptr, uintptr, string, string) bool

// Checks if @msg authenticates to @domain via @username and
// @password.
//
// This would normally be called from a
// [callback@AuthDomainGenericAuthCallback].
func (x *AuthDomain) CheckPassword(MsgVar *ServerMessage, UsernameVar string, PasswordVar string) bool {

	cret := xAuthDomainCheckPassword(x.GoPointer(), MsgVar.GoPointer(), UsernameVar, PasswordVar)

	return cret
}

var xAuthDomainCovers func(uintptr, uintptr) bool

// Checks if @domain requires @msg to be authenticated (according to
// its paths and filter function).
//
// This does not actually look at whether @msg *is* authenticated, merely
// whether or not it needs to be.
//
// This is used by [class@Server] internally and is probably of no use to
// anyone else.
func (x *AuthDomain) Covers(MsgVar *ServerMessage) bool {

	cret := xAuthDomainCovers(x.GoPointer(), MsgVar.GoPointer())

	return cret
}

var xAuthDomainGetRealm func(uintptr) string

// Gets the realm name associated with @domain.
func (x *AuthDomain) GetRealm() string {

	cret := xAuthDomainGetRealm(x.GoPointer())

	return cret
}

var xAuthDomainRemovePath func(uintptr, string)

// Removes @path from @domain.
//
// Requests under @path on @domain's server will NOT require
// authentication.
//
// This is not simply an undo-er for [method@AuthDomain.add_path]; it
// can be used to "carve out" a subtree that does not require
// authentication inside a hierarchy that does. Note also that unlike
// with [method@AuthDomain.add_path], this cannot be overridden by
// adding a filter, as filters can only bypass authentication that
// would otherwise be required, not require it where it would
// otherwise be unnecessary.
func (x *AuthDomain) RemovePath(PathVar string) {

	xAuthDomainRemovePath(x.GoPointer(), PathVar)

}

var xAuthDomainSetFilter func(uintptr, uintptr, uintptr, uintptr)

// Adds @filter as an authentication filter to @domain.
//
// The filter gets a chance to bypass authentication for certain requests that
// would otherwise require it. Eg, it might check the message's path in some way
// that is too complicated to do via the other methods, or it might check the
// message's method, and allow GETs but not PUTs.
//
// The filter function returns %TRUE if the request should still
// require authentication, or %FALSE if authentication is unnecessary
// for this request.
//
// To help prevent security holes, your filter should return %TRUE by
// default, and only return %FALSE under specifically-tested
// circumstances, rather than the other way around. Eg, in the example
// above, where you want to authenticate PUTs but not GETs, you should
// check if the method is GET and return %FALSE in that case, and then
// return %TRUE for all other methods (rather than returning %TRUE for
// PUT and %FALSE for all other methods). This way if it turned out
// (now or later) that some paths supported additional methods besides
// GET and PUT, those methods would default to being NOT allowed for
// unauthenticated users.
//
// You can also set the filter by setting the SoupAuthDomain:filter
// and [property@AuthDomain:filter-data properties], which can also be
// used to set the filter at construct time.
func (x *AuthDomain) SetFilter(FilterVar *AuthDomainFilter, FilterDataVar uintptr, DnotifyVar *glib.DestroyNotify) {

	var FilterVarRef uintptr
	if FilterVar != nil {
		FilterVarPtr := uintptr(unsafe.Pointer(FilterVar))
		if cbRefPtr, ok := glib.GetCallback(FilterVarPtr); ok {
			FilterVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) bool {
				cbFn := *FilterVar
				return cbFn(arg0, arg1, arg2)
			}
			FilterVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(FilterVarPtr, FilterVarRef, FilterVar)
		}
	}

	var DnotifyVarRef uintptr
	if DnotifyVar != nil {
		DnotifyVarPtr := uintptr(unsafe.Pointer(DnotifyVar))
		if cbRefPtr, ok := glib.GetCallback(DnotifyVarPtr); ok {
			DnotifyVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *DnotifyVar
				cbFn(arg0)
			}
			DnotifyVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(DnotifyVarPtr, DnotifyVarRef, DnotifyVar)
		}
	}

	xAuthDomainSetFilter(x.GoPointer(), FilterVarRef, FilterDataVar, DnotifyVarRef)

}

var xAuthDomainSetGenericAuthCallback func(uintptr, uintptr, uintptr, uintptr)

// Sets @auth_callback as an authentication-handling callback for @domain.
//
// Whenever a request comes in to @domain which cannot be authenticated via a
// domain-specific auth callback (eg, [callback@AuthDomainDigestAuthCallback]),
// the generic auth callback will be invoked. See
// [callback@AuthDomainGenericAuthCallback] for information on what the callback
// should do.
func (x *AuthDomain) SetGenericAuthCallback(AuthCallbackVar *AuthDomainGenericAuthCallback, AuthDataVar uintptr, DnotifyVar *glib.DestroyNotify) {

	var AuthCallbackVarRef uintptr
	if AuthCallbackVar != nil {
		AuthCallbackVarPtr := uintptr(unsafe.Pointer(AuthCallbackVar))
		if cbRefPtr, ok := glib.GetCallback(AuthCallbackVarPtr); ok {
			AuthCallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 string, arg3 uintptr) bool {
				cbFn := *AuthCallbackVar
				return cbFn(arg0, arg1, arg2, arg3)
			}
			AuthCallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(AuthCallbackVarPtr, AuthCallbackVarRef, AuthCallbackVar)
		}
	}

	var DnotifyVarRef uintptr
	if DnotifyVar != nil {
		DnotifyVarPtr := uintptr(unsafe.Pointer(DnotifyVar))
		if cbRefPtr, ok := glib.GetCallback(DnotifyVarPtr); ok {
			DnotifyVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *DnotifyVar
				cbFn(arg0)
			}
			DnotifyVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(DnotifyVarPtr, DnotifyVarRef, DnotifyVar)
		}
	}

	xAuthDomainSetGenericAuthCallback(x.GoPointer(), AuthCallbackVarRef, AuthDataVar, DnotifyVarRef)

}

func (c *AuthDomain) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *AuthDomain) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyFilterData sets the "filter-data" property.
// Data to pass to the [callback@AuthDomainFilter].
func (x *AuthDomain) SetPropertyFilterData(value uintptr) {
	var v gobject.Value
	v.Init(gobject.TypePointerVal)
	v.SetPointer(value)
	x.SetProperty("filter-data", &v)
}

// GetPropertyFilterData gets the "filter-data" property.
// Data to pass to the [callback@AuthDomainFilter].
func (x *AuthDomain) GetPropertyFilterData() uintptr {
	var v gobject.Value
	x.GetProperty("filter-data", &v)
	return v.GetPointer()
}

// SetPropertyGenericAuthData sets the "generic-auth-data" property.
// The data to pass to the [callback@AuthDomainGenericAuthCallback].
func (x *AuthDomain) SetPropertyGenericAuthData(value uintptr) {
	var v gobject.Value
	v.Init(gobject.TypePointerVal)
	v.SetPointer(value)
	x.SetProperty("generic-auth-data", &v)
}

// GetPropertyGenericAuthData gets the "generic-auth-data" property.
// The data to pass to the [callback@AuthDomainGenericAuthCallback].
func (x *AuthDomain) GetPropertyGenericAuthData() uintptr {
	var v gobject.Value
	x.GetProperty("generic-auth-data", &v)
	return v.GetPointer()
}

// SetPropertyProxy sets the "proxy" property.
// Whether or not this is a proxy auth domain.
func (x *AuthDomain) SetPropertyProxy(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("proxy", &v)
}

// GetPropertyProxy gets the "proxy" property.
// Whether or not this is a proxy auth domain.
func (x *AuthDomain) GetPropertyProxy() bool {
	var v gobject.Value
	x.GetProperty("proxy", &v)
	return v.GetBoolean()
}

// SetPropertyRealm sets the "realm" property.
// The realm of this auth domain.
func (x *AuthDomain) SetPropertyRealm(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("realm", &v)
}

// GetPropertyRealm gets the "realm" property.
// The realm of this auth domain.
func (x *AuthDomain) GetPropertyRealm() string {
	var v gobject.Value
	x.GetProperty("realm", &v)
	return v.GetString()
}

func init() {
	core.SetPackageName("SOUP", "libsoup-3.0")
	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("SOUP") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xAuthDomainGLibType, libs, "soup_auth_domain_get_type")

	core.PuregoSafeRegister(&xAuthDomainAccepts, libs, "soup_auth_domain_accepts")
	core.PuregoSafeRegister(&xAuthDomainAddPath, libs, "soup_auth_domain_add_path")
	core.PuregoSafeRegister(&xAuthDomainChallenge, libs, "soup_auth_domain_challenge")
	core.PuregoSafeRegister(&xAuthDomainCheckPassword, libs, "soup_auth_domain_check_password")
	core.PuregoSafeRegister(&xAuthDomainCovers, libs, "soup_auth_domain_covers")
	core.PuregoSafeRegister(&xAuthDomainGetRealm, libs, "soup_auth_domain_get_realm")
	core.PuregoSafeRegister(&xAuthDomainRemovePath, libs, "soup_auth_domain_remove_path")
	core.PuregoSafeRegister(&xAuthDomainSetFilter, libs, "soup_auth_domain_set_filter")
	core.PuregoSafeRegister(&xAuthDomainSetGenericAuthCallback, libs, "soup_auth_domain_set_generic_auth_callback")

}
