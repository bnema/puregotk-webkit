// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package soup

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type MultipartInputStreamClass struct {
	_ structs.HostLayout

	ParentClass gio.FilterInputStreamClass
}

func (x *MultipartInputStreamClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Handles streams of multipart messages.
//
// This adds support for the multipart responses. For handling the
// multiple parts the user needs to wrap the [class@Gio.InputStream] obtained by
// sending the request with a [class@MultipartInputStream] and use
// [method@MultipartInputStream.next_part] before reading. Responses
// which are not wrapped will be treated like non-multipart responses.
//
// Note that although #SoupMultipartInputStream is a [class@Gio.InputStream],
// you should not read directly from it, and the results are undefined
// if you do.
type MultipartInputStream struct {
	gio.FilterInputStream
}

var xMultipartInputStreamGLibType func() types.GType

func MultipartInputStreamGLibType() types.GType {
	return xMultipartInputStreamGLibType()
}

func MultipartInputStreamNewFromInternalPtr(ptr uintptr) *MultipartInputStream {
	cls := &MultipartInputStream{}
	cls.Ptr = ptr
	return cls
}

var xNewMultipartInputStream func(uintptr, uintptr) uintptr

// Creates a new #SoupMultipartInputStream that wraps the
// [class@Gio.InputStream] obtained by sending the [class@Message].
//
// Reads should not be done directly through this object, use the input streams
// returned by [method@MultipartInputStream.next_part] or its async
// counterpart instead.
func NewMultipartInputStream(MsgVar *Message, BaseStreamVar *gio.InputStream) *MultipartInputStream {
	var cls *MultipartInputStream

	cret := xNewMultipartInputStream(MsgVar.GoPointer(), BaseStreamVar.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &MultipartInputStream{}
	cls.Ptr = cret
	return cls
}

var xMultipartInputStreamGetHeaders func(uintptr) *MessageHeaders

// Obtains the headers for the part currently being processed.
//
// Note that the [struct@MessageHeaders] that are returned are owned by the
// #SoupMultipartInputStream and will be replaced when a call is made to
// [method@MultipartInputStream.next_part] or its async counterpart, so if
// keeping the headers is required, a copy must be made.
//
// Note that if a part had no headers at all an empty [struct@MessageHeaders]
// will be returned.
func (x *MultipartInputStream) GetHeaders() *MessageHeaders {

	cret := xMultipartInputStreamGetHeaders(x.GoPointer())
	return cret
}

var xMultipartInputStreamNextPart func(uintptr, uintptr, **glib.Error) uintptr

// Obtains an input stream for the next part.
//
// When dealing with a multipart response the input stream needs to be wrapped
// in a #SoupMultipartInputStream and this function or its async counterpart
// need to be called to obtain the first part for reading.
//
// After calling this function,
// [method@MultipartInputStream.get_headers] can be used to obtain the
// headers for the first part. A read of 0 bytes indicates the end of
// the part; a new call to this function should be done at that point,
// to obtain the next part.
//
// @error will only be set if an error happens during a read, %NULL
// is a valid return value otherwise.
func (x *MultipartInputStream) NextPart(CancellableVar *gio.Cancellable) (*gio.InputStream, error) {
	var cls *gio.InputStream
	var cerr *glib.Error

	cret := xMultipartInputStreamNextPart(x.GoPointer(), CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &gio.InputStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xMultipartInputStreamNextPartAsync func(uintptr, int, uintptr, uintptr, uintptr)

// Obtains a [class@Gio.InputStream] for the next request.
//
// See [method@MultipartInputStream.next_part] for details on the workflow.
func (x *MultipartInputStream) NextPartAsync(IoPriorityVar int, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, DataVar uintptr) {

	xMultipartInputStreamNextPartAsync(x.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), DataVar)

}

var xMultipartInputStreamNextPartFinish func(uintptr, uintptr, **glib.Error) uintptr

// Finishes an asynchronous request for the next part.
func (x *MultipartInputStream) NextPartFinish(ResultVar gio.AsyncResult) (*gio.InputStream, error) {
	var cls *gio.InputStream
	var cerr *glib.Error

	cret := xMultipartInputStreamNextPartFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &gio.InputStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

func (c *MultipartInputStream) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *MultipartInputStream) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Checks if @stream is actually pollable. Some classes may implement
// #GPollableInputStream but have only certain instances of that class
// be pollable. If this method returns %FALSE, then the behavior of
// other #GPollableInputStream methods is undefined.
//
// For any given stream, the value returned by this method is constant;
// a stream cannot switch from pollable to non-pollable or vice versa.
func (x *MultipartInputStream) CanPoll() bool {

	cret := gio.XGPollableInputStreamCanPoll(x.GoPointer())
	return cret
}

// Creates a #GSource that triggers when @stream can be read, or
// @cancellable is triggered or an error occurs. The callback on the
// source is of the #GPollableSourceFunc type.
//
// As with g_pollable_input_stream_is_readable(), it is possible that
// the stream may not actually be readable even after the source
// triggers, so you should use g_pollable_input_stream_read_nonblocking()
// rather than g_input_stream_read() from the callback.
//
// The behaviour of this method is undefined if
// g_pollable_input_stream_can_poll() returns %FALSE for @stream.
func (x *MultipartInputStream) CreateSource(CancellableVar *gio.Cancellable) *glib.Source {

	cret := gio.XGPollableInputStreamCreateSource(x.GoPointer(), CancellableVar.GoPointer())
	return cret
}

// Checks if @stream can be read.
//
// Note that some stream types may not be able to implement this 100%
// reliably, and it is possible that a call to g_input_stream_read()
// after this returns %TRUE would still block. To guarantee
// non-blocking behavior, you should always use
// g_pollable_input_stream_read_nonblocking(), which will return a
// %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
//
// The behaviour of this method is undefined if
// g_pollable_input_stream_can_poll() returns %FALSE for @stream.
func (x *MultipartInputStream) IsReadable() bool {

	cret := gio.XGPollableInputStreamIsReadable(x.GoPointer())
	return cret
}

// Attempts to read up to @count bytes from @stream into @buffer, as
// with g_input_stream_read(). If @stream is not currently readable,
// this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
// use g_pollable_input_stream_create_source() to create a #GSource
// that will be triggered when @stream is readable.
//
// Note that since this method never blocks, you cannot actually
// use @cancellable to cancel it. However, it will return an error
// if @cancellable has already been cancelled when you call, which
// may happen if you call this method after a source triggers due
// to having been cancelled.
//
// The behaviour of this method is undefined if
// g_pollable_input_stream_can_poll() returns %FALSE for @stream.
func (x *MultipartInputStream) ReadNonblocking(BufferVar *[]byte, CountVar uint, CancellableVar *gio.Cancellable) (int, error) {
	var cerr *glib.Error

	cret := gio.XGPollableInputStreamReadNonblocking(x.GoPointer(), BufferVar, CountVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

func init() {
	core.SetPackageName("SOUP", "libsoup-3.0")
	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("SOUP") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xMultipartInputStreamGLibType, libs, "soup_multipart_input_stream_get_type")

	core.PuregoSafeRegister(&xNewMultipartInputStream, libs, "soup_multipart_input_stream_new")

	core.PuregoSafeRegister(&xMultipartInputStreamGetHeaders, libs, "soup_multipart_input_stream_get_headers")
	core.PuregoSafeRegister(&xMultipartInputStreamNextPart, libs, "soup_multipart_input_stream_next_part")
	core.PuregoSafeRegister(&xMultipartInputStreamNextPartAsync, libs, "soup_multipart_input_stream_next_part_async")
	core.PuregoSafeRegister(&xMultipartInputStreamNextPartFinish, libs, "soup_multipart_input_stream_next_part_finish")

}
