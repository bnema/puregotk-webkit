// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package soup

import (
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// Pre-defined close codes that can be passed to
// [method@WebsocketConnection.close] or received from
// [method@WebsocketConnection.get_close_code].
//
// However, other codes are also allowed.
type WebsocketCloseCode int

var xWebsocketCloseCodeGLibType func() types.GType

func WebsocketCloseCodeGLibType() types.GType {
	return xWebsocketCloseCodeGLibType()
}

const (

	// a normal, non-error close
	WebsocketCloseNormalValue WebsocketCloseCode = 1000
	// the client/server is going away
	WebsocketCloseGoingAwayValue WebsocketCloseCode = 1001
	// a protocol error occurred
	WebsocketCloseProtocolErrorValue WebsocketCloseCode = 1002
	// the endpoint received data
	//   of a type that it does not support.
	WebsocketCloseUnsupportedDataValue WebsocketCloseCode = 1003
	// reserved value indicating that
	//   no close code was present; must not be sent.
	WebsocketCloseNoStatusValue WebsocketCloseCode = 1005
	// reserved value indicating that
	//   the connection was closed abnormally; must not be sent.
	WebsocketCloseAbnormalValue WebsocketCloseCode = 1006
	// the endpoint received data that
	//   was invalid (eg, non-UTF-8 data in a text message).
	WebsocketCloseBadDataValue WebsocketCloseCode = 1007
	// generic error code
	//   indicating some sort of policy violation.
	WebsocketClosePolicyViolationValue WebsocketCloseCode = 1008
	// the endpoint received a message
	//   that is too big to process.
	WebsocketCloseTooBigValue WebsocketCloseCode = 1009
	// the client is closing the
	//   connection because the server failed to negotiate a required
	//   extension.
	WebsocketCloseNoExtensionValue WebsocketCloseCode = 1010
	// the server is closing the
	//   connection because it was unable to fulfill the request.
	WebsocketCloseServerErrorValue WebsocketCloseCode = 1011
	// reserved value indicating that
	//   the TLS handshake failed; must not be sent.
	WebsocketCloseTlsHandshakeValue WebsocketCloseCode = 1015
)

// The type of a [class@WebsocketConnection].
type WebsocketConnectionType int

var xWebsocketConnectionTypeGLibType func() types.GType

func WebsocketConnectionTypeGLibType() types.GType {
	return xWebsocketConnectionTypeGLibType()
}

const (

	// unknown/invalid connection
	WebsocketConnectionUnknownValue WebsocketConnectionType = 0
	// a client-side connection
	WebsocketConnectionClientValue WebsocketConnectionType = 1
	// a server-side connection
	WebsocketConnectionServerValue WebsocketConnectionType = 2
)

// The type of data contained in a [signal@WebsocketConnection::message] signal.
type WebsocketDataType int

var xWebsocketDataTypeGLibType func() types.GType

func WebsocketDataTypeGLibType() types.GType {
	return xWebsocketDataTypeGLibType()
}

const (

	// UTF-8 text
	WebsocketDataTextValue WebsocketDataType = 1
	// binary data
	WebsocketDataBinaryValue WebsocketDataType = 2
)

// WebSocket-related errors.
type WebsocketError int

var xWebsocketErrorGLibType func() types.GType

func WebsocketErrorGLibType() types.GType {
	return xWebsocketErrorGLibType()
}

const (

	// a generic error
	WebsocketErrorFailedValue WebsocketError = 0
	// attempted to handshake with a
	//   server that does not appear to understand WebSockets.
	WebsocketErrorNotWebsocketValue WebsocketError = 1
	// the WebSocket handshake failed
	//   because some detail was invalid (eg, incorrect accept key).
	WebsocketErrorBadHandshakeValue WebsocketError = 2
	// the WebSocket handshake failed
	//   because the "Origin" header was not an allowed value.
	WebsocketErrorBadOriginValue WebsocketError = 3
)

// The state of the WebSocket connection.
type WebsocketState int

var xWebsocketStateGLibType func() types.GType

func WebsocketStateGLibType() types.GType {
	return xWebsocketStateGLibType()
}

const (

	// the connection is ready to send messages
	WebsocketStateOpenValue WebsocketState = 1
	// the connection is in the process of
	//   closing down; messages may be received, but not sent
	WebsocketStateClosingValue WebsocketState = 2
	// the connection is completely closed down
	WebsocketStateClosedValue WebsocketState = 3
)

var xWebsocketClientPrepareHandshake func(uintptr, uintptr, []string, []gobject.TypeClass)

// Adds the necessary headers to @msg to request a WebSocket
// handshake including supported WebSocket extensions.
//
// The message body and non-WebSocket-related headers are
// not modified.
//
// This is a low-level function; if you use
// [method@Session.websocket_connect_async] to create a WebSocket connection, it
// will call this for you.
func WebsocketClientPrepareHandshake(MsgVar *Message, OriginVar *string, ProtocolsVar []string, SupportedExtensionsVar []gobject.TypeClass) {

	OriginVarPtr := core.GStrdupNullable(OriginVar)
	defer core.GFreeNullable(OriginVarPtr)

	xWebsocketClientPrepareHandshake(MsgVar.GoPointer(), OriginVarPtr, ProtocolsVar, SupportedExtensionsVar)

}

var xWebsocketClientVerifyHandshake func(uintptr, []gobject.TypeClass, **glib.List, **glib.Error) bool

// Looks at the response status code and headers in @msg and
// determines if they contain a valid WebSocket handshake response
// (given the handshake request in @msg's request headers).
//
// If @supported_extensions is non-%NULL, extensions included in the
// response "Sec-WebSocket-Extensions" are verified too. Accepted
// extensions are returned in @accepted_extensions parameter if non-%NULL.
//
// This is a low-level function; if you use
// [method@Session.websocket_connect_async] to create a WebSocket
// connection, it will call this for you.
func WebsocketClientVerifyHandshake(MsgVar *Message, SupportedExtensionsVar []gobject.TypeClass, AcceptedExtensionsVar **glib.List) (bool, error) {
	var cerr *glib.Error

	cret := xWebsocketClientVerifyHandshake(MsgVar.GoPointer(), SupportedExtensionsVar, AcceptedExtensionsVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xWebsocketErrorQuark func() glib.Quark

// Registers error quark for SoupWebsocket if needed.
func WebsocketErrorQuark() glib.Quark {

	cret := xWebsocketErrorQuark()
	return cret
}

var xWebsocketServerCheckHandshake func(uintptr, uintptr, []string, []gobject.TypeClass, **glib.Error) bool

// Examines the method and request headers in @msg and determines
// whether @msg contains a valid handshake request.
//
// If @origin is non-%NULL, then only requests containing a matching
// "Origin" header will be accepted. If @protocols is non-%NULL, then
// only requests containing a compatible "Sec-WebSocket-Protocols"
// header will be accepted. If @supported_extensions is non-%NULL, then
// only requests containing valid supported extensions in
// "Sec-WebSocket-Extensions" header will be accepted.
//
// Normally [func@websocket_server_process_handshake]
// will take care of this for you, and if you use
// [method@Server.add_websocket_handler] to handle accepting WebSocket
// connections, it will call that for you. However, this function may
// be useful if you need to perform more complicated validation; eg,
// accepting multiple different Origins, or handling different protocols
// depending on the path.
func WebsocketServerCheckHandshake(MsgVar *ServerMessage, OriginVar *string, ProtocolsVar []string, SupportedExtensionsVar []gobject.TypeClass) (bool, error) {
	var cerr *glib.Error

	OriginVarPtr := core.GStrdupNullable(OriginVar)
	defer core.GFreeNullable(OriginVarPtr)

	cret := xWebsocketServerCheckHandshake(MsgVar.GoPointer(), OriginVarPtr, ProtocolsVar, SupportedExtensionsVar, &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xWebsocketServerProcessHandshake func(uintptr, uintptr, []string, []gobject.TypeClass, **glib.List) bool

// Examines the method and request headers in @msg and (assuming @msg
// contains a valid handshake request), fills in the handshake
// response.
//
// If @expected_origin is non-%NULL, then only requests containing a matching
// "Origin" header will be accepted. If @protocols is non-%NULL, then
// only requests containing a compatible "Sec-WebSocket-Protocols"
// header will be accepted. If @supported_extensions is non-%NULL, then
// only requests containing valid supported extensions in
// "Sec-WebSocket-Extensions" header will be accepted. The accepted extensions
// will be returned in @accepted_extensions parameter if non-%NULL.
//
// This is a low-level function; if you use
// [method@Server.add_websocket_handler] to handle accepting WebSocket
// connections, it will call this for you.
func WebsocketServerProcessHandshake(MsgVar *ServerMessage, ExpectedOriginVar *string, ProtocolsVar []string, SupportedExtensionsVar []gobject.TypeClass, AcceptedExtensionsVar **glib.List) bool {

	ExpectedOriginVarPtr := core.GStrdupNullable(ExpectedOriginVar)
	defer core.GFreeNullable(ExpectedOriginVarPtr)

	cret := xWebsocketServerProcessHandshake(MsgVar.GoPointer(), ExpectedOriginVarPtr, ProtocolsVar, SupportedExtensionsVar, AcceptedExtensionsVar)
	return cret
}

func init() {
	core.SetPackageName("SOUP", "libsoup-3.0")
	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("SOUP") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xWebsocketCloseCodeGLibType, libs, "soup_websocket_close_code_get_type")

	core.PuregoSafeRegister(&xWebsocketConnectionTypeGLibType, libs, "soup_websocket_connection_type_get_type")

	core.PuregoSafeRegister(&xWebsocketDataTypeGLibType, libs, "soup_websocket_data_type_get_type")

	core.PuregoSafeRegister(&xWebsocketErrorGLibType, libs, "soup_websocket_error_get_type")

	core.PuregoSafeRegister(&xWebsocketStateGLibType, libs, "soup_websocket_state_get_type")

	core.PuregoSafeRegister(&xWebsocketClientPrepareHandshake, libs, "soup_websocket_client_prepare_handshake")
	core.PuregoSafeRegister(&xWebsocketClientVerifyHandshake, libs, "soup_websocket_client_verify_handshake")
	core.PuregoSafeRegister(&xWebsocketErrorQuark, libs, "soup_websocket_error_quark")
	core.PuregoSafeRegister(&xWebsocketServerCheckHandshake, libs, "soup_websocket_server_check_handshake")
	core.PuregoSafeRegister(&xWebsocketServerProcessHandshake, libs, "soup_websocket_server_process_handshake")

}
