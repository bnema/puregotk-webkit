// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package soup

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// Represents a multipart HTTP message body, parsed according to the
// syntax of RFC 2046.
//
// Of particular interest to HTTP are `multipart/byte-ranges` and
// `multipart/form-data`,
//
// Although the headers of a #SoupMultipart body part will contain the
// full headers from that body part, libsoup does not interpret them
// according to MIME rules. For example, each body part is assumed to
// have "binary" Content-Transfer-Encoding, even if its headers
// explicitly state otherwise. In other words, don't try to use
// #SoupMultipart for handling real MIME multiparts.
type Multipart struct {
	_ structs.HostLayout
}

var xMultipartGLibType func() types.GType

func MultipartGLibType() types.GType {
	return xMultipartGLibType()
}

func (x *Multipart) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xNewMultipart func(string) *Multipart

// Creates a new empty #SoupMultipart with a randomly-generated
// boundary string.
//
// Note that @mime_type must be the full MIME type, including "multipart/".
//
// See also: [ctor@Message.new_from_multipart].
func NewMultipart(MimeTypeVar string) *Multipart {

	cret := xNewMultipart(MimeTypeVar)
	return cret
}

var xNewMultipartFromMessage func(*MessageHeaders, *glib.Bytes) *Multipart

// Parses @headers and @body to form a new #SoupMultipart
func NewMultipartFromMessage(HeadersVar *MessageHeaders, BodyVar *glib.Bytes) *Multipart {

	cret := xNewMultipartFromMessage(HeadersVar, BodyVar)
	return cret
}

var xMultipartAppendFormFile func(uintptr, string, uintptr, uintptr, *glib.Bytes)

// Adds a new MIME part containing @body to @multipart
//
// Uses "Content-Disposition: form-data", as per the HTML forms specification.
func (x *Multipart) AppendFormFile(ControlNameVar string, FilenameVar *string, ContentTypeVar *string, BodyVar *glib.Bytes) {

	xMultipartAppendFormFile(x.GoPointer(), ControlNameVar, core.NullableStringToPtr(FilenameVar), core.NullableStringToPtr(ContentTypeVar), BodyVar)

}

var xMultipartAppendFormString func(uintptr, string, string)

// Adds a new MIME part containing @data to @multipart.
//
// Uses "Content-Disposition: form-data", as per the HTML forms specification.
func (x *Multipart) AppendFormString(ControlNameVar string, DataVar string) {

	xMultipartAppendFormString(x.GoPointer(), ControlNameVar, DataVar)

}

var xMultipartAppendPart func(uintptr, *MessageHeaders, *glib.Bytes)

// Adds a new MIME part to @multipart with the given headers and body.
//
// (The multipart will make its own copies of @headers and @body, so
// you should free your copies if you are not using them for anything
// else.)
func (x *Multipart) AppendPart(HeadersVar *MessageHeaders, BodyVar *glib.Bytes) {

	xMultipartAppendPart(x.GoPointer(), HeadersVar, BodyVar)

}

var xMultipartFree func(uintptr)

// Frees @multipart.
func (x *Multipart) Free() {

	xMultipartFree(x.GoPointer())

}

var xMultipartGetLength func(uintptr) int

// Gets the number of body parts in @multipart.
func (x *Multipart) GetLength() int {

	cret := xMultipartGetLength(x.GoPointer())
	return cret
}

var xMultipartGetPart func(uintptr, int, **MessageHeaders, **glib.Bytes) bool

// Gets the indicated body part from @multipart.
func (x *Multipart) GetPart(PartVar int, HeadersVar **MessageHeaders, BodyVar **glib.Bytes) bool {

	cret := xMultipartGetPart(x.GoPointer(), PartVar, HeadersVar, BodyVar)
	return cret
}

var xMultipartToMessage func(uintptr, *MessageHeaders, **glib.Bytes)

// Serializes @multipart to @dest_headers and @dest_body.
func (x *Multipart) ToMessage(DestHeadersVar *MessageHeaders, DestBodyVar **glib.Bytes) {

	xMultipartToMessage(x.GoPointer(), DestHeadersVar, DestBodyVar)

}

func init() {
	core.SetPackageName("SOUP", "libsoup-3.0")
	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("SOUP") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xMultipartGLibType, libs, "soup_multipart_get_type")

	core.PuregoSafeRegister(&xNewMultipart, libs, "soup_multipart_new")
	core.PuregoSafeRegister(&xNewMultipartFromMessage, libs, "soup_multipart_new_from_message")

	core.PuregoSafeRegister(&xMultipartAppendFormFile, libs, "soup_multipart_append_form_file")
	core.PuregoSafeRegister(&xMultipartAppendFormString, libs, "soup_multipart_append_form_string")
	core.PuregoSafeRegister(&xMultipartAppendPart, libs, "soup_multipart_append_part")
	core.PuregoSafeRegister(&xMultipartFree, libs, "soup_multipart_free")
	core.PuregoSafeRegister(&xMultipartGetLength, libs, "soup_multipart_get_length")
	core.PuregoSafeRegister(&xMultipartGetPart, libs, "soup_multipart_get_part")
	core.PuregoSafeRegister(&xMultipartToMessage, libs, "soup_multipart_to_message")

}
