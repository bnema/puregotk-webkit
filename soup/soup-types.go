// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package soup

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// Implements HTTP cookies, as described by
// [RFC 6265](http://tools.ietf.org/html/rfc6265.txt).
//
// To have a [class@Session] handle cookies for your appliction
// automatically, use a [class@CookieJar].
//
// @name and @value will be set for all cookies. If the cookie is
// generated from a string that appears to have no name, then @name
// will be the empty string.
//
// @domain and @path give the host or domain, and path within that
// host/domain, to restrict this cookie to. If @domain starts with
// ".", that indicates a domain (which matches the string after the
// ".", or any hostname that has @domain as a suffix). Otherwise, it
// is a hostname and must match exactly.
//
// @expires will be non-%NULL if the cookie uses either the original
// "expires" attribute, or the newer "max-age" attribute. If @expires
// is %NULL, it indicates that neither "expires" nor "max-age" was
// specified, and the cookie expires at the end of the session.
//
// If @http_only is set, the cookie should not be exposed to untrusted
// code (eg, javascript), so as to minimize the danger posed by
// cross-site scripting attacks.
type Cookie struct {
	_ structs.HostLayout
}

var xCookieGLibType func() types.GType

func CookieGLibType() types.GType {
	return xCookieGLibType()
}

func (x *Cookie) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xNewCookie func(string, string, string, string, int) uintptr

// Creates a new #SoupCookie with the given attributes.
//
// Use [method@Cookie.set_secure] and [method@Cookie.set_http_only] if you
// need to set those attributes on the returned cookie.
//
// If @domain starts with ".", that indicates a domain (which matches
// the string after the ".", or any hostname that has @domain as a
// suffix). Otherwise, it is a hostname and must match exactly.
//
// @max_age is used to set the "expires" attribute on the cookie; pass
// -1 to not include the attribute (indicating that the cookie expires
// with the current session), 0 for an already-expired cookie, or a
// lifetime in seconds. You can use the constants
// %SOUP_COOKIE_MAX_AGE_ONE_HOUR, %SOUP_COOKIE_MAX_AGE_ONE_DAY,
// %SOUP_COOKIE_MAX_AGE_ONE_WEEK and %SOUP_COOKIE_MAX_AGE_ONE_YEAR (or
// multiples thereof) to calculate this value. (If you really care
// about setting the exact time that the cookie will expire, use
// [method@Cookie.set_expires].)
//
// As of version 3.4.0 the default value of a cookie's same-site-policy
// is %SOUP_SAME_SITE_POLICY_LAX.
func NewCookie(NameVar string, ValueVar string, DomainVar string, PathVar string, MaxAgeVar int) uintptr {

	cret := xNewCookie(NameVar, ValueVar, DomainVar, PathVar, MaxAgeVar)
	return cret
}

var xCookieAppliesToUri func(uintptr, uintptr) bool

// Tests if @cookie should be sent to @uri.
//
// (At the moment, this does not check that @cookie's domain matches
// @uri, because it assumes that the caller has already done that.
// But don't rely on that; it may change in the future.)
func (x *Cookie) AppliesToUri(UriVar uintptr) bool {

	cret := xCookieAppliesToUri(x.GoPointer(), UriVar)
	return cret
}

var xCookieCopy func(uintptr) uintptr

// Copies @cookie.
func (x *Cookie) Copy() uintptr {

	cret := xCookieCopy(x.GoPointer())
	return cret
}

var xCookieDomainMatches func(uintptr, string) bool

// Checks if the @cookie's domain and @host match.
//
// The domains match if @cookie should be sent when making a request to @host,
// or that @cookie should be accepted when receiving a response from @host.
func (x *Cookie) DomainMatches(HostVar string) bool {

	cret := xCookieDomainMatches(x.GoPointer(), HostVar)
	return cret
}

var xCookieEqual func(uintptr, uintptr) bool

// Tests if @cookie1 and @cookie2 are equal.
//
// Note that currently, this does not check that the cookie domains
// match. This may change in the future.
func (x *Cookie) Equal(Cookie2Var uintptr) bool {

	cret := xCookieEqual(x.GoPointer(), Cookie2Var)
	return cret
}

var xCookieFree func(uintptr)

// Frees @cookie.
func (x *Cookie) Free() {

	xCookieFree(x.GoPointer())

}

var xCookieGetDomain func(uintptr) string

// Gets @cookie's domain.
func (x *Cookie) GetDomain() string {

	cret := xCookieGetDomain(x.GoPointer())
	return cret
}

var xCookieGetExpires func(uintptr) uintptr

// Gets @cookie's expiration time.
func (x *Cookie) GetExpires() uintptr {

	cret := xCookieGetExpires(x.GoPointer())
	return cret
}

var xCookieGetHttpOnly func(uintptr) bool

// Gets @cookie's HttpOnly attribute.
func (x *Cookie) GetHttpOnly() bool {

	cret := xCookieGetHttpOnly(x.GoPointer())
	return cret
}

var xCookieGetName func(uintptr) string

// Gets @cookie's name.
func (x *Cookie) GetName() string {

	cret := xCookieGetName(x.GoPointer())
	return cret
}

var xCookieGetPath func(uintptr) string

// Gets @cookie's path.
func (x *Cookie) GetPath() string {

	cret := xCookieGetPath(x.GoPointer())
	return cret
}

var xCookieGetSameSitePolicy func(uintptr) SameSitePolicy

// Returns the same-site policy for this cookie.
func (x *Cookie) GetSameSitePolicy() SameSitePolicy {

	cret := xCookieGetSameSitePolicy(x.GoPointer())
	return cret
}

var xCookieGetSecure func(uintptr) bool

// Gets @cookie's secure attribute.
func (x *Cookie) GetSecure() bool {

	cret := xCookieGetSecure(x.GoPointer())
	return cret
}

var xCookieGetValue func(uintptr) string

// Gets @cookie's value.
func (x *Cookie) GetValue() string {

	cret := xCookieGetValue(x.GoPointer())
	return cret
}

var xCookieSetDomain func(uintptr, string)

// Sets @cookie's domain to @domain.
func (x *Cookie) SetDomain(DomainVar string) {

	xCookieSetDomain(x.GoPointer(), DomainVar)

}

var xCookieSetExpires func(uintptr, uintptr)

// Sets @cookie's expiration time to @expires.
//
// If @expires is %NULL, @cookie will be a session cookie and will expire at the
// end of the client's session.
//
// (This sets the same property as [method@Cookie.set_max_age].)
func (x *Cookie) SetExpires(ExpiresVar uintptr) {

	xCookieSetExpires(x.GoPointer(), ExpiresVar)

}

var xCookieSetHttpOnly func(uintptr, bool)

// Sets @cookie's HttpOnly attribute to @http_only.
//
// If %TRUE, @cookie will be marked as "http only", meaning it should not be
// exposed to web page scripts or other untrusted code.
func (x *Cookie) SetHttpOnly(HttpOnlyVar bool) {

	xCookieSetHttpOnly(x.GoPointer(), HttpOnlyVar)

}

var xCookieSetMaxAge func(uintptr, int)

// Sets @cookie's max age to @max_age.
//
// If @max_age is -1, the cookie is a session cookie, and will expire at the end
// of the client's session. Otherwise, it is the number of seconds until the
// cookie expires. You can use the constants %SOUP_COOKIE_MAX_AGE_ONE_HOUR,
// %SOUP_COOKIE_MAX_AGE_ONE_DAY, %SOUP_COOKIE_MAX_AGE_ONE_WEEK and
// %SOUP_COOKIE_MAX_AGE_ONE_YEAR (or multiples thereof) to calculate this value.
// (A value of 0 indicates that the cookie should be considered
// already-expired.)
//
// This sets the same property as [method@Cookie.set_expires].
func (x *Cookie) SetMaxAge(MaxAgeVar int) {

	xCookieSetMaxAge(x.GoPointer(), MaxAgeVar)

}

var xCookieSetName func(uintptr, string)

// Sets @cookie's name to @name.
func (x *Cookie) SetName(NameVar string) {

	xCookieSetName(x.GoPointer(), NameVar)

}

var xCookieSetPath func(uintptr, string)

// Sets @cookie's path to @path.
func (x *Cookie) SetPath(PathVar string) {

	xCookieSetPath(x.GoPointer(), PathVar)

}

var xCookieSetSameSitePolicy func(uintptr, SameSitePolicy)

// When used in conjunction with
// [method@CookieJar.get_cookie_list_with_same_site_info] this sets the policy
// of when this cookie should be exposed.
func (x *Cookie) SetSameSitePolicy(PolicyVar SameSitePolicy) {

	xCookieSetSameSitePolicy(x.GoPointer(), PolicyVar)

}

var xCookieSetSecure func(uintptr, bool)

// Sets @cookie's secure attribute to @secure.
//
// If %TRUE, @cookie will only be transmitted from the client to the server over
// secure (https) connections.
func (x *Cookie) SetSecure(SecureVar bool) {

	xCookieSetSecure(x.GoPointer(), SecureVar)

}

var xCookieSetValue func(uintptr, string)

// Sets @cookie's value to @value.
func (x *Cookie) SetValue(ValueVar string) {

	xCookieSetValue(x.GoPointer(), ValueVar)

}

var xCookieToCookieHeader func(uintptr) string

// Serializes @cookie in the format used by the Cookie header (ie, for
// returning a cookie from a [class@Session] to a server).
func (x *Cookie) ToCookieHeader() string {

	cret := xCookieToCookieHeader(x.GoPointer())
	return cret
}

var xCookieToSetCookieHeader func(uintptr) string

// Serializes @cookie in the format used by the Set-Cookie header.
//
// i.e. for sending a cookie from a [class@Server] to a client.
func (x *Cookie) ToSetCookieHeader() string {

	cret := xCookieToSetCookieHeader(x.GoPointer())
	return cret
}

// #SoupHSTSPolicy implements HTTP policies, as described by
// [RFC 6797](http://tools.ietf.org/html/rfc6797).
//
// @domain represents the host that this policy applies to. The domain
// must be IDNA-canonicalized. [ctor@HSTSPolicy.new] and related methods
// will do this for you.
//
// @max_age contains the 'max-age' value from the Strict Transport
// Security header and indicates the time to live of this policy,
// in seconds.
//
// @expires will be non-%NULL if the policy has been set by the host and
// hence has an expiry time. If @expires is %NULL, it indicates that the
// policy is a permanent session policy set by the user agent.
//
// If @include_subdomains is %TRUE, the Strict Transport Security policy
// must also be enforced on subdomains of @domain.
type HSTSPolicy struct {
	_ structs.HostLayout
}

var xHSTSPolicyGLibType func() types.GType

func HSTSPolicyGLibType() types.GType {
	return xHSTSPolicyGLibType()
}

func (x *HSTSPolicy) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xNewHSTSPolicy func(string, uint32, bool) uintptr

// Creates a new #SoupHSTSPolicy with the given attributes.
//
// @domain is a domain on which the strict transport security policy
// represented by this object must be enforced.
//
// @max_age is used to set the "expires" attribute on the policy; pass
// %SOUP_HSTS_POLICY_MAX_AGE_PAST for an already-expired policy, or a
// lifetime in seconds.
//
// If @include_subdomains is %TRUE, the strict transport security policy
// must also be enforced on all subdomains of @domain.
func NewHSTSPolicy(DomainVar string, MaxAgeVar uint32, IncludeSubdomainsVar bool) uintptr {

	cret := xNewHSTSPolicy(DomainVar, MaxAgeVar, IncludeSubdomainsVar)
	return cret
}

var xNewHSTSPolicyFromResponse func(uintptr) uintptr

// Parses @msg's first "Strict-Transport-Security" response header and
// returns a #SoupHSTSPolicy.
func NewHSTSPolicyFromResponse(MsgVar *Message) uintptr {

	cret := xNewHSTSPolicyFromResponse(MsgVar.GoPointer())
	return cret
}

var xNewHSTSPolicyFull func(string, uint32, uintptr, bool) uintptr

// Full version of [ctor@HSTSPolicy.new], to use with an existing
// expiration date.
//
// See [ctor@HSTSPolicy.new] for details.
func NewHSTSPolicyFull(DomainVar string, MaxAgeVar uint32, ExpiresVar uintptr, IncludeSubdomainsVar bool) uintptr {

	cret := xNewHSTSPolicyFull(DomainVar, MaxAgeVar, ExpiresVar, IncludeSubdomainsVar)
	return cret
}

var xNewHSTSPolicySessionPolicy func(string, bool) uintptr

// Creates a new session #SoupHSTSPolicy with the given attributes.
//
// A session policy is a policy that is valid during the lifetime of
// the [class@HSTSEnforcer] it is added to. Contrary to regular policies,
// it has no expiration date and is not stored in persistent
// enforcers. These policies are useful for user-agent to load their
// own or user-defined rules.
//
// @domain is a domain on which the strict transport security policy
// represented by this object must be enforced.
//
// If @include_subdomains is %TRUE, the strict transport security policy
// must also be enforced on all subdomains of @domain.
func NewHSTSPolicySessionPolicy(DomainVar string, IncludeSubdomainsVar bool) uintptr {

	cret := xNewHSTSPolicySessionPolicy(DomainVar, IncludeSubdomainsVar)
	return cret
}

var xHSTSPolicyCopy func(uintptr) uintptr

// Copies @policy.
func (x *HSTSPolicy) Copy() uintptr {

	cret := xHSTSPolicyCopy(x.GoPointer())
	return cret
}

var xHSTSPolicyEqual func(uintptr, uintptr) bool

// Tests if @policy1 and @policy2 are equal.
func (x *HSTSPolicy) Equal(Policy2Var uintptr) bool {

	cret := xHSTSPolicyEqual(x.GoPointer(), Policy2Var)
	return cret
}

var xHSTSPolicyFree func(uintptr)

// Frees @policy.
func (x *HSTSPolicy) Free() {

	xHSTSPolicyFree(x.GoPointer())

}

var xHSTSPolicyGetDomain func(uintptr) string

// Gets @policy's domain.
func (x *HSTSPolicy) GetDomain() string {

	cret := xHSTSPolicyGetDomain(x.GoPointer())
	return cret
}

var xHSTSPolicyGetExpires func(uintptr) uintptr

// Returns the expiration date for @policy.
func (x *HSTSPolicy) GetExpires() uintptr {

	cret := xHSTSPolicyGetExpires(x.GoPointer())
	return cret
}

var xHSTSPolicyGetMaxAge func(uintptr) uint32

// Returns the max age for @policy.
func (x *HSTSPolicy) GetMaxAge() uint32 {

	cret := xHSTSPolicyGetMaxAge(x.GoPointer())
	return cret
}

var xHSTSPolicyIncludesSubdomains func(uintptr) bool

// Gets whether @policy include its subdomains.
func (x *HSTSPolicy) IncludesSubdomains() bool {

	cret := xHSTSPolicyIncludesSubdomains(x.GoPointer())
	return cret
}

var xHSTSPolicyIsExpired func(uintptr) bool

// Gets whether @policy is expired.
//
// Permanent policies never expire.
func (x *HSTSPolicy) IsExpired() bool {

	cret := xHSTSPolicyIsExpired(x.GoPointer())
	return cret
}

var xHSTSPolicyIsSessionPolicy func(uintptr) bool

// Gets whether @policy is a non-permanent, non-expirable session policy.
//
// See [ctor@HSTSPolicy.new_session_policy] for details.
func (x *HSTSPolicy) IsSessionPolicy() bool {

	cret := xHSTSPolicyIsSessionPolicy(x.GoPointer())
	return cret
}

// Contains metrics collected while loading a [class@Message] either from the
// network or the disk cache.
//
// Metrics are not collected by default for a [class@Message], you need to add the
// flag %SOUP_MESSAGE_COLLECT_METRICS to enable the feature.
//
// Temporal metrics are expressed as a monotonic time and always start with a
// fetch start event and finish with response end. All other events are optional.
// An event can be 0 because it hasn't happened yet, because it's optional or
// because the load failed before the event reached.
//
// Size metrics are expressed in bytes and are updated while the [class@Message] is
// being loaded. You can connect to different [class@Message] signals to get the
// final result of every value.
type MessageMetrics struct {
	_ structs.HostLayout
}

var xMessageMetricsGLibType func() types.GType

func MessageMetricsGLibType() types.GType {
	return xMessageMetricsGLibType()
}

func (x *MessageMetrics) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xMessageMetricsCopy func(uintptr) uintptr

// Copies @metrics.
func (x *MessageMetrics) Copy() uintptr {

	cret := xMessageMetricsCopy(x.GoPointer())
	return cret
}

var xMessageMetricsFree func(uintptr)

// Frees @metrics.
func (x *MessageMetrics) Free() {

	xMessageMetricsFree(x.GoPointer())

}

var xMessageMetricsGetConnectEnd func(uintptr) uint64

// Get the time immediately after the [class@Message] completed the
// connection to the server. This includes the time for the proxy
// negotiation and TLS handshake.
//
// It will be 0 if no network connection was required to fetch the resource (a
// persistent connection was used or resource was loaded from the local disk
// cache).
func (x *MessageMetrics) GetConnectEnd() uint64 {

	cret := xMessageMetricsGetConnectEnd(x.GoPointer())
	return cret
}

var xMessageMetricsGetConnectStart func(uintptr) uint64

// Get the time immediately before the [class@Message] started to
// establish the connection to the server.
//
// It will be 0 if no network connection was required to fetch the resource (a
// persistent connection was used or resource was loaded from the local disk
// cache).
func (x *MessageMetrics) GetConnectStart() uint64 {

	cret := xMessageMetricsGetConnectStart(x.GoPointer())
	return cret
}

var xMessageMetricsGetDnsEnd func(uintptr) uint64

// Get the time immediately after the [class@Message] completed the
// domain lookup name for the resource.
//
// It will be 0 if no domain lookup was required to fetch the resource (a
// persistent connection was used or resource was loaded from the local disk
// cache).
func (x *MessageMetrics) GetDnsEnd() uint64 {

	cret := xMessageMetricsGetDnsEnd(x.GoPointer())
	return cret
}

var xMessageMetricsGetDnsStart func(uintptr) uint64

// Get the time immediately before the [class@Message] started the
// domain lookup name for the resource.
//
// It will be 0 if no domain lookup was required to fetch the resource (a
// persistent connection was used or resource was loaded from the local disk
// cache).
func (x *MessageMetrics) GetDnsStart() uint64 {

	cret := xMessageMetricsGetDnsStart(x.GoPointer())
	return cret
}

var xMessageMetricsGetFetchStart func(uintptr) uint64

// Get the time immediately before the [class@Message] started to
// fetch a resource either from a remote server or local disk cache.
func (x *MessageMetrics) GetFetchStart() uint64 {

	cret := xMessageMetricsGetFetchStart(x.GoPointer())
	return cret
}

var xMessageMetricsGetRequestBodyBytesSent func(uintptr) uint64

// Get the number of bytes sent to the network for the request body.
//
// This is the size of the body sent, after encodings are applied, so it might
// be greater than the value returned by
// [method@MessageMetrics.get_request_body_size]. This value is available right
// before [signal@Message::wrote-body] signal is emitted, but you might get an
// intermediate value if called before.
func (x *MessageMetrics) GetRequestBodyBytesSent() uint64 {

	cret := xMessageMetricsGetRequestBodyBytesSent(x.GoPointer())
	return cret
}

var xMessageMetricsGetRequestBodySize func(uintptr) uint64

// Get the request body size in bytes. This is the size of the original body
// given to the request before any encoding is applied.
//
// This value is available right before [signal@Message::wrote-body] signal is
// emitted, but you might get an intermediate value if called before.
func (x *MessageMetrics) GetRequestBodySize() uint64 {

	cret := xMessageMetricsGetRequestBodySize(x.GoPointer())
	return cret
}

var xMessageMetricsGetRequestHeaderBytesSent func(uintptr) uint64

// Get the number of bytes sent to the network for the request headers.
//
// This value is available right before [signal@Message::wrote-headers] signal
// is emitted, but you might get an intermediate value if called before.
func (x *MessageMetrics) GetRequestHeaderBytesSent() uint64 {

	cret := xMessageMetricsGetRequestHeaderBytesSent(x.GoPointer())
	return cret
}

var xMessageMetricsGetRequestStart func(uintptr) uint64

// Get the time immediately before the [class@Message] started the
// request of the resource from the server or the local disk cache.
func (x *MessageMetrics) GetRequestStart() uint64 {

	cret := xMessageMetricsGetRequestStart(x.GoPointer())
	return cret
}

var xMessageMetricsGetResponseBodyBytesReceived func(uintptr) uint64

// Get the number of bytes received from the network for the response body.
//
// This value is available right before [signal@Message::got-body] signal is
// emitted, but you might get an intermediate value if called before. For
// resources loaded from the disk cache this value is always 0.
func (x *MessageMetrics) GetResponseBodyBytesReceived() uint64 {

	cret := xMessageMetricsGetResponseBodyBytesReceived(x.GoPointer())
	return cret
}

var xMessageMetricsGetResponseBodySize func(uintptr) uint64

// Get the response body size in bytes.
//
// This is the size of the body as given to the user after all encodings are
// applied, so it might be greater than the value returned by
// [method@MessageMetrics.get_response_body_bytes_received]. This value is
// available right before [signal@Message::got-body] signal is emitted, but you
// might get an intermediate value if called before.
func (x *MessageMetrics) GetResponseBodySize() uint64 {

	cret := xMessageMetricsGetResponseBodySize(x.GoPointer())
	return cret
}

var xMessageMetricsGetResponseEnd func(uintptr) uint64

// Get the time immediately after the [class@Message] received the last
// bytes of the response from the server or the local disk cache.
//
// In case of load failure, this returns the time immediately before the
// fetch is aborted.
func (x *MessageMetrics) GetResponseEnd() uint64 {

	cret := xMessageMetricsGetResponseEnd(x.GoPointer())
	return cret
}

var xMessageMetricsGetResponseHeaderBytesReceived func(uintptr) uint64

// Get the number of bytes received from the network for the response headers.
//
// This value is available right before [signal@Message::got-headers] signal
// is emitted, but you might get an intermediate value if called before.
// For resources loaded from the disk cache this value is always 0.
func (x *MessageMetrics) GetResponseHeaderBytesReceived() uint64 {

	cret := xMessageMetricsGetResponseHeaderBytesReceived(x.GoPointer())
	return cret
}

var xMessageMetricsGetResponseStart func(uintptr) uint64

// Get the time immediately after the [class@Message] received the first
// bytes of the response from the server or the local disk cache.
func (x *MessageMetrics) GetResponseStart() uint64 {

	cret := xMessageMetricsGetResponseStart(x.GoPointer())
	return cret
}

var xMessageMetricsGetTlsStart func(uintptr) uint64

// Get the time immediately before the [class@Message] started the
// TLS handshake.
//
// It will be 0 if no TLS handshake was required to fetch the resource
// (connection was not secure, a persistent connection was used or resource was
// loaded from the local disk cache).
func (x *MessageMetrics) GetTlsStart() uint64 {

	cret := xMessageMetricsGetTlsStart(x.GoPointer())
	return cret
}

func init() {
	core.SetPackageName("SOUP", "libsoup-3.0")
	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("SOUP") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xCookieGLibType, libs, "soup_cookie_get_type")

	core.PuregoSafeRegister(&xNewCookie, libs, "soup_cookie_new")

	core.PuregoSafeRegister(&xCookieAppliesToUri, libs, "soup_cookie_applies_to_uri")
	core.PuregoSafeRegister(&xCookieCopy, libs, "soup_cookie_copy")
	core.PuregoSafeRegister(&xCookieDomainMatches, libs, "soup_cookie_domain_matches")
	core.PuregoSafeRegister(&xCookieEqual, libs, "soup_cookie_equal")
	core.PuregoSafeRegister(&xCookieFree, libs, "soup_cookie_free")
	core.PuregoSafeRegister(&xCookieGetDomain, libs, "soup_cookie_get_domain")
	core.PuregoSafeRegister(&xCookieGetExpires, libs, "soup_cookie_get_expires")
	core.PuregoSafeRegister(&xCookieGetHttpOnly, libs, "soup_cookie_get_http_only")
	core.PuregoSafeRegister(&xCookieGetName, libs, "soup_cookie_get_name")
	core.PuregoSafeRegister(&xCookieGetPath, libs, "soup_cookie_get_path")
	core.PuregoSafeRegister(&xCookieGetSameSitePolicy, libs, "soup_cookie_get_same_site_policy")
	core.PuregoSafeRegister(&xCookieGetSecure, libs, "soup_cookie_get_secure")
	core.PuregoSafeRegister(&xCookieGetValue, libs, "soup_cookie_get_value")
	core.PuregoSafeRegister(&xCookieSetDomain, libs, "soup_cookie_set_domain")
	core.PuregoSafeRegister(&xCookieSetExpires, libs, "soup_cookie_set_expires")
	core.PuregoSafeRegister(&xCookieSetHttpOnly, libs, "soup_cookie_set_http_only")
	core.PuregoSafeRegister(&xCookieSetMaxAge, libs, "soup_cookie_set_max_age")
	core.PuregoSafeRegister(&xCookieSetName, libs, "soup_cookie_set_name")
	core.PuregoSafeRegister(&xCookieSetPath, libs, "soup_cookie_set_path")
	core.PuregoSafeRegister(&xCookieSetSameSitePolicy, libs, "soup_cookie_set_same_site_policy")
	core.PuregoSafeRegister(&xCookieSetSecure, libs, "soup_cookie_set_secure")
	core.PuregoSafeRegister(&xCookieSetValue, libs, "soup_cookie_set_value")
	core.PuregoSafeRegister(&xCookieToCookieHeader, libs, "soup_cookie_to_cookie_header")
	core.PuregoSafeRegister(&xCookieToSetCookieHeader, libs, "soup_cookie_to_set_cookie_header")

	core.PuregoSafeRegister(&xHSTSPolicyGLibType, libs, "soup_hsts_policy_get_type")

	core.PuregoSafeRegister(&xNewHSTSPolicy, libs, "soup_hsts_policy_new")
	core.PuregoSafeRegister(&xNewHSTSPolicyFromResponse, libs, "soup_hsts_policy_new_from_response")
	core.PuregoSafeRegister(&xNewHSTSPolicyFull, libs, "soup_hsts_policy_new_full")
	core.PuregoSafeRegister(&xNewHSTSPolicySessionPolicy, libs, "soup_hsts_policy_new_session_policy")

	core.PuregoSafeRegister(&xHSTSPolicyCopy, libs, "soup_hsts_policy_copy")
	core.PuregoSafeRegister(&xHSTSPolicyEqual, libs, "soup_hsts_policy_equal")
	core.PuregoSafeRegister(&xHSTSPolicyFree, libs, "soup_hsts_policy_free")
	core.PuregoSafeRegister(&xHSTSPolicyGetDomain, libs, "soup_hsts_policy_get_domain")
	core.PuregoSafeRegister(&xHSTSPolicyGetExpires, libs, "soup_hsts_policy_get_expires")
	core.PuregoSafeRegister(&xHSTSPolicyGetMaxAge, libs, "soup_hsts_policy_get_max_age")
	core.PuregoSafeRegister(&xHSTSPolicyIncludesSubdomains, libs, "soup_hsts_policy_includes_subdomains")
	core.PuregoSafeRegister(&xHSTSPolicyIsExpired, libs, "soup_hsts_policy_is_expired")
	core.PuregoSafeRegister(&xHSTSPolicyIsSessionPolicy, libs, "soup_hsts_policy_is_session_policy")

	core.PuregoSafeRegister(&xMessageMetricsGLibType, libs, "soup_message_metrics_get_type")

	core.PuregoSafeRegister(&xMessageMetricsCopy, libs, "soup_message_metrics_copy")
	core.PuregoSafeRegister(&xMessageMetricsFree, libs, "soup_message_metrics_free")
	core.PuregoSafeRegister(&xMessageMetricsGetConnectEnd, libs, "soup_message_metrics_get_connect_end")
	core.PuregoSafeRegister(&xMessageMetricsGetConnectStart, libs, "soup_message_metrics_get_connect_start")
	core.PuregoSafeRegister(&xMessageMetricsGetDnsEnd, libs, "soup_message_metrics_get_dns_end")
	core.PuregoSafeRegister(&xMessageMetricsGetDnsStart, libs, "soup_message_metrics_get_dns_start")
	core.PuregoSafeRegister(&xMessageMetricsGetFetchStart, libs, "soup_message_metrics_get_fetch_start")
	core.PuregoSafeRegister(&xMessageMetricsGetRequestBodyBytesSent, libs, "soup_message_metrics_get_request_body_bytes_sent")
	core.PuregoSafeRegister(&xMessageMetricsGetRequestBodySize, libs, "soup_message_metrics_get_request_body_size")
	core.PuregoSafeRegister(&xMessageMetricsGetRequestHeaderBytesSent, libs, "soup_message_metrics_get_request_header_bytes_sent")
	core.PuregoSafeRegister(&xMessageMetricsGetRequestStart, libs, "soup_message_metrics_get_request_start")
	core.PuregoSafeRegister(&xMessageMetricsGetResponseBodyBytesReceived, libs, "soup_message_metrics_get_response_body_bytes_received")
	core.PuregoSafeRegister(&xMessageMetricsGetResponseBodySize, libs, "soup_message_metrics_get_response_body_size")
	core.PuregoSafeRegister(&xMessageMetricsGetResponseEnd, libs, "soup_message_metrics_get_response_end")
	core.PuregoSafeRegister(&xMessageMetricsGetResponseHeaderBytesReceived, libs, "soup_message_metrics_get_response_header_bytes_received")
	core.PuregoSafeRegister(&xMessageMetricsGetResponseStart, libs, "soup_message_metrics_get_response_start")
	core.PuregoSafeRegister(&xMessageMetricsGetTlsStart, libs, "soup_message_metrics_get_tls_start")

}
