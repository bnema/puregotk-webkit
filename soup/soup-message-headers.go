// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package soup

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// The callback passed to [method@MessageHeaders.foreach].
type MessageHeadersForeachFunc func(string, string, uintptr)

// The HTTP message headers associated with a request or response.
type MessageHeaders struct {
	_ structs.HostLayout
}

var xMessageHeadersGLibType func() types.GType

func MessageHeadersGLibType() types.GType {
	return xMessageHeadersGLibType()
}

func (x *MessageHeaders) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xNewMessageHeaders func(MessageHeadersType) *MessageHeaders

// Creates a #SoupMessageHeaders.
//
// ([class@Message] does this automatically for its own headers. You would only
// need to use this method if you are manually parsing or generating message
// headers.)
func NewMessageHeaders(TypeVar MessageHeadersType) *MessageHeaders {

	cret := xNewMessageHeaders(TypeVar)
	return cret
}

var xMessageHeadersAppend func(uintptr, string, string)

// Appends a new header with name @name and value @value to @hdrs.
//
// (If there is an existing header with name @name, then this creates a second
// one, which is only allowed for list-valued headers; see also
// [method@MessageHeaders.replace].)
//
// The caller is expected to make sure that @name and @value are
// syntactically correct.
func (x *MessageHeaders) Append(NameVar string, ValueVar string) {

	xMessageHeadersAppend(x.GoPointer(), NameVar, ValueVar)

}

var xMessageHeadersCleanConnectionHeaders func(uintptr)

// Removes all the headers listed in the Connection header.
func (x *MessageHeaders) CleanConnectionHeaders() {

	xMessageHeadersCleanConnectionHeaders(x.GoPointer())

}

var xMessageHeadersClear func(uintptr)

// Clears @hdrs.
func (x *MessageHeaders) Clear() {

	xMessageHeadersClear(x.GoPointer())

}

var xMessageHeadersForeach func(uintptr, uintptr, uintptr)

// Calls @func once for each header value in @hdrs.
//
// Beware that unlike [method@MessageHeaders.get_list], this processes the
// headers in exactly the way they were added, rather than
// concatenating multiple same-named headers into a single value.
// (This is intentional; it ensures that if you call
// [method@MessageHeaders.append] multiple times with the same name,
// then the I/O code will output multiple copies of the header when
// sending the message to the remote implementation, which may be
// required for interoperability in some cases.)
//
// You may not modify the headers from @func.
func (x *MessageHeaders) Foreach(FuncVar *MessageHeadersForeachFunc, UserDataVar uintptr) {

	var FuncVarRef uintptr
	if FuncVar != nil {
		FuncVarPtr := uintptr(unsafe.Pointer(FuncVar))
		if cbRefPtr, ok := glib.GetCallback(FuncVarPtr); ok {
			FuncVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *FuncVar
				cbFn(core.GoString(arg0), core.GoString(arg1), arg2)
			}
			FuncVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(FuncVarPtr, FuncVarRef, FuncVar)
		}
	}

	xMessageHeadersForeach(x.GoPointer(), FuncVarRef, UserDataVar)

}

var xMessageHeadersFreeRanges func(uintptr, *Range)

// Frees the array of ranges returned from [method@MessageHeaders.get_ranges].
func (x *MessageHeaders) FreeRanges(RangesVar *Range) {

	xMessageHeadersFreeRanges(x.GoPointer(), RangesVar)

}

var xMessageHeadersGetContentDisposition func(uintptr, *string, **glib.HashTable) bool

// Looks up the "Content-Disposition" header in @hdrs, parses it, and
// returns its value in *@disposition and *@params.
//
// @params can be %NULL if you are only interested in the disposition-type.
//
// In HTTP, the most common use of this header is to set a
// disposition-type of "attachment", to suggest to the browser that a
// response should be saved to disk rather than displayed in the
// browser. If @params contains a "filename" parameter, this is a
// suggestion of a filename to use. (If the parameter value in the
// header contains an absolute or relative path, libsoup will truncate
// it down to just the final path component, so you do not need to
// test this yourself.)
//
// Content-Disposition is also used in "multipart/form-data", however
// this is handled automatically by [struct@Multipart] and the associated
// form methods.
func (x *MessageHeaders) GetContentDisposition(DispositionVar *string, ParamsVar **glib.HashTable) bool {

	cret := xMessageHeadersGetContentDisposition(x.GoPointer(), DispositionVar, ParamsVar)
	return cret
}

var xMessageHeadersGetContentLength func(uintptr) int64

// Gets the message body length that @hdrs declare.
//
// This will only be non-0 if [method@MessageHeaders.get_encoding] returns
// %SOUP_ENCODING_CONTENT_LENGTH.
func (x *MessageHeaders) GetContentLength() int64 {

	cret := xMessageHeadersGetContentLength(x.GoPointer())
	return cret
}

var xMessageHeadersGetContentRange func(uintptr, *int64, *int64, *int64) bool

// Parses @hdrs's Content-Range header and returns it in @start,
// @end, and @total_length. If the total length field in the header
// was specified as "*", then @total_length will be set to -1.
func (x *MessageHeaders) GetContentRange(StartVar *int64, EndVar *int64, TotalLengthVar *int64) bool {

	cret := xMessageHeadersGetContentRange(x.GoPointer(), StartVar, EndVar, TotalLengthVar)
	return cret
}

var xMessageHeadersGetContentType func(uintptr, **glib.HashTable) string

// Looks up the "Content-Type" header in @hdrs, parses it, and returns
// its value in *@content_type and *@params.
//
// @params can be %NULL if you are only interested in the content type itself.
func (x *MessageHeaders) GetContentType(ParamsVar **glib.HashTable) string {

	cret := xMessageHeadersGetContentType(x.GoPointer(), ParamsVar)
	return cret
}

var xMessageHeadersGetEncoding func(uintptr) Encoding

// Gets the message body encoding that @hdrs declare.
//
// This may not always correspond to the encoding used on the wire; eg, a HEAD
// response may declare a Content-Length or Transfer-Encoding, but it will never
// actually include a body.
func (x *MessageHeaders) GetEncoding() Encoding {

	cret := xMessageHeadersGetEncoding(x.GoPointer())
	return cret
}

var xMessageHeadersGetExpectations func(uintptr) Expectation

// Gets the expectations declared by @hdrs's "Expect" header.
//
// Currently this will either be %SOUP_EXPECTATION_CONTINUE or
// %SOUP_EXPECTATION_UNRECOGNIZED.
func (x *MessageHeaders) GetExpectations() Expectation {

	cret := xMessageHeadersGetExpectations(x.GoPointer())
	return cret
}

var xMessageHeadersGetHeadersType func(uintptr) MessageHeadersType

// Gets the type of headers.
func (x *MessageHeaders) GetHeadersType() MessageHeadersType {

	cret := xMessageHeadersGetHeadersType(x.GoPointer())
	return cret
}

var xMessageHeadersGetList func(uintptr, string) string

// Gets the value of header @name in @hdrs.
//
// Use this for headers whose values are comma-delimited lists, and which are
// therefore allowed to appear multiple times in the headers. For
// non-list-valued headers, use [method@MessageHeaders.get_one].
//
// If @name appears multiple times in @hdrs,
// [method@MessageHeaders.get_list] will concatenate all of the values
// together, separated by commas. This is sometimes awkward to parse
// (eg, WWW-Authenticate, Set-Cookie), but you have to be able to deal
// with it anyway, because the HTTP spec explicitly states that this
// transformation is allowed, and so an upstream proxy could do the
// same thing.
func (x *MessageHeaders) GetList(NameVar string) string {

	cret := xMessageHeadersGetList(x.GoPointer(), NameVar)
	return cret
}

var xMessageHeadersGetOne func(uintptr, string) string

// Gets the value of header @name in @hdrs.
//
// Use this for headers whose values are *not* comma-delimited lists, and which
// therefore can only appear at most once in the headers. For list-valued
// headers, use [method@MessageHeaders.get_list].
//
// If @hdrs does erroneously contain multiple copies of the header, it
// is not defined which one will be returned. (Ideally, it will return
// whichever one makes libsoup most compatible with other HTTP
// implementations.)
func (x *MessageHeaders) GetOne(NameVar string) string {

	cret := xMessageHeadersGetOne(x.GoPointer(), NameVar)
	return cret
}

var xMessageHeadersGetRanges func(uintptr, int64, *uintptr, *int) bool

// Parses @hdrs's Range header and returns an array of the requested
// byte ranges.
//
// The returned array must be freed with [method@MessageHeaders.free_ranges].
//
// If @total_length is non-0, its value will be used to adjust the
// returned ranges to have explicit start and end values, and the
// returned ranges will be sorted and non-overlapping. If
// @total_length is 0, then some ranges may have an end value of -1,
// as described under [struct@Range], and some of the ranges may be
// redundant.
//
// Beware that even if given a @total_length, this function does not
// check that the ranges are satisfiable.
//
// #SoupServer has built-in handling for range requests. If your
// server handler returns a %SOUP_STATUS_OK response containing the
// complete response body (rather than pausing the message and
// returning some of the response body later), and there is a Range
// header in the request, then libsoup will automatically convert the
// response to a %SOUP_STATUS_PARTIAL_CONTENT response containing only
// the range(s) requested by the client.
//
// The only time you need to process the Range header yourself is if
// either you need to stream the response body rather than returning
// it all at once, or you do not already have the complete response
// body available, and only want to generate the parts that were
// actually requested by the client.
func (x *MessageHeaders) GetRanges(TotalLengthVar int64, RangesVar *uintptr, LengthVar *int) bool {

	cret := xMessageHeadersGetRanges(x.GoPointer(), TotalLengthVar, RangesVar, LengthVar)
	return cret
}

var xMessageHeadersHeaderContains func(uintptr, string, string) bool

// Checks whether the list-valued header @name is present in @hdrs,
// and contains a case-insensitive match for @token.
//
// (If @name is present in @hdrs, then this is equivalent to calling
// [func@header_contains] on its value.)
func (x *MessageHeaders) HeaderContains(NameVar string, TokenVar string) bool {

	cret := xMessageHeadersHeaderContains(x.GoPointer(), NameVar, TokenVar)
	return cret
}

var xMessageHeadersHeaderEquals func(uintptr, string, string) bool

// Checks whether the header @name is present in @hdrs and is
// (case-insensitively) equal to @value.
func (x *MessageHeaders) HeaderEquals(NameVar string, ValueVar string) bool {

	cret := xMessageHeadersHeaderEquals(x.GoPointer(), NameVar, ValueVar)
	return cret
}

var xMessageHeadersRef func(uintptr) *MessageHeaders

// Atomically increments the reference count of @hdrs by one.
func (x *MessageHeaders) Ref() *MessageHeaders {

	cret := xMessageHeadersRef(x.GoPointer())
	return cret
}

var xMessageHeadersRemove func(uintptr, string)

// Removes @name from @hdrs.
//
// If there are multiple values for @name, they are all removed.
func (x *MessageHeaders) Remove(NameVar string) {

	xMessageHeadersRemove(x.GoPointer(), NameVar)

}

var xMessageHeadersReplace func(uintptr, string, string)

// Replaces the value of the header @name in @hdrs with @value.
//
// See also [method@MessageHeaders.append].
//
// The caller is expected to make sure that @name and @value are
// syntactically correct.
func (x *MessageHeaders) Replace(NameVar string, ValueVar string) {

	xMessageHeadersReplace(x.GoPointer(), NameVar, ValueVar)

}

var xMessageHeadersSetContentDisposition func(uintptr, string, *glib.HashTable)

// Sets the "Content-Disposition" header in @hdrs to @disposition,
// optionally with additional parameters specified in @params.
//
// See [method@MessageHeaders.get_content_disposition] for a discussion
// of how Content-Disposition is used in HTTP.
func (x *MessageHeaders) SetContentDisposition(DispositionVar string, ParamsVar *glib.HashTable) {

	xMessageHeadersSetContentDisposition(x.GoPointer(), DispositionVar, ParamsVar)

}

var xMessageHeadersSetContentLength func(uintptr, int64)

// Sets the message body length that @hdrs will declare, and sets
// @hdrs's encoding to %SOUP_ENCODING_CONTENT_LENGTH.
//
// You do not normally need to call this; if @hdrs is set to use
// Content-Length encoding, libsoup will automatically set its
// Content-Length header for you immediately before sending the
// headers. One situation in which this method is useful is when
// generating the response to a HEAD request; Calling
// [method@MessageHeaders.set_content_length] allows you to put the
// correct content length into the response without needing to waste
// memory by filling in a response body which won't actually be sent.
func (x *MessageHeaders) SetContentLength(ContentLengthVar int64) {

	xMessageHeadersSetContentLength(x.GoPointer(), ContentLengthVar)

}

var xMessageHeadersSetContentRange func(uintptr, int64, int64, int64)

// Sets @hdrs's Content-Range header according to the given values.
//
// (Note that @total_length is the total length of the entire resource
// that this is a range of, not simply @end - @start + 1.)
//
// [class@Server] has built-in handling for range requests, and you do
// not normally need to call this function youself. See
// [method@MessageHeaders.get_ranges] for more details.
func (x *MessageHeaders) SetContentRange(StartVar int64, EndVar int64, TotalLengthVar int64) {

	xMessageHeadersSetContentRange(x.GoPointer(), StartVar, EndVar, TotalLengthVar)

}

var xMessageHeadersSetContentType func(uintptr, string, *glib.HashTable)

// Sets the "Content-Type" header in @hdrs to @content_type.
//
// Accepts additional parameters specified in @params.
func (x *MessageHeaders) SetContentType(ContentTypeVar string, ParamsVar *glib.HashTable) {

	xMessageHeadersSetContentType(x.GoPointer(), ContentTypeVar, ParamsVar)

}

var xMessageHeadersSetEncoding func(uintptr, Encoding)

// Sets the message body encoding that @hdrs will declare.
//
// In particular, you should use this if you are going to send a request or
// response in chunked encoding.
func (x *MessageHeaders) SetEncoding(EncodingVar Encoding) {

	xMessageHeadersSetEncoding(x.GoPointer(), EncodingVar)

}

var xMessageHeadersSetExpectations func(uintptr, Expectation)

// Sets @hdrs's "Expect" header according to @expectations.
//
// Currently %SOUP_EXPECTATION_CONTINUE is the only known expectation
// value. You should set this value on a request if you are sending a
// large message body (eg, via POST or PUT), and want to give the
// server a chance to reject the request after seeing just the headers
// (eg, because it will require authentication before allowing you to
// post, or because you're POSTing to a URL that doesn't exist). This
// saves you from having to transmit the large request body when the
// server is just going to ignore it anyway.
func (x *MessageHeaders) SetExpectations(ExpectationsVar Expectation) {

	xMessageHeadersSetExpectations(x.GoPointer(), ExpectationsVar)

}

var xMessageHeadersSetRange func(uintptr, int64, int64)

// Sets @hdrs's Range header to request the indicated range.
//
// @start and @end are interpreted as in a [struct@Range].
//
// If you need to request multiple ranges, use
// [method@MessageHeaders.set_ranges].
func (x *MessageHeaders) SetRange(StartVar int64, EndVar int64) {

	xMessageHeadersSetRange(x.GoPointer(), StartVar, EndVar)

}

var xMessageHeadersSetRanges func(uintptr, *Range, int)

// Sets @hdrs's Range header to request the indicated ranges.
//
// If you only want to request a single range, you can use
// [method@MessageHeaders.set_range].
func (x *MessageHeaders) SetRanges(RangesVar *Range, LengthVar int) {

	xMessageHeadersSetRanges(x.GoPointer(), RangesVar, LengthVar)

}

var xMessageHeadersUnref func(uintptr)

// Atomically decrements the reference count of @hdrs by one.
//
// When the reference count reaches zero, the resources allocated by
// @hdrs are freed
func (x *MessageHeaders) Unref() {

	xMessageHeadersUnref(x.GoPointer())

}

// An opaque type used to iterate over a %SoupMessageHeaders
// structure.
//
// After intializing the iterator with [func@MessageHeadersIter.init], call
// [method@MessageHeadersIter.next] to fetch data from it.
//
// You may not modify the headers while iterating over them.
type MessageHeadersIter struct {
	_ structs.HostLayout

	Dummy [3]uintptr
}

func (x *MessageHeadersIter) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Represents a byte range as used in the Range header.
//
// If @end is non-negative, then @start and @end represent the bounds
// of of the range, counting from 0. (Eg, the first 500 bytes would be
// represented as @start = 0 and @end = 499.)
//
// If @end is -1 and @start is non-negative, then this represents a
// range starting at @start and ending with the last byte of the
// requested resource body. (Eg, all but the first 500 bytes would be
// @start = 500, and @end = -1.)
//
// If @end is -1 and @start is negative, then it represents a "suffix
// range", referring to the last -@start bytes of the resource body.
// (Eg, the last 500 bytes would be @start = -500 and @end = -1.)
type Range struct {
	_ structs.HostLayout

	Start int64

	End int64
}

func (x *Range) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Represents the parsed value of the "Expect" header.
type Expectation int

var xExpectationGLibType func() types.GType

func ExpectationGLibType() types.GType {
	return xExpectationGLibType()
}

const (

	// any unrecognized expectation
	ExpectationUnrecognizedValue Expectation = 1
	// "100-continue"
	ExpectationContinueValue Expectation = 2
)

// How a message body is encoded for transport
type Encoding int

var xEncodingGLibType func() types.GType

func EncodingGLibType() types.GType {
	return xEncodingGLibType()
}

const (

	// unknown / error
	EncodingUnrecognizedValue Encoding = 0
	// no body is present (which is not the same as a
	//   0-length body, and only occurs in certain places)
	EncodingNoneValue Encoding = 1
	// Content-Length encoding
	EncodingContentLengthValue Encoding = 2
	// Response body ends when the connection is closed
	EncodingEofValue Encoding = 3
	// chunked encoding (currently only supported
	//   for response)
	EncodingChunkedValue Encoding = 4
	// multipart/byteranges (Reserved for future
	//   use: NOT CURRENTLY IMPLEMENTED)
	EncodingByterangesValue Encoding = 5
)

// Value passed to [ctor@MessageHeaders.new] to set certain default
// behaviors.
type MessageHeadersType int

var xMessageHeadersTypeGLibType func() types.GType

func MessageHeadersTypeGLibType() types.GType {
	return xMessageHeadersTypeGLibType()
}

const (

	// request headers
	MessageHeadersRequestValue MessageHeadersType = 0
	// response headers
	MessageHeadersResponseValue MessageHeadersType = 1
	// multipart body part headers
	MessageHeadersMultipartValue MessageHeadersType = 2
)

var xMessageHeadersIterInit func(*MessageHeadersIter, *MessageHeaders)

// Initializes @iter for iterating @hdrs.
func MessageHeadersIterInit(IterVar *MessageHeadersIter, HdrsVar *MessageHeaders) {

	xMessageHeadersIterInit(IterVar, HdrsVar)

}

var xMessageHeadersIterNext func(*MessageHeadersIter, *string, *string) bool

// Yields the next name/value pair in the [struct@MessageHeaders] being
// iterated by @iter.
//
// If @iter has already yielded the last header, then
// [method@MessageHeadersIter.next] will return %FALSE and @name and @value
// will be unchanged.
func MessageHeadersIterNext(IterVar *MessageHeadersIter, NameVar *string, ValueVar *string) bool {

	cret := xMessageHeadersIterNext(IterVar, NameVar, ValueVar)
	return cret
}

func init() {
	core.SetPackageName("SOUP", "libsoup-3.0")
	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("SOUP") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xExpectationGLibType, libs, "soup_expectation_get_type")

	core.PuregoSafeRegister(&xEncodingGLibType, libs, "soup_encoding_get_type")

	core.PuregoSafeRegister(&xMessageHeadersTypeGLibType, libs, "soup_message_headers_type_get_type")

	core.PuregoSafeRegister(&xMessageHeadersIterInit, libs, "soup_message_headers_iter_init")
	core.PuregoSafeRegister(&xMessageHeadersIterNext, libs, "soup_message_headers_iter_next")

	core.PuregoSafeRegister(&xMessageHeadersGLibType, libs, "soup_message_headers_get_type")

	core.PuregoSafeRegister(&xNewMessageHeaders, libs, "soup_message_headers_new")

	core.PuregoSafeRegister(&xMessageHeadersAppend, libs, "soup_message_headers_append")
	core.PuregoSafeRegister(&xMessageHeadersCleanConnectionHeaders, libs, "soup_message_headers_clean_connection_headers")
	core.PuregoSafeRegister(&xMessageHeadersClear, libs, "soup_message_headers_clear")
	core.PuregoSafeRegister(&xMessageHeadersForeach, libs, "soup_message_headers_foreach")
	core.PuregoSafeRegister(&xMessageHeadersFreeRanges, libs, "soup_message_headers_free_ranges")
	core.PuregoSafeRegister(&xMessageHeadersGetContentDisposition, libs, "soup_message_headers_get_content_disposition")
	core.PuregoSafeRegister(&xMessageHeadersGetContentLength, libs, "soup_message_headers_get_content_length")
	core.PuregoSafeRegister(&xMessageHeadersGetContentRange, libs, "soup_message_headers_get_content_range")
	core.PuregoSafeRegister(&xMessageHeadersGetContentType, libs, "soup_message_headers_get_content_type")
	core.PuregoSafeRegister(&xMessageHeadersGetEncoding, libs, "soup_message_headers_get_encoding")
	core.PuregoSafeRegister(&xMessageHeadersGetExpectations, libs, "soup_message_headers_get_expectations")
	core.PuregoSafeRegister(&xMessageHeadersGetHeadersType, libs, "soup_message_headers_get_headers_type")
	core.PuregoSafeRegister(&xMessageHeadersGetList, libs, "soup_message_headers_get_list")
	core.PuregoSafeRegister(&xMessageHeadersGetOne, libs, "soup_message_headers_get_one")
	core.PuregoSafeRegister(&xMessageHeadersGetRanges, libs, "soup_message_headers_get_ranges")
	core.PuregoSafeRegister(&xMessageHeadersHeaderContains, libs, "soup_message_headers_header_contains")
	core.PuregoSafeRegister(&xMessageHeadersHeaderEquals, libs, "soup_message_headers_header_equals")
	core.PuregoSafeRegister(&xMessageHeadersRef, libs, "soup_message_headers_ref")
	core.PuregoSafeRegister(&xMessageHeadersRemove, libs, "soup_message_headers_remove")
	core.PuregoSafeRegister(&xMessageHeadersReplace, libs, "soup_message_headers_replace")
	core.PuregoSafeRegister(&xMessageHeadersSetContentDisposition, libs, "soup_message_headers_set_content_disposition")
	core.PuregoSafeRegister(&xMessageHeadersSetContentLength, libs, "soup_message_headers_set_content_length")
	core.PuregoSafeRegister(&xMessageHeadersSetContentRange, libs, "soup_message_headers_set_content_range")
	core.PuregoSafeRegister(&xMessageHeadersSetContentType, libs, "soup_message_headers_set_content_type")
	core.PuregoSafeRegister(&xMessageHeadersSetEncoding, libs, "soup_message_headers_set_encoding")
	core.PuregoSafeRegister(&xMessageHeadersSetExpectations, libs, "soup_message_headers_set_expectations")
	core.PuregoSafeRegister(&xMessageHeadersSetRange, libs, "soup_message_headers_set_range")
	core.PuregoSafeRegister(&xMessageHeadersSetRanges, libs, "soup_message_headers_set_ranges")
	core.PuregoSafeRegister(&xMessageHeadersUnref, libs, "soup_message_headers_unref")

}
