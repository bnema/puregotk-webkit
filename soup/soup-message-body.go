// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package soup

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// #SoupMessageBody represents the request or response body of a
// [class@Message].
//
// Note that while @length always reflects the full length of the
// message body, @data is normally %NULL, and will only be filled in
// after [method@MessageBody.flatten] is called. For client-side
// messages, this automatically happens for the response body after it
// has been fully read. Likewise, for server-side
// messages, the request body is automatically filled in after being
// read.
//
// As an added bonus, when @data is filled in, it is always terminated
// with a `\0` byte (which is not reflected in @length).
type MessageBody struct {
	_ structs.HostLayout

	Data uintptr

	Length int64
}

var xMessageBodyGLibType func() types.GType

func MessageBodyGLibType() types.GType {
	return xMessageBodyGLibType()
}

func (x *MessageBody) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

var xNewMessageBody func() *MessageBody

// Creates a new #SoupMessageBody.
//
// [class@Message] uses this internally; you
// will not normally need to call it yourself.
func NewMessageBody() *MessageBody {

	cret := xNewMessageBody()
	return cret
}

var xMessageBodyAppend func(uintptr, MemoryUse, []byte, uint)

// Appends @length bytes from @data to @body according to @use.
func (x *MessageBody) Append(UseVar MemoryUse, DataVar []byte, LengthVar uint) {

	xMessageBodyAppend(x.GoPointer(), UseVar, DataVar, LengthVar)

}

var xMessageBodyAppendBytes func(uintptr, *glib.Bytes)

// Appends the data from @buffer to @body.
func (x *MessageBody) AppendBytes(BufferVar *glib.Bytes) {

	xMessageBodyAppendBytes(x.GoPointer(), BufferVar)

}

var xMessageBodyAppendTake func(uintptr, []byte, uint)

// Appends @length bytes from @data to @body.
//
// This function is exactly equivalent to [method@MessageBody.append]
// with %SOUP_MEMORY_TAKE as second argument; it exists mainly for
// convenience and simplifying language bindings.
func (x *MessageBody) AppendTake(DataVar []byte, LengthVar uint) {

	xMessageBodyAppendTake(x.GoPointer(), DataVar, LengthVar)

}

var xMessageBodyComplete func(uintptr)

// Tags @body as being complete.
//
// Call this when using chunked encoding after you have appended the last chunk.
func (x *MessageBody) Complete() {

	xMessageBodyComplete(x.GoPointer())

}

var xMessageBodyFlatten func(uintptr) *glib.Bytes

// Fills in @body's data field with a buffer containing all of the
// data in @body.
//
// Adds an additional `\0` byte not counted by @body's
// length field.
func (x *MessageBody) Flatten() *glib.Bytes {

	cret := xMessageBodyFlatten(x.GoPointer())
	return cret
}

var xMessageBodyGetAccumulate func(uintptr) bool

// Gets the accumulate flag on @body.
//
// See [method@MessageBody.set_accumulate. for details.
func (x *MessageBody) GetAccumulate() bool {

	cret := xMessageBodyGetAccumulate(x.GoPointer())
	return cret
}

var xMessageBodyGetChunk func(uintptr, int64) *glib.Bytes

// Gets a [struct@GLib.Bytes] containing data from @body starting at @offset.
//
// The size of the returned chunk is unspecified. You can iterate
// through the entire body by first calling
// [method@MessageBody.get_chunk] with an offset of 0, and then on each
// successive call, increment the offset by the length of the
// previously-returned chunk.
//
// If @offset is greater than or equal to the total length of @body,
// then the return value depends on whether or not
// [method@MessageBody.complete] has been called or not; if it has,
// then [method@MessageBody.get_chunk] will return a 0-length chunk
// (indicating the end of @body). If it has not, then
// [method@MessageBody.get_chunk] will return %NULL (indicating that
// @body may still potentially have more data, but that data is not
// currently available).
func (x *MessageBody) GetChunk(OffsetVar int64) *glib.Bytes {

	cret := xMessageBodyGetChunk(x.GoPointer(), OffsetVar)
	return cret
}

var xMessageBodyGotChunk func(uintptr, *glib.Bytes)

// Handles the #SoupMessageBody part of receiving a chunk of data from
// the network.
//
// Normally this means appending @chunk to @body, exactly as with
// [method@MessageBody.append_bytes], but if you have set @body's accumulate
// flag to %FALSE, then that will not happen.
//
// This is a low-level method which you should not normally need to
// use.
func (x *MessageBody) GotChunk(ChunkVar *glib.Bytes) {

	xMessageBodyGotChunk(x.GoPointer(), ChunkVar)

}

var xMessageBodyRef func(uintptr) *MessageBody

// Atomically increments the reference count of @body by one.
func (x *MessageBody) Ref() *MessageBody {

	cret := xMessageBodyRef(x.GoPointer())
	return cret
}

var xMessageBodySetAccumulate func(uintptr, bool)

// Sets or clears the accumulate flag on @body.
//
// (The default value is %TRUE.) If set to %FALSE, @body's data field will not
// be filled in after the body is fully sent/received, and the chunks that make
// up @body may be discarded when they are no longer needed.
//
// If you set the flag to %FALSE on the [class@Message] request_body of a
// client-side message, it will block the accumulation of chunks into
// @body's data field, but it will not normally cause the chunks to
// be discarded after being written like in the server-side
// [class@Message] response_body case, because the request body needs to
// be kept around in case the request needs to be sent a second time
// due to redirection or authentication.
func (x *MessageBody) SetAccumulate(AccumulateVar bool) {

	xMessageBodySetAccumulate(x.GoPointer(), AccumulateVar)

}

var xMessageBodyTruncate func(uintptr)

// Deletes all of the data in @body.
func (x *MessageBody) Truncate() {

	xMessageBodyTruncate(x.GoPointer())

}

var xMessageBodyUnref func(uintptr)

// Atomically decrements the reference count of @body by one.
//
// When the reference count reaches zero, the resources allocated by
// @body are freed
func (x *MessageBody) Unref() {

	xMessageBodyUnref(x.GoPointer())

}

var xMessageBodyWroteChunk func(uintptr, *glib.Bytes)

// Handles the #SoupMessageBody part of writing a chunk of data to the
// network.
//
// Normally this is a no-op, but if you have set @body's accumulate flag to
// %FALSE, then this will cause @chunk to be discarded to free up memory.
//
// This is a low-level method which you should not need to use, and
// there are further restrictions on its proper use which are not
// documented here.
func (x *MessageBody) WroteChunk(ChunkVar *glib.Bytes) {

	xMessageBodyWroteChunk(x.GoPointer(), ChunkVar)

}

// The lifetime of the memory being passed.
type MemoryUse int

var xMemoryUseGLibType func() types.GType

func MemoryUseGLibType() types.GType {
	return xMemoryUseGLibType()
}

const (

	// The memory is statically allocated and
	//   constant; libsoup can use the passed-in buffer directly and not
	//   need to worry about it being modified or freed.
	MemoryStaticValue MemoryUse = 0
	// The caller has allocated the memory and libsoup
	//   will assume ownership of it and free it with [func@GLib.free].
	MemoryTakeValue MemoryUse = 1
	// The passed-in data belongs to the caller and
	//   libsoup will copy it into new memory leaving the caller free
	//   to reuse the original memory.
	MemoryCopyValue MemoryUse = 2
)

func init() {
	core.SetPackageName("SOUP", "libsoup-3.0")
	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("SOUP") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xMemoryUseGLibType, libs, "soup_memory_use_get_type")

	core.PuregoSafeRegister(&xMessageBodyGLibType, libs, "soup_message_body_get_type")

	core.PuregoSafeRegister(&xNewMessageBody, libs, "soup_message_body_new")

	core.PuregoSafeRegister(&xMessageBodyAppend, libs, "soup_message_body_append")
	core.PuregoSafeRegister(&xMessageBodyAppendBytes, libs, "soup_message_body_append_bytes")
	core.PuregoSafeRegister(&xMessageBodyAppendTake, libs, "soup_message_body_append_take")
	core.PuregoSafeRegister(&xMessageBodyComplete, libs, "soup_message_body_complete")
	core.PuregoSafeRegister(&xMessageBodyFlatten, libs, "soup_message_body_flatten")
	core.PuregoSafeRegister(&xMessageBodyGetAccumulate, libs, "soup_message_body_get_accumulate")
	core.PuregoSafeRegister(&xMessageBodyGetChunk, libs, "soup_message_body_get_chunk")
	core.PuregoSafeRegister(&xMessageBodyGotChunk, libs, "soup_message_body_got_chunk")
	core.PuregoSafeRegister(&xMessageBodyRef, libs, "soup_message_body_ref")
	core.PuregoSafeRegister(&xMessageBodySetAccumulate, libs, "soup_message_body_set_accumulate")
	core.PuregoSafeRegister(&xMessageBodyTruncate, libs, "soup_message_body_truncate")
	core.PuregoSafeRegister(&xMessageBodyUnref, libs, "soup_message_body_unref")
	core.PuregoSafeRegister(&xMessageBodyWroteChunk, libs, "soup_message_body_wrote_chunk")

}
