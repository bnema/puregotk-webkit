// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package soup

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type SessionClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass

	xRequestQueued uintptr

	xRequestUnqueued uintptr

	xSoupReserved1 uintptr

	xSoupReserved2 uintptr

	xSoupReserved3 uintptr

	xSoupReserved4 uintptr

	xSoupReserved5 uintptr

	xSoupReserved6 uintptr

	xSoupReserved7 uintptr

	xSoupReserved8 uintptr
}

func (x *SessionClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideRequestQueued sets the callback function.
func (x *SessionClass) OverrideRequestQueued(cb func(*Session, *Message)) {
	if cb == nil {
		x.xRequestQueued = 0
	} else {
		x.xRequestQueued = purego.NewCallback(func(SessionVarp uintptr, MsgVarp uintptr) {
			cb(SessionNewFromInternalPtr(SessionVarp), MessageNewFromInternalPtr(MsgVarp))
		})
	}
}

// GetRequestQueued gets the callback function.
func (x *SessionClass) GetRequestQueued() func(*Session, *Message) {
	if x.xRequestQueued == 0 {
		return nil
	}
	var rawCallback func(SessionVarp uintptr, MsgVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xRequestQueued)
	return func(SessionVar *Session, MsgVar *Message) {
		rawCallback(SessionVar.GoPointer(), MsgVar.GoPointer())
	}
}

// OverrideRequestUnqueued sets the callback function.
func (x *SessionClass) OverrideRequestUnqueued(cb func(*Session, *Message)) {
	if cb == nil {
		x.xRequestUnqueued = 0
	} else {
		x.xRequestUnqueued = purego.NewCallback(func(SessionVarp uintptr, MsgVarp uintptr) {
			cb(SessionNewFromInternalPtr(SessionVarp), MessageNewFromInternalPtr(MsgVarp))
		})
	}
}

// GetRequestUnqueued gets the callback function.
func (x *SessionClass) GetRequestUnqueued() func(*Session, *Message) {
	if x.xRequestUnqueued == 0 {
		return nil
	}
	var rawCallback func(SessionVarp uintptr, MsgVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xRequestUnqueued)
	return func(SessionVar *Session, MsgVar *Message) {
		rawCallback(SessionVar.GoPointer(), MsgVar.GoPointer())
	}
}

// OverrideSoupReserved1 sets the callback function.
func (x *SessionClass) OverrideSoupReserved1(cb func()) {
	if cb == nil {
		x.xSoupReserved1 = 0
	} else {
		x.xSoupReserved1 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetSoupReserved1 gets the callback function.
func (x *SessionClass) GetSoupReserved1() func() {
	if x.xSoupReserved1 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xSoupReserved1)
	return func() {
		rawCallback()
	}
}

// OverrideSoupReserved2 sets the callback function.
func (x *SessionClass) OverrideSoupReserved2(cb func()) {
	if cb == nil {
		x.xSoupReserved2 = 0
	} else {
		x.xSoupReserved2 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetSoupReserved2 gets the callback function.
func (x *SessionClass) GetSoupReserved2() func() {
	if x.xSoupReserved2 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xSoupReserved2)
	return func() {
		rawCallback()
	}
}

// OverrideSoupReserved3 sets the callback function.
func (x *SessionClass) OverrideSoupReserved3(cb func()) {
	if cb == nil {
		x.xSoupReserved3 = 0
	} else {
		x.xSoupReserved3 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetSoupReserved3 gets the callback function.
func (x *SessionClass) GetSoupReserved3() func() {
	if x.xSoupReserved3 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xSoupReserved3)
	return func() {
		rawCallback()
	}
}

// OverrideSoupReserved4 sets the callback function.
func (x *SessionClass) OverrideSoupReserved4(cb func()) {
	if cb == nil {
		x.xSoupReserved4 = 0
	} else {
		x.xSoupReserved4 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetSoupReserved4 gets the callback function.
func (x *SessionClass) GetSoupReserved4() func() {
	if x.xSoupReserved4 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xSoupReserved4)
	return func() {
		rawCallback()
	}
}

// OverrideSoupReserved5 sets the callback function.
func (x *SessionClass) OverrideSoupReserved5(cb func()) {
	if cb == nil {
		x.xSoupReserved5 = 0
	} else {
		x.xSoupReserved5 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetSoupReserved5 gets the callback function.
func (x *SessionClass) GetSoupReserved5() func() {
	if x.xSoupReserved5 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xSoupReserved5)
	return func() {
		rawCallback()
	}
}

// OverrideSoupReserved6 sets the callback function.
func (x *SessionClass) OverrideSoupReserved6(cb func()) {
	if cb == nil {
		x.xSoupReserved6 = 0
	} else {
		x.xSoupReserved6 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetSoupReserved6 gets the callback function.
func (x *SessionClass) GetSoupReserved6() func() {
	if x.xSoupReserved6 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xSoupReserved6)
	return func() {
		rawCallback()
	}
}

// OverrideSoupReserved7 sets the callback function.
func (x *SessionClass) OverrideSoupReserved7(cb func()) {
	if cb == nil {
		x.xSoupReserved7 = 0
	} else {
		x.xSoupReserved7 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetSoupReserved7 gets the callback function.
func (x *SessionClass) GetSoupReserved7() func() {
	if x.xSoupReserved7 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xSoupReserved7)
	return func() {
		rawCallback()
	}
}

// OverrideSoupReserved8 sets the callback function.
func (x *SessionClass) OverrideSoupReserved8(cb func()) {
	if cb == nil {
		x.xSoupReserved8 = 0
	} else {
		x.xSoupReserved8 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetSoupReserved8 gets the callback function.
func (x *SessionClass) GetSoupReserved8() func() {
	if x.xSoupReserved8 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xSoupReserved8)
	return func() {
		rawCallback()
	}
}

// A #SoupSession error.
type SessionError int

var xSessionErrorGLibType func() types.GType

func SessionErrorGLibType() types.GType {
	return xSessionErrorGLibType()
}

const (

	// the server's response could not
	//   be parsed
	SessionErrorParsingValue SessionError = 0
	// the server's response was in an
	//   unsupported format
	SessionErrorEncodingValue SessionError = 1
	// the message has been redirected
	//   too many times
	SessionErrorTooManyRedirectsValue SessionError = 2
	// the message has been restarted
	//   too many times
	SessionErrorTooManyRestartsValue SessionError = 3
	// failed to redirect message because
	//   Location header was missing or empty in response
	SessionErrorRedirectNoLocationValue SessionError = 4
	// failed to redirect message because
	//   Location header contains an invalid URI
	SessionErrorRedirectBadUriValue SessionError = 5
	// the message is already in the
	//   session queue. Messages can only be reused after unqueued.
	SessionErrorMessageAlreadyInQueueValue SessionError = 6
)

var xSessionErrorQuark func() glib.Quark

// Registers error quark for SoupSession if needed.
func SessionErrorQuark() glib.Quark {

	cret := xSessionErrorQuark()
	return cret
}

// Soup session state object.
//
// #SoupSession is the object that controls client-side HTTP. A
// #SoupSession encapsulates all of the state that libsoup is keeping
// on behalf of your program; cached HTTP connections, authentication
// information, etc. It also keeps track of various global options
// and features that you are using.
//
// Most applications will only need a single #SoupSession; the primary
// reason you might need multiple sessions is if you need to have
// multiple independent authentication contexts. (Eg, you are
// connecting to a server and authenticating as two different users at
// different times; the easiest way to ensure that each [class@Message]
// is sent with the authentication information you intended is to use
// one session for the first user, and a second session for the other
// user.)
//
// Additional #SoupSession functionality is provided by
// [iface@SessionFeature] objects, which can be added to a session with
// [method@Session.add_feature] or [method@Session.add_feature_by_type]
// For example, [class@Logger] provides support for
// logging HTTP traffic, [class@ContentDecoder] provides support for
// compressed response handling, and [class@ContentSniffer] provides
// support for HTML5-style response body content sniffing.
// Additionally, subtypes of [class@Auth] can be added
// as features, to add support for additional authentication types.
//
// All `SoupSession`s are created with a [class@AuthManager], and support
// for %SOUP_TYPE_AUTH_BASIC and %SOUP_TYPE_AUTH_DIGEST. Additionally,
// sessions using the plain #SoupSession class (rather than one of its deprecated
// subtypes) have a [class@ContentDecoder] by default.
//
// Note that all async methods will invoke their callbacks on the thread-default
// context at the time of the function call.
type Session struct {
	gobject.Object
}

var xSessionGLibType func() types.GType

func SessionGLibType() types.GType {
	return xSessionGLibType()
}

func SessionNewFromInternalPtr(ptr uintptr) *Session {
	cls := &Session{}
	cls.Ptr = ptr
	return cls
}

var xNewSession func() uintptr

// Creates a #SoupSession with the default options.
func NewSession() *Session {
	var cls *Session

	cret := xNewSession()

	if cret == 0 {
		return nil
	}
	cls = &Session{}
	cls.Ptr = cret
	return cls
}

var xNewSessionWithOptions func(string, ...interface{}) uintptr

// Creates a #SoupSession with the specified options.
func NewSessionWithOptions(Optname1Var string, varArgs ...interface{}) *Session {
	var cls *Session

	cret := xNewSessionWithOptions(Optname1Var, varArgs...)

	if cret == 0 {
		return nil
	}
	cls = &Session{}
	cls.Ptr = cret
	return cls
}

var xSessionAbort func(uintptr)

// Cancels all pending requests in @session and closes all idle
// persistent connections.
func (x *Session) Abort() {

	xSessionAbort(x.GoPointer())

}

var xSessionAddFeature func(uintptr, uintptr)

// Adds @feature's functionality to @session. You cannot add multiple
// features of the same [alias@GObject.Type] to a session.
//
// See the main #SoupSession documentation for information on what
// features are present in sessions by default.
func (x *Session) AddFeature(FeatureVar SessionFeature) {

	xSessionAddFeature(x.GoPointer(), FeatureVar.GoPointer())

}

var xSessionAddFeatureByType func(uintptr, types.GType)

// If @feature_type is the type of a class that implements
// [iface@SessionFeature], this creates a new feature of that type and
// adds it to @session as with [method@Session.add_feature]. You can use
// this when you don't need to customize the new feature in any way.
// Adding multiple features of the same @feature_type is not allowed.
//
// If @feature_type is not a [iface@SessionFeature] type, this gives each
// existing feature on @session the chance to accept @feature_type as
// a "subfeature". This can be used to add new [class@Auth] types, for instance.
//
// See the main #SoupSession documentation for information on what
// features are present in sessions by default.
func (x *Session) AddFeatureByType(FeatureTypeVar types.GType) {

	xSessionAddFeatureByType(x.GoPointer(), FeatureTypeVar)

}

var xSessionGetAcceptLanguage func(uintptr) string

// Get the value used by @session for the "Accept-Language" header on new
// requests.
func (x *Session) GetAcceptLanguage() string {

	cret := xSessionGetAcceptLanguage(x.GoPointer())
	return cret
}

var xSessionGetAcceptLanguageAuto func(uintptr) bool

// Gets whether @session automatically sets the "Accept-Language" header on new
// requests.
func (x *Session) GetAcceptLanguageAuto() bool {

	cret := xSessionGetAcceptLanguageAuto(x.GoPointer())
	return cret
}

var xSessionGetAsyncResultMessage func(uintptr, uintptr) uintptr

// Gets the [class@Message] of the @result asynchronous operation This is useful
// to get the [class@Message] of an asynchronous operation started by @session
// from its [callback@Gio.AsyncReadyCallback].
func (x *Session) GetAsyncResultMessage(ResultVar gio.AsyncResult) *Message {
	var cls *Message

	cret := xSessionGetAsyncResultMessage(x.GoPointer(), ResultVar.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Message{}
	cls.Ptr = cret
	return cls
}

var xSessionGetFeature func(uintptr, types.GType) uintptr

// Gets the feature in @session of type @feature_type.
func (x *Session) GetFeature(FeatureTypeVar types.GType) *SessionFeatureBase {
	var cls *SessionFeatureBase

	cret := xSessionGetFeature(x.GoPointer(), FeatureTypeVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &SessionFeatureBase{}
	cls.Ptr = cret
	return cls
}

var xSessionGetFeatureForMessage func(uintptr, types.GType, uintptr) uintptr

// Gets the feature in @session of type @feature_type, provided
// that it is not disabled for @msg.
func (x *Session) GetFeatureForMessage(FeatureTypeVar types.GType, MsgVar *Message) *SessionFeatureBase {
	var cls *SessionFeatureBase

	cret := xSessionGetFeatureForMessage(x.GoPointer(), FeatureTypeVar, MsgVar.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &SessionFeatureBase{}
	cls.Ptr = cret
	return cls
}

var xSessionGetIdleTimeout func(uintptr) uint

// Get the timeout in seconds for idle connection lifetime currently used by
// @session.
func (x *Session) GetIdleTimeout() uint {

	cret := xSessionGetIdleTimeout(x.GoPointer())
	return cret
}

var xSessionGetLocalAddress func(uintptr) uintptr

// Get the [class@Gio.InetSocketAddress] to use for the client side of
// connections in @session.
func (x *Session) GetLocalAddress() *gio.InetSocketAddress {
	var cls *gio.InetSocketAddress

	cret := xSessionGetLocalAddress(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.InetSocketAddress{}
	cls.Ptr = cret
	return cls
}

var xSessionGetMaxConns func(uintptr) uint

// Get the maximum number of connections that @session can open at once.
func (x *Session) GetMaxConns() uint {

	cret := xSessionGetMaxConns(x.GoPointer())
	return cret
}

var xSessionGetMaxConnsPerHost func(uintptr) uint

// Get the maximum number of connections that @session can open at once to a
// given host.
func (x *Session) GetMaxConnsPerHost() uint {

	cret := xSessionGetMaxConnsPerHost(x.GoPointer())
	return cret
}

var xSessionGetProxyResolver func(uintptr) uintptr

// Get the [iface@Gio.ProxyResolver] currently used by @session.
func (x *Session) GetProxyResolver() *gio.ProxyResolverBase {
	var cls *gio.ProxyResolverBase

	cret := xSessionGetProxyResolver(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.ProxyResolverBase{}
	cls.Ptr = cret
	return cls
}

var xSessionGetRemoteConnectable func(uintptr) uintptr

// Gets the remote connectable if one set.
func (x *Session) GetRemoteConnectable() *gio.SocketConnectableBase {
	var cls *gio.SocketConnectableBase

	cret := xSessionGetRemoteConnectable(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.SocketConnectableBase{}
	cls.Ptr = cret
	return cls
}

var xSessionGetTimeout func(uintptr) uint

// Get the timeout in seconds for socket I/O operations currently used by
// @session.
func (x *Session) GetTimeout() uint {

	cret := xSessionGetTimeout(x.GoPointer())
	return cret
}

var xSessionGetTlsDatabase func(uintptr) uintptr

// Get the [class@Gio.TlsDatabase] currently used by @session.
func (x *Session) GetTlsDatabase() *gio.TlsDatabase {
	var cls *gio.TlsDatabase

	cret := xSessionGetTlsDatabase(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.TlsDatabase{}
	cls.Ptr = cret
	return cls
}

var xSessionGetTlsInteraction func(uintptr) uintptr

// Get the [class@Gio.TlsInteraction] currently used by @session.
func (x *Session) GetTlsInteraction() *gio.TlsInteraction {
	var cls *gio.TlsInteraction

	cret := xSessionGetTlsInteraction(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.TlsInteraction{}
	cls.Ptr = cret
	return cls
}

var xSessionGetUserAgent func(uintptr) string

// Get the value used by @session for the "User-Agent" header on new requests.
func (x *Session) GetUserAgent() string {

	cret := xSessionGetUserAgent(x.GoPointer())
	return cret
}

var xSessionHasFeature func(uintptr, types.GType) bool

// Tests if @session has at a feature of type @feature_type (which can
// be the type of either a [iface@SessionFeature], or else a subtype of
// some class managed by another feature, such as [class@Auth]).
func (x *Session) HasFeature(FeatureTypeVar types.GType) bool {

	cret := xSessionHasFeature(x.GoPointer(), FeatureTypeVar)
	return cret
}

var xSessionPreconnectAsync func(uintptr, uintptr, int, uintptr, uintptr, uintptr)

// Start a preconnection to @msg.
//
// Once the connection is done, it will remain in idle state so that it can be
// reused by future requests. If there's already an idle connection for the
// given @msg host, the operation finishes successfully without creating a new
// connection. If a new request for the given @msg host is made while the
// preconnect is still ongoing, the request will take the ownership of the
// connection and the preconnect operation will finish successfully (if there's
// a connection error it will be handled by the request).
//
// The operation finishes when the connection is done or an error occurred.
func (x *Session) PreconnectAsync(MsgVar *Message, IoPriorityVar int, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	xSessionPreconnectAsync(x.GoPointer(), MsgVar.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

var xSessionPreconnectFinish func(uintptr, uintptr, **glib.Error) bool

// Complete a preconnect async operation started with [method@Session.preconnect_async].
func (x *Session) PreconnectFinish(ResultVar gio.AsyncResult) (bool, error) {
	var cerr *glib.Error

	cret := xSessionPreconnectFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xSessionRemoveFeature func(uintptr, uintptr)

// Removes @feature's functionality from @session.
func (x *Session) RemoveFeature(FeatureVar SessionFeature) {

	xSessionRemoveFeature(x.GoPointer(), FeatureVar.GoPointer())

}

var xSessionRemoveFeatureByType func(uintptr, types.GType)

// Removes all features of type @feature_type (or any subclass of
// @feature_type) from @session.
func (x *Session) RemoveFeatureByType(FeatureTypeVar types.GType) {

	xSessionRemoveFeatureByType(x.GoPointer(), FeatureTypeVar)

}

var xSessionSend func(uintptr, uintptr, uintptr, **glib.Error) uintptr

// Synchronously sends @msg and waits for the beginning of a response.
//
// On success, a [class@Gio.InputStream] will be returned which you can use to
// read the response body. ("Success" here means only that an HTTP
// response was received and understood; it does not necessarily mean
// that a 2xx class status code was received.)
//
// If non-%NULL, @cancellable can be used to cancel the request;
// [method@Session.send] will return a %G_IO_ERROR_CANCELLED error. Note that
// with requests that have side effects (eg, `POST`, `PUT`, `DELETE`) it is
// possible that you might cancel the request after the server acts on it, but
// before it returns a response, leaving the remote resource in an unknown
// state.
//
// If @msg is requeued due to a redirect or authentication, the
// initial (`3xx/401/407`) response body will be suppressed, and
// [method@Session.send] will only return once a final response has been
// received.
//
// Possible error domains include [error@SessionError], [error@Gio.IOErrorEnum],
// and [error@Gio.TlsError] which you may want to specifically handle.
func (x *Session) Send(MsgVar *Message, CancellableVar *gio.Cancellable) (*gio.InputStream, error) {
	var cls *gio.InputStream
	var cerr *glib.Error

	cret := xSessionSend(x.GoPointer(), MsgVar.GoPointer(), CancellableVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &gio.InputStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xSessionSendAndRead func(uintptr, uintptr, uintptr, **glib.Error) uintptr

// Synchronously sends @msg and reads the response body.
//
// On success, a [struct@GLib.Bytes] will be returned with the response body.
// This function should only be used when the resource to be retrieved
// is not too long and can be stored in memory.
//
// See [method@Session.send] for more details on the general semantics.
func (x *Session) SendAndRead(MsgVar *Message, CancellableVar *gio.Cancellable) (uintptr, error) {
	var cerr *glib.Error

	cret := xSessionSendAndRead(x.GoPointer(), MsgVar.GoPointer(), CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xSessionSendAndReadAsync func(uintptr, uintptr, int, uintptr, uintptr, uintptr)

// Asynchronously sends @msg and reads the response body.
//
// When @callback is called, then either @msg has been sent, and its response
// body read, or else an error has occurred. This function should only be used
// when the resource to be retrieved is not too long and can be stored in
// memory. Call [method@Session.send_and_read_finish] to get a
// [struct@GLib.Bytes] with the response body.
//
// See [method@Session.send] for more details on the general semantics.
func (x *Session) SendAndReadAsync(MsgVar *Message, IoPriorityVar int, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	xSessionSendAndReadAsync(x.GoPointer(), MsgVar.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

var xSessionSendAndReadFinish func(uintptr, uintptr, **glib.Error) uintptr

// Gets the response to a [method@Session.send_and_read_async].
//
// If successful, returns a [struct@GLib.Bytes] with the response body.
func (x *Session) SendAndReadFinish(ResultVar gio.AsyncResult) (uintptr, error) {
	var cerr *glib.Error

	cret := xSessionSendAndReadFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xSessionSendAndSplice func(uintptr, uintptr, uintptr, gio.OutputStreamSpliceFlags, uintptr, **glib.Error) int

// Synchronously sends @msg and splices the response body stream into @out_stream.
//
// See [method@Session.send] for more details on the general semantics.
func (x *Session) SendAndSplice(MsgVar *Message, OutStreamVar *gio.OutputStream, FlagsVar gio.OutputStreamSpliceFlags, CancellableVar *gio.Cancellable) (int, error) {
	var cerr *glib.Error

	cret := xSessionSendAndSplice(x.GoPointer(), MsgVar.GoPointer(), OutStreamVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xSessionSendAndSpliceAsync func(uintptr, uintptr, uintptr, gio.OutputStreamSpliceFlags, int, uintptr, uintptr, uintptr)

// Asynchronously sends @msg and splices the response body stream into @out_stream.
// When @callback is called, then either @msg has been sent and its response body
// spliced, or else an error has occurred.
//
// See [method@Session.send] for more details on the general semantics.
func (x *Session) SendAndSpliceAsync(MsgVar *Message, OutStreamVar *gio.OutputStream, FlagsVar gio.OutputStreamSpliceFlags, IoPriorityVar int, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	xSessionSendAndSpliceAsync(x.GoPointer(), MsgVar.GoPointer(), OutStreamVar.GoPointer(), FlagsVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

var xSessionSendAndSpliceFinish func(uintptr, uintptr, **glib.Error) int

// Gets the response to a [method@Session.send_and_splice_async].
func (x *Session) SendAndSpliceFinish(ResultVar gio.AsyncResult) (int, error) {
	var cerr *glib.Error

	cret := xSessionSendAndSpliceFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
	if cerr == nil {
		return cret, nil
	}
	return cret, cerr

}

var xSessionSendAsync func(uintptr, uintptr, int, uintptr, uintptr, uintptr)

// Asynchronously sends @msg and waits for the beginning of a response.
//
// When @callback is called, then either @msg has been sent, and its response
// headers received, or else an error has occurred. Call
// [method@Session.send_finish] to get a [class@Gio.InputStream] for reading the
// response body.
//
// See [method@Session.send] for more details on the general semantics.
func (x *Session) SendAsync(MsgVar *Message, IoPriorityVar int, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	xSessionSendAsync(x.GoPointer(), MsgVar.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

var xSessionSendFinish func(uintptr, uintptr, **glib.Error) uintptr

// Gets the response to a [method@Session.send_async] call.
//
// If successful returns a [class@Gio.InputStream] that can be used to read the
// response body.
func (x *Session) SendFinish(ResultVar gio.AsyncResult) (*gio.InputStream, error) {
	var cls *gio.InputStream
	var cerr *glib.Error

	cret := xSessionSendFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &gio.InputStream{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

var xSessionSetAcceptLanguage func(uintptr, string)

// Set the value to use for the "Accept-Language" header on [class@Message]s
// sent from @session.
//
// If @accept_language is %NULL then no "Accept-Language" will be included in
// requests. See [property@Session:accept-language] for more information.
func (x *Session) SetAcceptLanguage(AcceptLanguageVar string) {

	xSessionSetAcceptLanguage(x.GoPointer(), AcceptLanguageVar)

}

var xSessionSetAcceptLanguageAuto func(uintptr, bool)

// Set whether @session will automatically set the "Accept-Language" header on
// requests using a value generated from system languages based on
// [func@GLib.get_language_names].
//
// See [property@Session:accept-language-auto] for more information.
func (x *Session) SetAcceptLanguageAuto(AcceptLanguageAutoVar bool) {

	xSessionSetAcceptLanguageAuto(x.GoPointer(), AcceptLanguageAutoVar)

}

var xSessionSetIdleTimeout func(uintptr, uint)

// Set a timeout in seconds for idle connection lifetime to be used by @session
// on new connections.
//
// See [property@Session:idle-timeout] for more information.
func (x *Session) SetIdleTimeout(TimeoutVar uint) {

	xSessionSetIdleTimeout(x.GoPointer(), TimeoutVar)

}

var xSessionSetProxyResolver func(uintptr, uintptr)

// Set a [iface@Gio.ProxyResolver] to be used by @session on new connections.
//
// If @proxy_resolver is %NULL then no proxies will be used. See
// [property@Session:proxy-resolver] for more information.
func (x *Session) SetProxyResolver(ProxyResolverVar gio.ProxyResolver) {

	xSessionSetProxyResolver(x.GoPointer(), ProxyResolverVar.GoPointer())

}

var xSessionSetTimeout func(uintptr, uint)

// Set a timeout in seconds for socket I/O operations to be used by @session
// on new connections.
//
// See [property@Session:timeout] for more information.
func (x *Session) SetTimeout(TimeoutVar uint) {

	xSessionSetTimeout(x.GoPointer(), TimeoutVar)

}

var xSessionSetTlsDatabase func(uintptr, uintptr)

// Set a [class@Gio.TlsDatabase] to be used by @session on new connections.
//
// If @tls_database is %NULL then certificate validation will always fail. See
// [property@Session:tls-database] for more information.
func (x *Session) SetTlsDatabase(TlsDatabaseVar *gio.TlsDatabase) {

	xSessionSetTlsDatabase(x.GoPointer(), TlsDatabaseVar.GoPointer())

}

var xSessionSetTlsInteraction func(uintptr, uintptr)

// Set a [class@Gio.TlsInteraction] to be used by @session on new connections.
//
// If @tls_interaction is %NULL then client certificate validation will always
// fail.
//
// See [property@Session:tls-interaction] for more information.
func (x *Session) SetTlsInteraction(TlsInteractionVar *gio.TlsInteraction) {

	xSessionSetTlsInteraction(x.GoPointer(), TlsInteractionVar.GoPointer())

}

var xSessionSetUserAgent func(uintptr, string)

// Set the value to use for the "User-Agent" header on [class@Message]s sent
// from @session.
//
// If @user_agent has trailing whitespace, @session will append its own product
// token (eg, `libsoup/3.0.0`) to the end of the header for you. If @user_agent
// is %NULL then no "User-Agent" will be included in requests. See
// [property@Session:user-agent] for more information.
func (x *Session) SetUserAgent(UserAgentVar string) {

	xSessionSetUserAgent(x.GoPointer(), UserAgentVar)

}

var xSessionWebsocketConnectAsync func(uintptr, uintptr, string, []string, int, uintptr, uintptr, uintptr)

// Asynchronously creates a [class@WebsocketConnection] to communicate with a
// remote server.
//
// All necessary WebSocket-related headers will be added to @msg, and
// it will then be sent and asynchronously processed normally
// (including handling of redirection and HTTP authentication).
//
// If the server returns "101 Switching Protocols", then @msg's status
// code and response headers will be updated, and then the WebSocket
// handshake will be completed. On success,
// [method@Session.websocket_connect_finish] will return a new
// [class@WebsocketConnection]. On failure it will return a #GError.
//
// If the server returns a status other than "101 Switching Protocols", then
// @msg will contain the complete response headers and body from the server's
// response, and [method@Session.websocket_connect_finish] will return
// %SOUP_WEBSOCKET_ERROR_NOT_WEBSOCKET.
func (x *Session) WebsocketConnectAsync(MsgVar *Message, OriginVar string, ProtocolsVar []string, IoPriorityVar int, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	xSessionWebsocketConnectAsync(x.GoPointer(), MsgVar.GoPointer(), OriginVar, ProtocolsVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

var xSessionWebsocketConnectFinish func(uintptr, uintptr, **glib.Error) uintptr

// Gets the [class@WebsocketConnection] response to a
// [method@Session.websocket_connect_async] call.
//
// If successful, returns a [class@WebsocketConnection] that can be used to
// communicate with the server.
func (x *Session) WebsocketConnectFinish(ResultVar gio.AsyncResult) (*WebsocketConnection, error) {
	var cls *WebsocketConnection
	var cerr *glib.Error

	cret := xSessionWebsocketConnectFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &WebsocketConnection{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

func (c *Session) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *Session) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emitted when a request is queued on @session.
//
// When sending a request, first [signal@Session::request-queued]
// is emitted, indicating that the session has become aware of
// the request.
//
// After a connection is available to send the request various
// [class@Message] signals are emitted as the message is
// processed. If the message is requeued, it will emit
// [signal@Message::restarted], which will then be followed by other
// [class@Message] signals when the message is re-sent.
//
// Eventually, the message will emit [signal@Message::finished].
// Normally, this signals the completion of message
// processing. However, it is possible that the application
// will requeue the message from the "finished" handler.
// In that case the process will loop back.
//
// Eventually, a message will reach "finished" and not be
// requeued. At that point, the session will emit
// [signal@Session::request-unqueued] to indicate that it is done
// with the message.
//
// To sum up: [signal@Session::request-queued] and
// [signal@Session::request-unqueued] are guaranteed to be emitted
// exactly once, but [signal@Message::finished] (and all of the other
// [class@Message] signals) may be invoked multiple times for a given
// message.
func (x *Session) ConnectRequestQueued(cb *func(Session, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "request-queued", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, MsgVarp uintptr) {
		fa := Session{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, MsgVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "request-queued", cbRefPtr)
}

// Emitted when a request is removed from @session's queue,
// indicating that @session is done with it.
//
// See [signal@Session::request-queued] for a detailed description of
// the message lifecycle within a session.
func (x *Session) ConnectRequestUnqueued(cb *func(Session, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "request-unqueued", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, MsgVarp uintptr) {
		fa := Session{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, MsgVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "request-unqueued", cbRefPtr)
}

func init() {
	core.SetPackageName("SOUP", "libsoup-3.0")
	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("SOUP") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xSessionErrorGLibType, libs, "soup_session_error_get_type")

	core.PuregoSafeRegister(&xSessionErrorQuark, libs, "soup_session_error_quark")

	core.PuregoSafeRegister(&xSessionGLibType, libs, "soup_session_get_type")

	core.PuregoSafeRegister(&xNewSession, libs, "soup_session_new")
	core.PuregoSafeRegister(&xNewSessionWithOptions, libs, "soup_session_new_with_options")

	core.PuregoSafeRegister(&xSessionAbort, libs, "soup_session_abort")
	core.PuregoSafeRegister(&xSessionAddFeature, libs, "soup_session_add_feature")
	core.PuregoSafeRegister(&xSessionAddFeatureByType, libs, "soup_session_add_feature_by_type")
	core.PuregoSafeRegister(&xSessionGetAcceptLanguage, libs, "soup_session_get_accept_language")
	core.PuregoSafeRegister(&xSessionGetAcceptLanguageAuto, libs, "soup_session_get_accept_language_auto")
	core.PuregoSafeRegister(&xSessionGetAsyncResultMessage, libs, "soup_session_get_async_result_message")
	core.PuregoSafeRegister(&xSessionGetFeature, libs, "soup_session_get_feature")
	core.PuregoSafeRegister(&xSessionGetFeatureForMessage, libs, "soup_session_get_feature_for_message")
	core.PuregoSafeRegister(&xSessionGetIdleTimeout, libs, "soup_session_get_idle_timeout")
	core.PuregoSafeRegister(&xSessionGetLocalAddress, libs, "soup_session_get_local_address")
	core.PuregoSafeRegister(&xSessionGetMaxConns, libs, "soup_session_get_max_conns")
	core.PuregoSafeRegister(&xSessionGetMaxConnsPerHost, libs, "soup_session_get_max_conns_per_host")
	core.PuregoSafeRegister(&xSessionGetProxyResolver, libs, "soup_session_get_proxy_resolver")
	core.PuregoSafeRegister(&xSessionGetRemoteConnectable, libs, "soup_session_get_remote_connectable")
	core.PuregoSafeRegister(&xSessionGetTimeout, libs, "soup_session_get_timeout")
	core.PuregoSafeRegister(&xSessionGetTlsDatabase, libs, "soup_session_get_tls_database")
	core.PuregoSafeRegister(&xSessionGetTlsInteraction, libs, "soup_session_get_tls_interaction")
	core.PuregoSafeRegister(&xSessionGetUserAgent, libs, "soup_session_get_user_agent")
	core.PuregoSafeRegister(&xSessionHasFeature, libs, "soup_session_has_feature")
	core.PuregoSafeRegister(&xSessionPreconnectAsync, libs, "soup_session_preconnect_async")
	core.PuregoSafeRegister(&xSessionPreconnectFinish, libs, "soup_session_preconnect_finish")
	core.PuregoSafeRegister(&xSessionRemoveFeature, libs, "soup_session_remove_feature")
	core.PuregoSafeRegister(&xSessionRemoveFeatureByType, libs, "soup_session_remove_feature_by_type")
	core.PuregoSafeRegister(&xSessionSend, libs, "soup_session_send")
	core.PuregoSafeRegister(&xSessionSendAndRead, libs, "soup_session_send_and_read")
	core.PuregoSafeRegister(&xSessionSendAndReadAsync, libs, "soup_session_send_and_read_async")
	core.PuregoSafeRegister(&xSessionSendAndReadFinish, libs, "soup_session_send_and_read_finish")
	core.PuregoSafeRegister(&xSessionSendAndSplice, libs, "soup_session_send_and_splice")
	core.PuregoSafeRegister(&xSessionSendAndSpliceAsync, libs, "soup_session_send_and_splice_async")
	core.PuregoSafeRegister(&xSessionSendAndSpliceFinish, libs, "soup_session_send_and_splice_finish")
	core.PuregoSafeRegister(&xSessionSendAsync, libs, "soup_session_send_async")
	core.PuregoSafeRegister(&xSessionSendFinish, libs, "soup_session_send_finish")
	core.PuregoSafeRegister(&xSessionSetAcceptLanguage, libs, "soup_session_set_accept_language")
	core.PuregoSafeRegister(&xSessionSetAcceptLanguageAuto, libs, "soup_session_set_accept_language_auto")
	core.PuregoSafeRegister(&xSessionSetIdleTimeout, libs, "soup_session_set_idle_timeout")
	core.PuregoSafeRegister(&xSessionSetProxyResolver, libs, "soup_session_set_proxy_resolver")
	core.PuregoSafeRegister(&xSessionSetTimeout, libs, "soup_session_set_timeout")
	core.PuregoSafeRegister(&xSessionSetTlsDatabase, libs, "soup_session_set_tls_database")
	core.PuregoSafeRegister(&xSessionSetTlsInteraction, libs, "soup_session_set_tls_interaction")
	core.PuregoSafeRegister(&xSessionSetUserAgent, libs, "soup_session_set_user_agent")
	core.PuregoSafeRegister(&xSessionWebsocketConnectAsync, libs, "soup_session_websocket_connect_async")
	core.PuregoSafeRegister(&xSessionWebsocketConnectFinish, libs, "soup_session_websocket_connect_finish")

}
