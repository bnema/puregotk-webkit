// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package soup

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type AuthManagerClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass
}

func (x *AuthManagerClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// HTTP client-side authentication handler.
//
// #SoupAuthManager is the [iface@SessionFeature] that handles HTTP
// authentication for a [class@Session].
//
// A #SoupAuthManager is added to the session by default, and normally
// you don't need to worry about it at all. However, if you want to
// disable HTTP authentication, you can remove the feature from the
// session with [method@Session.remove_feature_by_type] or disable it on
// individual requests with [method@Message.disable_feature].
//
// You can use this with [method@Session.remove_feature_by_type] or
// [method@Message.disable_feature].
//
// (Although this type has only been publicly visible since libsoup 2.42, it has
// always existed in the background, and you can use `g_type_from_name
// ("SoupAuthManager")` to get its [alias@GObject.Type] in earlier releases.)
type AuthManager struct {
	gobject.Object
}

var xAuthManagerGLibType func() types.GType

func AuthManagerGLibType() types.GType {
	return xAuthManagerGLibType()
}

func AuthManagerNewFromInternalPtr(ptr uintptr) *AuthManager {
	cls := &AuthManager{}
	cls.Ptr = ptr
	return cls
}

var xAuthManagerClearCachedCredentials func(uintptr)

// Clear all credentials cached by @manager.
func (x *AuthManager) ClearCachedCredentials() {

	xAuthManagerClearCachedCredentials(x.GoPointer())

}

var xAuthManagerUseAuth func(uintptr, *glib.Uri, uintptr)

// Records that @auth is to be used under @uri, as though a
// WWW-Authenticate header had been received at that URI.
//
// This can be used to "preload" @manager's auth cache, to avoid an extra HTTP
// round trip in the case where you know ahead of time that a 401 response will
// be returned.
//
// This is only useful for authentication types where the initial
// Authorization header does not depend on any additional information
// from the server. (Eg, Basic or NTLM, but not Digest.)
func (x *AuthManager) UseAuth(UriVar *glib.Uri, AuthVar *Auth) {

	xAuthManagerUseAuth(x.GoPointer(), UriVar, AuthVar.GoPointer())

}

func (c *AuthManager) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *AuthManager) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	core.SetPackageName("SOUP", "libsoup-3.0")
	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("SOUP") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xAuthManagerGLibType, libs, "soup_auth_manager_get_type")

	core.PuregoSafeRegister(&xAuthManagerClearCachedCredentials, libs, "soup_auth_manager_clear_cached_credentials")
	core.PuregoSafeRegister(&xAuthManagerUseAuth, libs, "soup_auth_manager_use_auth")

}
