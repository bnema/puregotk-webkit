// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package soup

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type CookieJarClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass

	xSave uintptr

	xIsPersistent uintptr

	xChanged uintptr

	Padding [6]uintptr
}

func (x *CookieJarClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideSave sets the "save" callback function.
func (x *CookieJarClass) OverrideSave(cb func(*CookieJar)) {
	if cb == nil {
		x.xSave = 0
	} else {
		x.xSave = purego.NewCallback(func(JarVarp uintptr) {
			cb(CookieJarNewFromInternalPtr(JarVarp))
		})
	}
}

// GetSave gets the "save" callback function.
func (x *CookieJarClass) GetSave() func(*CookieJar) {
	if x.xSave == 0 {
		return nil
	}
	var rawCallback func(JarVarp uintptr)
	purego.RegisterFunc(&rawCallback, x.xSave)
	return func(JarVar *CookieJar) {
		rawCallback(JarVar.GoPointer())
	}
}

// OverrideIsPersistent sets the "is_persistent" callback function.
func (x *CookieJarClass) OverrideIsPersistent(cb func(*CookieJar) bool) {
	if cb == nil {
		x.xIsPersistent = 0
	} else {
		x.xIsPersistent = purego.NewCallback(func(JarVarp uintptr) bool {
			return cb(CookieJarNewFromInternalPtr(JarVarp))
		})
	}
}

// GetIsPersistent gets the "is_persistent" callback function.
func (x *CookieJarClass) GetIsPersistent() func(*CookieJar) bool {
	if x.xIsPersistent == 0 {
		return nil
	}
	var rawCallback func(JarVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xIsPersistent)
	return func(JarVar *CookieJar) bool {
		return rawCallback(JarVar.GoPointer())
	}
}

// OverrideChanged sets the "changed" callback function.
func (x *CookieJarClass) OverrideChanged(cb func(*CookieJar, *Cookie, *Cookie)) {
	if cb == nil {
		x.xChanged = 0
	} else {
		x.xChanged = purego.NewCallback(func(JarVarp uintptr, OldCookieVarp *Cookie, NewCookieVarp *Cookie) {
			cb(CookieJarNewFromInternalPtr(JarVarp), OldCookieVarp, NewCookieVarp)
		})
	}
}

// GetChanged gets the "changed" callback function.
func (x *CookieJarClass) GetChanged() func(*CookieJar, *Cookie, *Cookie) {
	if x.xChanged == 0 {
		return nil
	}
	var rawCallback func(JarVarp uintptr, OldCookieVarp *Cookie, NewCookieVarp *Cookie)
	purego.RegisterFunc(&rawCallback, x.xChanged)
	return func(JarVar *CookieJar, OldCookieVar *Cookie, NewCookieVar *Cookie) {
		rawCallback(JarVar.GoPointer(), OldCookieVar, NewCookieVar)
	}
}

// The policy for accepting or rejecting cookies returned in
// responses.
type CookieJarAcceptPolicy int

var xCookieJarAcceptPolicyGLibType func() types.GType

func CookieJarAcceptPolicyGLibType() types.GType {
	return xCookieJarAcceptPolicyGLibType()
}

const (

	// accept all cookies unconditionally.
	CookieJarAcceptAlwaysValue CookieJarAcceptPolicy = 0
	// reject all cookies unconditionally.
	CookieJarAcceptNeverValue CookieJarAcceptPolicy = 1
	// accept all cookies set by the main
	//   document loaded in the application using libsoup. An example of the most
	//   common case, web browsers, would be: If http://www.example.com is the page
	//   loaded, accept all cookies set by example.com, but if a resource from
	//   http://www.third-party.com is loaded from that page reject any cookie that
	//   it could try to set. For libsoup to be able to tell apart first party
	//   cookies from the rest, the application must call
	//   [method@Message.set_first_party] on each outgoing [class@Message], setting
	//   the [struct@GLib.Uri] of the main document. If no first party is set in a
	//   message when this policy is in effect, cookies will be assumed to be third
	//   party by default.
	CookieJarAcceptNoThirdPartyValue CookieJarAcceptPolicy = 2
	// accept all cookies set by
	//   the main document loaded in the application using libsoup, and from domains
	//   that have previously set at least one cookie when loaded as the main
	//   document. An example of the most common case, web browsers, would be: if
	//   http://www.example.com is the page loaded, accept all cookies set by
	//   example.com, but if a resource from http://www.third-party.com is loaded
	//   from that page, reject any cookie that it could try to set unless it
	//   already has a cookie in the cookie jar. For libsoup to be able to tell
	//   apart first party cookies from the rest, the application must call
	//   [method@Message.set_first_party] on each outgoing #SoupMessage, setting the
	//   [struct@GLib.Uri] of the main document. If no first party is set in a
	//   message when this policy is in effect, cookies will be assumed to be third
	//   party by default.
	CookieJarAcceptGrandfatheredThirdPartyValue CookieJarAcceptPolicy = 3
)

// Automatic cookie handling for SoupSession.
//
// A #SoupCookieJar stores [struct@Cookie]s and arrange for them to be sent with
// the appropriate [class@Message]s. #SoupCookieJar implements
// [iface@SessionFeature], so you can add a cookie jar to a session with
// [method@Session.add_feature] or [method@Session.add_feature_by_type].
//
// Note that the base #SoupCookieJar class does not support any form
// of long-term cookie persistence.
type CookieJar struct {
	gobject.Object
}

var xCookieJarGLibType func() types.GType

func CookieJarGLibType() types.GType {
	return xCookieJarGLibType()
}

func CookieJarNewFromInternalPtr(ptr uintptr) *CookieJar {
	cls := &CookieJar{}
	cls.Ptr = ptr
	return cls
}

var xNewCookieJar func() uintptr

// Creates a new #SoupCookieJar.
//
// The base #SoupCookieJar class does not support persistent storage of cookies;
// use a subclass for that.
func NewCookieJar() *CookieJar {
	var cls *CookieJar

	cret := xNewCookieJar()

	if cret == 0 {
		return nil
	}
	cls = &CookieJar{}
	cls.Ptr = cret
	return cls
}

var xCookieJarAddCookie func(uintptr, *Cookie)

// Adds @cookie to @jar.
//
// Emits the [signal@CookieJar::changed] signal if we are modifying
// an existing cookie or adding a valid new cookie ('valid' means
// that the cookie's expire date is not in the past).
//
// @cookie will be 'stolen' by the jar, so don't free it afterwards.
func (x *CookieJar) AddCookie(CookieVar *Cookie) {

	xCookieJarAddCookie(x.GoPointer(), CookieVar)

}

var xCookieJarAddCookieFull func(uintptr, *Cookie, *glib.Uri, *glib.Uri)

// Adds @cookie to @jar.
//
// Emits the [signal@CookieJar::changed] signal if we are modifying an existing
// cookie or adding a valid new cookie ('valid' means that the cookie's expire
// date is not in the past).
//
// @first_party will be used to reject cookies coming from third party
// resources in case such a security policy is set in the @jar.
//
// @uri will be used to reject setting or overwriting secure cookies
// from insecure origins. %NULL is treated as secure.
//
// @cookie will be 'stolen' by the jar, so don't free it afterwards.
func (x *CookieJar) AddCookieFull(CookieVar *Cookie, UriVar *glib.Uri, FirstPartyVar *glib.Uri) {

	xCookieJarAddCookieFull(x.GoPointer(), CookieVar, UriVar, FirstPartyVar)

}

var xCookieJarAddCookieWithFirstParty func(uintptr, *glib.Uri, *Cookie)

// Adds @cookie to @jar.
//
// Emits the [signal@CookieJar::changed] signal if we are modifying
// an existing cookie or adding a valid new cookie ('valid' means
// that the cookie's expire date is not in the past).
//
// @first_party will be used to reject cookies coming from third party
// resources in case such a security policy is set in the @jar.
//
// @cookie will be 'stolen' by the jar, so don't free it afterwards.
//
// For secure cookies to work properly you may want to use
// [method@CookieJar.add_cookie_full].
func (x *CookieJar) AddCookieWithFirstParty(FirstPartyVar *glib.Uri, CookieVar *Cookie) {

	xCookieJarAddCookieWithFirstParty(x.GoPointer(), FirstPartyVar, CookieVar)

}

var xCookieJarAllCookies func(uintptr) *glib.SList

// Constructs a [struct@GLib.List] with every cookie inside the @jar.
//
// The cookies in the list are a copy of the original, so
// you have to free them when you are done with them.
//
// For historical reasons this list is in reverse order.
func (x *CookieJar) AllCookies() *glib.SList {

	cret := xCookieJarAllCookies(x.GoPointer())
	return cret
}

var xCookieJarDeleteCookie func(uintptr, *Cookie)

// Deletes @cookie from @jar.
//
// Emits the [signal@CookieJar::changed] signal.
func (x *CookieJar) DeleteCookie(CookieVar *Cookie) {

	xCookieJarDeleteCookie(x.GoPointer(), CookieVar)

}

var xCookieJarGetAcceptPolicy func(uintptr) CookieJarAcceptPolicy

// Gets @jar's [enum@CookieJarAcceptPolicy].
func (x *CookieJar) GetAcceptPolicy() CookieJarAcceptPolicy {

	cret := xCookieJarGetAcceptPolicy(x.GoPointer())
	return cret
}

var xCookieJarGetCookieList func(uintptr, *glib.Uri, bool) *glib.SList

// Retrieves the list of cookies that would be sent with a request to @uri
// as a [struct@GLib.List] of #SoupCookie objects.
//
// If @for_http is %TRUE, the return value will include cookies marked
// "HttpOnly" (that is, cookies that the server wishes to keep hidden
// from client-side scripting operations such as the JavaScript
// document.cookies property). Since #SoupCookieJar sets the Cookie
// header itself when making the actual HTTP request, you should
// almost certainly be setting @for_http to %FALSE if you are calling
// this.
func (x *CookieJar) GetCookieList(UriVar *glib.Uri, ForHttpVar bool) *glib.SList {

	cret := xCookieJarGetCookieList(x.GoPointer(), UriVar, ForHttpVar)
	return cret
}

var xCookieJarGetCookieListWithSameSiteInfo func(uintptr, *glib.Uri, *glib.Uri, *glib.Uri, bool, bool, bool) *glib.SList

// This is an extended version of [method@CookieJar.get_cookie_list] that
// provides more information required to use SameSite cookies.
//
// See the [SameSite cookies
// spec](https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00) for
// more detailed information.
func (x *CookieJar) GetCookieListWithSameSiteInfo(UriVar *glib.Uri, TopLevelVar *glib.Uri, SiteForCookiesVar *glib.Uri, ForHttpVar bool, IsSafeMethodVar bool, IsTopLevelNavigationVar bool) *glib.SList {

	cret := xCookieJarGetCookieListWithSameSiteInfo(x.GoPointer(), UriVar, TopLevelVar, SiteForCookiesVar, ForHttpVar, IsSafeMethodVar, IsTopLevelNavigationVar)
	return cret
}

var xCookieJarGetCookies func(uintptr, *glib.Uri, bool) string

// Retrieves (in Cookie-header form) the list of cookies that would
// be sent with a request to @uri.
//
// If @for_http is %TRUE, the return value will include cookies marked
// "HttpOnly" (that is, cookies that the server wishes to keep hidden
// from client-side scripting operations such as the JavaScript
// document.cookies property). Since #SoupCookieJar sets the Cookie
// header itself when making the actual HTTP request, you should
// almost certainly be setting @for_http to %FALSE if you are calling
// this.
func (x *CookieJar) GetCookies(UriVar *glib.Uri, ForHttpVar bool) string {

	cret := xCookieJarGetCookies(x.GoPointer(), UriVar, ForHttpVar)
	return cret
}

var xCookieJarIsPersistent func(uintptr) bool

// Gets whether @jar stores cookies persistenly.
func (x *CookieJar) IsPersistent() bool {

	cret := xCookieJarIsPersistent(x.GoPointer())
	return cret
}

var xCookieJarSetAcceptPolicy func(uintptr, CookieJarAcceptPolicy)

// Sets @policy as the cookie acceptance policy for @jar.
func (x *CookieJar) SetAcceptPolicy(PolicyVar CookieJarAcceptPolicy) {

	xCookieJarSetAcceptPolicy(x.GoPointer(), PolicyVar)

}

var xCookieJarSetCookie func(uintptr, *glib.Uri, string)

// Adds @cookie to @jar, exactly as though it had appeared in a
// Set-Cookie header returned from a request to @uri.
//
// Keep in mind that if the [enum@CookieJarAcceptPolicy] set is either
// %SOUP_COOKIE_JAR_ACCEPT_NO_THIRD_PARTY or
// %SOUP_COOKIE_JAR_ACCEPT_GRANDFATHERED_THIRD_PARTY you'll need to use
// [method@CookieJar.set_cookie_with_first_party], otherwise the jar
// will have no way of knowing if the cookie is being set by a third
// party or not.
func (x *CookieJar) SetCookie(UriVar *glib.Uri, CookieVar string) {

	xCookieJarSetCookie(x.GoPointer(), UriVar, CookieVar)

}

var xCookieJarSetCookieWithFirstParty func(uintptr, *glib.Uri, *glib.Uri, string)

// Adds @cookie to @jar, exactly as though it had appeared in a
// Set-Cookie header returned from a request to @uri.
//
// @first_party will be used to reject cookies coming from third party resources
// in case such a security policy is set in the @jar.
func (x *CookieJar) SetCookieWithFirstParty(UriVar *glib.Uri, FirstPartyVar *glib.Uri, CookieVar string) {

	xCookieJarSetCookieWithFirstParty(x.GoPointer(), UriVar, FirstPartyVar, CookieVar)

}

func (c *CookieJar) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *CookieJar) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyReadOnly sets the "read-only" property.
// Whether or not the cookie jar is read-only.
func (x *CookieJar) SetPropertyReadOnly(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("read-only", &v)
}

// GetPropertyReadOnly gets the "read-only" property.
// Whether or not the cookie jar is read-only.
func (x *CookieJar) GetPropertyReadOnly() bool {
	var v gobject.Value
	x.GetProperty("read-only", &v)
	return v.GetBoolean()
}

// Emitted when @jar changes.
//
// If a cookie has been added,
// @new_cookie will contain the newly-added cookie and
// @old_cookie will be %NULL. If a cookie has been deleted,
// @old_cookie will contain the to-be-deleted cookie and
// @new_cookie will be %NULL. If a cookie has been changed,
// @old_cookie will contain its old value, and @new_cookie its
// new value.
func (x *CookieJar) ConnectChanged(cb *func(CookieJar, uintptr, uintptr)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "changed", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, OldCookieVarp uintptr, NewCookieVarp uintptr) {
		fa := CookieJar{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, OldCookieVarp, NewCookieVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "changed", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

func init() {
	core.SetPackageName("SOUP", "libsoup-3.0")
	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("SOUP") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xCookieJarAcceptPolicyGLibType, libs, "soup_cookie_jar_accept_policy_get_type")

	core.PuregoSafeRegister(&xCookieJarGLibType, libs, "soup_cookie_jar_get_type")

	core.PuregoSafeRegister(&xNewCookieJar, libs, "soup_cookie_jar_new")

	core.PuregoSafeRegister(&xCookieJarAddCookie, libs, "soup_cookie_jar_add_cookie")
	core.PuregoSafeRegister(&xCookieJarAddCookieFull, libs, "soup_cookie_jar_add_cookie_full")
	core.PuregoSafeRegister(&xCookieJarAddCookieWithFirstParty, libs, "soup_cookie_jar_add_cookie_with_first_party")
	core.PuregoSafeRegister(&xCookieJarAllCookies, libs, "soup_cookie_jar_all_cookies")
	core.PuregoSafeRegister(&xCookieJarDeleteCookie, libs, "soup_cookie_jar_delete_cookie")
	core.PuregoSafeRegister(&xCookieJarGetAcceptPolicy, libs, "soup_cookie_jar_get_accept_policy")
	core.PuregoSafeRegister(&xCookieJarGetCookieList, libs, "soup_cookie_jar_get_cookie_list")
	core.PuregoSafeRegister(&xCookieJarGetCookieListWithSameSiteInfo, libs, "soup_cookie_jar_get_cookie_list_with_same_site_info")
	core.PuregoSafeRegister(&xCookieJarGetCookies, libs, "soup_cookie_jar_get_cookies")
	core.PuregoSafeRegister(&xCookieJarIsPersistent, libs, "soup_cookie_jar_is_persistent")
	core.PuregoSafeRegister(&xCookieJarSetAcceptPolicy, libs, "soup_cookie_jar_set_accept_policy")
	core.PuregoSafeRegister(&xCookieJarSetCookie, libs, "soup_cookie_jar_set_cookie")
	core.PuregoSafeRegister(&xCookieJarSetCookieWithFirstParty, libs, "soup_cookie_jar_set_cookie_with_first_party")

}
