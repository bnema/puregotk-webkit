// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package soup

import (
	"runtime"
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type ServerMessageClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass
}

func (x *ServerMessageClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// An HTTP server request and response pair.
//
// A SoupServerMessage represents an HTTP message that is being sent or
// received on a [class@Server].
//
// [class@Server] will create `SoupServerMessage`s automatically for
// incoming requests, which your application will receive via handlers.
//
// Note that libsoup's terminology here does not quite match the HTTP
// specification: in RFC 2616, an "HTTP-message" is *either* a Request, *or* a
// Response. In libsoup, a #SoupServerMessage combines both the request and the
// response.
type ServerMessage struct {
	gobject.Object
}

var xServerMessageGLibType func() types.GType

func ServerMessageGLibType() types.GType {
	return xServerMessageGLibType()
}

func ServerMessageNewFromInternalPtr(ptr uintptr) *ServerMessage {
	cls := &ServerMessage{}
	cls.Ptr = ptr
	return cls
}

var xServerMessageGetHttpVersion func(uintptr) HTTPVersion

// Get the HTTP version of @msg.
func (x *ServerMessage) GetHttpVersion() HTTPVersion {

	cret := xServerMessageGetHttpVersion(x.GoPointer())

	return cret
}

var xServerMessageGetLocalAddress func(uintptr) uintptr

// Retrieves the [class@Gio.SocketAddress] associated with the local end
// of a connection.
func (x *ServerMessage) GetLocalAddress() *gio.SocketAddress {
	var cls *gio.SocketAddress

	cret := xServerMessageGetLocalAddress(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.SocketAddress{}
	cls.Ptr = cret
	return cls
}

var xServerMessageGetMethod func(uintptr) string

// Get the HTTP method of @msg.
func (x *ServerMessage) GetMethod() string {

	cret := xServerMessageGetMethod(x.GoPointer())

	return cret
}

var xServerMessageGetReasonPhrase func(uintptr) string

// Get the HTTP reason phrase of @msg.
func (x *ServerMessage) GetReasonPhrase() string {

	cret := xServerMessageGetReasonPhrase(x.GoPointer())

	return cret
}

var xServerMessageGetRemoteAddress func(uintptr) uintptr

// Retrieves the [class@Gio.SocketAddress] associated with the remote end
// of a connection.
func (x *ServerMessage) GetRemoteAddress() *gio.SocketAddress {
	var cls *gio.SocketAddress

	cret := xServerMessageGetRemoteAddress(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.SocketAddress{}
	cls.Ptr = cret
	return cls
}

var xServerMessageGetRemoteHost func(uintptr) string

// Retrieves the IP address associated with the remote end of a
// connection.
func (x *ServerMessage) GetRemoteHost() string {

	cret := xServerMessageGetRemoteHost(x.GoPointer())

	return cret
}

var xServerMessageGetRequestBody func(uintptr) *MessageBody

// Get the request body of @msg.
func (x *ServerMessage) GetRequestBody() *MessageBody {

	cret := xServerMessageGetRequestBody(x.GoPointer())

	return cret
}

var xServerMessageGetRequestHeaders func(uintptr) *MessageHeaders

// Get the request headers of @msg.
func (x *ServerMessage) GetRequestHeaders() *MessageHeaders {

	cret := xServerMessageGetRequestHeaders(x.GoPointer())

	return cret
}

var xServerMessageGetResponseBody func(uintptr) *MessageBody

// Get the response body of @msg.
func (x *ServerMessage) GetResponseBody() *MessageBody {

	cret := xServerMessageGetResponseBody(x.GoPointer())

	return cret
}

var xServerMessageGetResponseHeaders func(uintptr) *MessageHeaders

// Get the response headers of @msg.
func (x *ServerMessage) GetResponseHeaders() *MessageHeaders {

	cret := xServerMessageGetResponseHeaders(x.GoPointer())

	return cret
}

var xServerMessageGetSocket func(uintptr) uintptr

// Retrieves the [class@Gio.Socket] that @msg is associated with.
//
// If you are using this method to observe when multiple requests are
// made on the same persistent HTTP connection (eg, as the ntlm-test
// test program does), you will need to pay attention to socket
// destruction as well (eg, by using weak references), so that you do
// not get fooled when the allocator reuses the memory address of a
// previously-destroyed socket to represent a new socket.
func (x *ServerMessage) GetSocket() *gio.Socket {
	var cls *gio.Socket

	cret := xServerMessageGetSocket(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.Socket{}
	cls.Ptr = cret
	return cls
}

var xServerMessageGetStatus func(uintptr) uint

// Get the HTTP status code of @msg.
func (x *ServerMessage) GetStatus() uint {

	cret := xServerMessageGetStatus(x.GoPointer())

	return cret
}

var xServerMessageGetTlsPeerCertificate func(uintptr) uintptr

// Gets the peer's #GTlsCertificate associated with @msg's connection.
// Note that this is not set yet during the emission of
// SoupServerMessage::accept-certificate signal.
func (x *ServerMessage) GetTlsPeerCertificate() *gio.TlsCertificate {
	var cls *gio.TlsCertificate

	cret := xServerMessageGetTlsPeerCertificate(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.TlsCertificate{}
	cls.Ptr = cret
	return cls
}

var xServerMessageGetTlsPeerCertificateErrors func(uintptr) gio.TlsCertificateFlags

// Gets the errors associated with validating @msg's TLS peer certificate.
// Note that this is not set yet during the emission of
// SoupServerMessage::accept-certificate signal.
func (x *ServerMessage) GetTlsPeerCertificateErrors() gio.TlsCertificateFlags {

	cret := xServerMessageGetTlsPeerCertificateErrors(x.GoPointer())

	return cret
}

var xServerMessageGetUri func(uintptr) *glib.Uri

// Get @msg's URI.
func (x *ServerMessage) GetUri() *glib.Uri {

	cret := xServerMessageGetUri(x.GoPointer())

	return cret
}

var xServerMessageIsOptionsPing func(uintptr) bool

// Gets if @msg represents an OPTIONS message with the path `*`.
func (x *ServerMessage) IsOptionsPing() bool {

	cret := xServerMessageIsOptionsPing(x.GoPointer())

	return cret
}

var xServerMessagePause func(uintptr)

// Pauses I/O on @msg.
//
// This can be used when you need to return from the server handler without
// having the full response ready yet. Use [method@ServerMessage.unpause] to
// resume I/O.
func (x *ServerMessage) Pause() {

	xServerMessagePause(x.GoPointer())

}

var xServerMessageSetHttpVersion func(uintptr, HTTPVersion)

// Set the HTTP version of @msg.
func (x *ServerMessage) SetHttpVersion(VersionVar HTTPVersion) {

	xServerMessageSetHttpVersion(x.GoPointer(), VersionVar)

}

var xServerMessageSetRedirect func(uintptr, uint, string)

// Sets @msg's status_code to @status_code and adds a Location header
// pointing to @redirect_uri. Use this from a [class@Server] when you
// want to redirect the client to another URI.
//
// @redirect_uri can be a relative URI, in which case it is
// interpreted relative to @msg's current URI. In particular, if
// @redirect_uri is just a path, it will replace the path
// *and query* of @msg's URI.
func (x *ServerMessage) SetRedirect(StatusCodeVar uint, RedirectUriVar string) {

	xServerMessageSetRedirect(x.GoPointer(), StatusCodeVar, RedirectUriVar)

}

var xServerMessageSetResponse func(uintptr, uintptr, MemoryUse, uintptr, uint)

// Convenience function to set the response body of a #SoupServerMessage. If
// @content_type is %NULL, the response body must be empty as well.
func (x *ServerMessage) SetResponse(ContentTypeVar *string, RespUseVar MemoryUse, RespBodyVar *string, RespLengthVar uint) {

	ContentTypeVarPtr, ContentTypeVarBytes := core.NullableStringToPtr(ContentTypeVar)

	RespBodyVarPtr, RespBodyVarBytes := core.NullableStringToPtr(RespBodyVar)

	xServerMessageSetResponse(x.GoPointer(), ContentTypeVarPtr, RespUseVar, RespBodyVarPtr, RespLengthVar)

	runtime.KeepAlive(ContentTypeVarBytes)

	runtime.KeepAlive(RespBodyVarBytes)

}

var xServerMessageSetStatus func(uintptr, uint, uintptr)

// Sets @msg's status code to @status_code.
//
// If @status_code is a known value and @reason_phrase is %NULL, the
// reason_phrase will be set automatically.
func (x *ServerMessage) SetStatus(StatusCodeVar uint, ReasonPhraseVar *string) {

	ReasonPhraseVarPtr, ReasonPhraseVarBytes := core.NullableStringToPtr(ReasonPhraseVar)

	xServerMessageSetStatus(x.GoPointer(), StatusCodeVar, ReasonPhraseVarPtr)

	runtime.KeepAlive(ReasonPhraseVarBytes)

}

var xServerMessageStealConnection func(uintptr) uintptr

// "Steals" the HTTP connection associated with @msg from its #SoupServer. This
// happens immediately, regardless of the current state of the connection; if
// the response to @msg has not yet finished being sent, then it will be
// discarded; you can steal the connection from a
// [signal@ServerMessage::wrote-informational] or
// [signal@ServerMessage::wrote-body] signal handler if you need to wait for
// part or all of the response to be sent.
//
// Note that when calling this function from C, @msg will most
// likely be freed as a side effect.
func (x *ServerMessage) StealConnection() *gio.IOStream {
	var cls *gio.IOStream

	cret := xServerMessageStealConnection(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gio.IOStream{}
	cls.Ptr = cret
	return cls
}

var xServerMessageUnpause func(uintptr)

// Resumes I/O on @msg.
//
// Use this to resume after calling [method@ServerMessage.pause], or after
// adding a new chunk to a chunked response. I/O won't actually resume until you
// return to the main loop.
func (x *ServerMessage) Unpause() {

	xServerMessageUnpause(x.GoPointer())

}

func (c *ServerMessage) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *ServerMessage) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emitted during the @msg's connection TLS handshake
// after client TLS certificate has been received.
// You can return %TRUE to accept @tls_certificate despite
// @tls_errors.
func (x *ServerMessage) ConnectAcceptCertificate(cb *func(ServerMessage, uintptr, gio.TlsCertificateFlags) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "accept-certificate", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, TlsPeerCertificateVarp uintptr, TlsPeerErrorsVarp gio.TlsCertificateFlags) bool {
		fa := ServerMessage{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, TlsPeerCertificateVarp, TlsPeerErrorsVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "accept-certificate", cbRefPtr)
}

// Emitted when the @msg's socket is connected and the TLS handshake completed.
func (x *ServerMessage) ConnectConnected(cb *func(ServerMessage)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "connected", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := ServerMessage{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "connected", cbRefPtr)
}

// Emitted when the @msg's socket is disconnected.
func (x *ServerMessage) ConnectDisconnected(cb *func(ServerMessage)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "disconnected", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := ServerMessage{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "disconnected", cbRefPtr)
}

// Emitted when all HTTP processing is finished for a message.
// (After [signal@ServerMessage::wrote-body]).
func (x *ServerMessage) ConnectFinished(cb *func(ServerMessage)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "finished", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := ServerMessage{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "finished", cbRefPtr)
}

// Emitted after receiving the complete request body.
func (x *ServerMessage) ConnectGotBody(cb *func(ServerMessage)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "got-body", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := ServerMessage{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "got-body", cbRefPtr)
}

// Emitted after receiving a chunk of a message body.
//
// Note that "chunk" in this context means any subpiece of the body, not
// necessarily the specific HTTP 1.1 chunks sent by the other side.
func (x *ServerMessage) ConnectGotChunk(cb *func(ServerMessage, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "got-chunk", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ChunkVarp uintptr) {
		fa := ServerMessage{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ChunkVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "got-chunk", cbRefPtr)
}

// Emitted after receiving the Request-Line and request headers.
func (x *ServerMessage) ConnectGotHeaders(cb *func(ServerMessage)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "got-headers", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := ServerMessage{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "got-headers", cbRefPtr)
}

// Emitted immediately after writing the complete response body for a
// message.
func (x *ServerMessage) ConnectWroteBody(cb *func(ServerMessage)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "wrote-body", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := ServerMessage{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "wrote-body", cbRefPtr)
}

// Emitted immediately after writing a portion of the message
// body to the network.
func (x *ServerMessage) ConnectWroteBodyData(cb *func(ServerMessage, uint)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "wrote-body-data", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ChunkSizeVarp uint) {
		fa := ServerMessage{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ChunkSizeVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "wrote-body-data", cbRefPtr)
}

// Emitted immediately after writing a body chunk for a message.
//
// Note that this signal is not parallel to
// [signal@ServerMessage::got-chunk]; it is emitted only when a complete
// chunk (added with [method@MessageBody.append] or
// [method@MessageBody.append_bytes] has been written. To get
// more useful continuous progress information, use
// [signal@ServerMessage::wrote-body-data].
func (x *ServerMessage) ConnectWroteChunk(cb *func(ServerMessage)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "wrote-chunk", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := ServerMessage{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "wrote-chunk", cbRefPtr)
}

// Emitted immediately after writing the response headers for a
// message.
func (x *ServerMessage) ConnectWroteHeaders(cb *func(ServerMessage)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "wrote-headers", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := ServerMessage{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "wrote-headers", cbRefPtr)
}

// Emitted immediately after writing a 1xx (Informational) response.
func (x *ServerMessage) ConnectWroteInformational(cb *func(ServerMessage)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "wrote-informational", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := ServerMessage{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "wrote-informational", cbRefPtr)
}

func init() {
	core.SetPackageName("SOUP", "libsoup-3.0")
	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("SOUP") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xServerMessageGLibType, libs, "soup_server_message_get_type")

	core.PuregoSafeRegister(&xServerMessageGetHttpVersion, libs, "soup_server_message_get_http_version")
	core.PuregoSafeRegister(&xServerMessageGetLocalAddress, libs, "soup_server_message_get_local_address")
	core.PuregoSafeRegister(&xServerMessageGetMethod, libs, "soup_server_message_get_method")
	core.PuregoSafeRegister(&xServerMessageGetReasonPhrase, libs, "soup_server_message_get_reason_phrase")
	core.PuregoSafeRegister(&xServerMessageGetRemoteAddress, libs, "soup_server_message_get_remote_address")
	core.PuregoSafeRegister(&xServerMessageGetRemoteHost, libs, "soup_server_message_get_remote_host")
	core.PuregoSafeRegister(&xServerMessageGetRequestBody, libs, "soup_server_message_get_request_body")
	core.PuregoSafeRegister(&xServerMessageGetRequestHeaders, libs, "soup_server_message_get_request_headers")
	core.PuregoSafeRegister(&xServerMessageGetResponseBody, libs, "soup_server_message_get_response_body")
	core.PuregoSafeRegister(&xServerMessageGetResponseHeaders, libs, "soup_server_message_get_response_headers")
	core.PuregoSafeRegister(&xServerMessageGetSocket, libs, "soup_server_message_get_socket")
	core.PuregoSafeRegister(&xServerMessageGetStatus, libs, "soup_server_message_get_status")
	core.PuregoSafeRegister(&xServerMessageGetTlsPeerCertificate, libs, "soup_server_message_get_tls_peer_certificate")
	core.PuregoSafeRegister(&xServerMessageGetTlsPeerCertificateErrors, libs, "soup_server_message_get_tls_peer_certificate_errors")
	core.PuregoSafeRegister(&xServerMessageGetUri, libs, "soup_server_message_get_uri")
	core.PuregoSafeRegister(&xServerMessageIsOptionsPing, libs, "soup_server_message_is_options_ping")
	core.PuregoSafeRegister(&xServerMessagePause, libs, "soup_server_message_pause")
	core.PuregoSafeRegister(&xServerMessageSetHttpVersion, libs, "soup_server_message_set_http_version")
	core.PuregoSafeRegister(&xServerMessageSetRedirect, libs, "soup_server_message_set_redirect")
	core.PuregoSafeRegister(&xServerMessageSetResponse, libs, "soup_server_message_set_response")
	core.PuregoSafeRegister(&xServerMessageSetStatus, libs, "soup_server_message_set_status")
	core.PuregoSafeRegister(&xServerMessageStealConnection, libs, "soup_server_message_steal_connection")
	core.PuregoSafeRegister(&xServerMessageUnpause, libs, "soup_server_message_unpause")

}
