// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package soup

import (
	"runtime"
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type MessageClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass
}

func (x *MessageClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Various flags that can be set on a #SoupMessage to alter its
// behavior.
type MessageFlags int

var xMessageFlagsGLibType func() types.GType

func MessageFlagsGLibType() types.GType {
	return xMessageFlagsGLibType()
}

const (

	// The session should not follow redirect
	//   (3xx) responses received by this message.
	MessageNoRedirectValue MessageFlags = 2
	// Requests that the message should be
	//   sent on a newly-created connection, not reusing an existing
	//   persistent connection. Note that messages with non-idempotent
	//   [property@Message:method]s behave this way by default, unless
	//   #SOUP_MESSAGE_IDEMPOTENT is set.
	MessageNewConnectionValue MessageFlags = 4
	// The message is considered idempotent,
	//   regardless its [property@Message:method], and allows reuse of existing
	//   idle connections, instead of always requiring a new one, unless
	//   #SOUP_MESSAGE_NEW_CONNECTION is set.
	MessageIdempotentValue MessageFlags = 8
	// The [class@AuthManager] should not use
	//   the credentials cache for this message, neither to use cached credentials
	//   to automatically authenticate this message nor to cache the credentials
	//   after the message is successfully authenticated. This applies to both server
	//   and proxy authentication. Note that [signal@Message::authenticate] signal will
	//   be emitted, if you want to disable authentication for a message use
	//   [method@Message.disable_feature] passing #SOUP_TYPE_AUTH_MANAGER instead.
	MessageDoNotUseAuthCacheValue MessageFlags = 16
	// Metrics will be collected for this message.
	MessageCollectMetricsValue MessageFlags = 32
)

// Priorities that can be set on a [class@Message] to instruct the message queue
// to process it before any other message with lower priority.
type MessagePriority int

var xMessagePriorityGLibType func() types.GType

func MessagePriorityGLibType() types.GType {
	return xMessagePriorityGLibType()
}

const (

	// The lowest priority, the messages
	//   with this priority will be the last ones to be attended.
	MessagePriorityVeryLowValue MessagePriority = 0
	// Use this for low priority messages, a
	//   #SoupMessage with the default priority will be processed first.
	MessagePriorityLowValue MessagePriority = 1
	// The default priotity, this is the
	//   priority assigned to the #SoupMessage by default.
	MessagePriorityNormalValue MessagePriority = 2
	// High priority, a #SoupMessage with
	//   this priority will be processed before the ones with the default
	//   priority.
	MessagePriorityHighValue MessagePriority = 3
	// The highest priority, use this
	//   for very urgent #SoupMessage as they will be the first ones to be
	//   attended.
	MessagePriorityVeryHighValue MessagePriority = 4
)

// Represents an HTTP message being sent or received.
//
// A #SoupMessage represents an HTTP message that is being sent or
// received.
//
// You would create a #SoupMessage with [ctor@Message.new] or
// [ctor@Message.new_from_uri], set up its fields appropriately, and send it.
//
// [property@Message:status-code] will normally be a [enum@Status] value, eg,
// %SOUP_STATUS_OK, though of course it might actually be an unknown status
// code. [property@Message:reason-phrase] is the actual text returned from the
// server, which may or may not correspond to the "standard" description of
// @status_code. At any rate, it is almost certainly not localized, and not very
// descriptive even if it is in the user's language; you should not use
// [property@Message:reason-phrase] in user-visible messages. Rather, you should
// look at [property@Message:status-code], and determine an end-user-appropriate
// message based on that and on what you were trying to do.
//
// Note that libsoup's terminology here does not quite match the HTTP
// specification: in RFC 2616, an "HTTP-message" is *either* a Request, *or* a
// Response. In libsoup, a #SoupMessage combines both the request and the
// response.
type Message struct {
	gobject.Object
}

var xMessageGLibType func() types.GType

func MessageGLibType() types.GType {
	return xMessageGLibType()
}

func MessageNewFromInternalPtr(ptr uintptr) *Message {
	cls := &Message{}
	cls.Ptr = ptr
	return cls
}

var xNewMessage func(string, string) uintptr

// Creates a new empty #SoupMessage, which will connect to @uri.
func NewMessage(MethodVar string, UriStringVar string) *Message {
	var cls *Message

	cret := xNewMessage(MethodVar, UriStringVar)

	if cret == 0 {
		return nil
	}
	cls = &Message{}
	cls.Ptr = cret
	return cls
}

var xNewMessageFromEncodedForm func(string, string, string) uintptr

// Creates a new #SoupMessage and sets it up to send the given @encoded_form
// to @uri via @method. If @method is "GET", it will include the form data
// into @uri's query field, and if @method is "POST" or "PUT", it will be set as
// request body.
//
// This function takes the ownership of @encoded_form, that will be released
// with [func@GLib.free] when no longer in use. See also [func@form_encode],
// [func@form_encode_hash] and [func@form_encode_datalist].
func NewMessageFromEncodedForm(MethodVar string, UriStringVar string, EncodedFormVar string) *Message {
	var cls *Message

	cret := xNewMessageFromEncodedForm(MethodVar, UriStringVar, EncodedFormVar)

	if cret == 0 {
		return nil
	}
	cls = &Message{}
	cls.Ptr = cret
	return cls
}

var xNewMessageFromMultipart func(string, *Multipart) uintptr

// Creates a new #SoupMessage and sets it up to send @multipart to
// @uri_string via POST.
func NewMessageFromMultipart(UriStringVar string, MultipartVar *Multipart) *Message {
	var cls *Message

	cret := xNewMessageFromMultipart(UriStringVar, MultipartVar)

	if cret == 0 {
		return nil
	}
	cls = &Message{}
	cls.Ptr = cret
	return cls
}

var xNewMessageFromUri func(string, *glib.Uri) uintptr

// Creates a new empty #SoupMessage, which will connect to @uri.
func NewMessageFromUri(MethodVar string, UriVar *glib.Uri) *Message {
	var cls *Message

	cret := xNewMessageFromUri(MethodVar, UriVar)

	if cret == 0 {
		return nil
	}
	cls = &Message{}
	cls.Ptr = cret
	return cls
}

var xNewMessageOptionsPing func(*glib.Uri) uintptr

// Creates a new #SoupMessage to send `OPTIONS *` to a server. The path of
// @base_uri will be ignored.
func NewMessageOptionsPing(BaseUriVar *glib.Uri) *Message {
	var cls *Message

	cret := xNewMessageOptionsPing(BaseUriVar)

	if cret == 0 {
		return nil
	}
	cls = &Message{}
	cls.Ptr = cret
	return cls
}

var xMessageAddFlags func(uintptr, MessageFlags)

// Adds @flags to the set of @msg's flags.
func (x *Message) AddFlags(FlagsVar MessageFlags) {

	xMessageAddFlags(x.GoPointer(), FlagsVar)

}

var xMessageAddHeaderHandler func(uintptr, string, string, uintptr, uintptr) uint

// Adds a signal handler to @msg for @signal.
//
// Similar to [func@GObject.signal_connect], but the @callback will only be run
// if @msg's incoming messages headers (that is, the `request_headers`) contain
// a header named @header.
func (x *Message) AddHeaderHandler(SignalVar string, HeaderVar string, CallbackVar *gobject.Callback, UserDataVar uintptr) uint {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func() {
				cbFn := *CallbackVar
				cbFn()
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CallbackVarPtr, CallbackVarRef, CallbackVar)
		}
	}

	cret := xMessageAddHeaderHandler(x.GoPointer(), SignalVar, HeaderVar, CallbackVarRef, UserDataVar)

	return cret
}

var xMessageAddStatusCodeHandler func(uintptr, string, uint, uintptr, uintptr) uint

// Adds a signal handler to @msg for @signal.
//
// Similar to [func@GObject.signal_connect], but the @callback will only be run
// if @msg has the status @status_code.
//
// @signal must be a signal that will be emitted after @msg's status
// is set (this means it can't be a "wrote" signal).
func (x *Message) AddStatusCodeHandler(SignalVar string, StatusCodeVar uint, CallbackVar *gobject.Callback, UserDataVar uintptr) uint {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func() {
				cbFn := *CallbackVar
				cbFn()
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallbackWithClosure(CallbackVarPtr, CallbackVarRef, CallbackVar)
		}
	}

	cret := xMessageAddStatusCodeHandler(x.GoPointer(), SignalVar, StatusCodeVar, CallbackVarRef, UserDataVar)

	return cret
}

var xMessageDisableFeature func(uintptr, types.GType)

// Disables the actions of [iface@SessionFeature]s with the
// given @feature_type (or a subclass of that type) on @msg.
//
// @msg is processed as though the feature(s) hadn't been added to the
// session. Eg, passing #SOUP_TYPE_CONTENT_SNIFFER for @feature_type
// will disable Content-Type sniffing on the message.
//
// You must call this before queueing @msg on a session; calling it on
// a message that has already been queued is undefined. In particular,
// you cannot call this on a message that is being requeued after a
// redirect or authentication.
func (x *Message) DisableFeature(FeatureTypeVar types.GType) {

	xMessageDisableFeature(x.GoPointer(), FeatureTypeVar)

}

var xMessageGetConnectionId func(uintptr) uint64

// Returns the unique idenfier for the last connection used.
//
// This may be 0 if it was a cached resource or it has not gotten
// a connection yet.
func (x *Message) GetConnectionId() uint64 {

	cret := xMessageGetConnectionId(x.GoPointer())

	return cret
}

var xMessageGetFirstParty func(uintptr) *glib.Uri

// Gets @msg's first-party [struct@GLib.Uri].
func (x *Message) GetFirstParty() *glib.Uri {

	cret := xMessageGetFirstParty(x.GoPointer())

	return cret
}

var xMessageGetFlags func(uintptr) MessageFlags

// Gets the flags on @msg.
func (x *Message) GetFlags() MessageFlags {

	cret := xMessageGetFlags(x.GoPointer())

	return cret
}

var xMessageGetForceHttp1 func(uintptr) bool

// Returns whether HTTP/1 version is currently demanded for the @msg send.
func (x *Message) GetForceHttp1() bool {

	cret := xMessageGetForceHttp1(x.GoPointer())

	return cret
}

var xMessageGetHttpVersion func(uintptr) HTTPVersion

// Gets the HTTP version of @msg.
//
// This is the minimum of the version from the request and the version from the
// response.
func (x *Message) GetHttpVersion() HTTPVersion {

	cret := xMessageGetHttpVersion(x.GoPointer())

	return cret
}

var xMessageGetIsOptionsPing func(uintptr) bool

// Gets whether @msg is intended to be used to send `OPTIONS *` to a server.
func (x *Message) GetIsOptionsPing() bool {

	cret := xMessageGetIsOptionsPing(x.GoPointer())

	return cret
}

var xMessageGetIsTopLevelNavigation func(uintptr) bool

// Returns if this message is set as a top level navigation.
//
// Used for same-site policy checks.
func (x *Message) GetIsTopLevelNavigation() bool {

	cret := xMessageGetIsTopLevelNavigation(x.GoPointer())

	return cret
}

var xMessageGetMethod func(uintptr) string

// Returns the method of this message.
func (x *Message) GetMethod() string {

	cret := xMessageGetMethod(x.GoPointer())

	return cret
}

var xMessageGetMetrics func(uintptr) *MessageMetrics

// Get the [struct@MessageMetrics] of @msg.
//
// If the flag %SOUP_MESSAGE_COLLECT_METRICS is not enabled for @msg this will
// return %NULL.
func (x *Message) GetMetrics() *MessageMetrics {

	cret := xMessageGetMetrics(x.GoPointer())

	return cret
}

var xMessageGetPriority func(uintptr) MessagePriority

// Retrieves the [enum@MessagePriority].
//
// If not set this value defaults to #SOUP_MESSAGE_PRIORITY_NORMAL.
func (x *Message) GetPriority() MessagePriority {

	cret := xMessageGetPriority(x.GoPointer())

	return cret
}

var xMessageGetReasonPhrase func(uintptr) string

// Returns the reason phrase for the status of this message.
func (x *Message) GetReasonPhrase() string {

	cret := xMessageGetReasonPhrase(x.GoPointer())

	return cret
}

var xMessageGetRemoteAddress func(uintptr) uintptr

// Get the remote [class@Gio.SocketAddress] of the connection associated with
// the message.
//
// The returned address can be %NULL if the connection hasn't been established
// yet, or the resource was loaded from the disk cache. In case of proxy
// connections, the remote address returned is a [class@Gio.ProxyAddress]. If
// [property@Session:remote-connectable] is set the returned address id for the
// connection to the session's remote connectable.
func (x *Message) GetRemoteAddress() *gio.SocketAddress {
	var cls *gio.SocketAddress

	cret := xMessageGetRemoteAddress(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.SocketAddress{}
	cls.Ptr = cret
	return cls
}

var xMessageGetRequestHeaders func(uintptr) *MessageHeaders

// Returns the headers sent with the request.
func (x *Message) GetRequestHeaders() *MessageHeaders {

	cret := xMessageGetRequestHeaders(x.GoPointer())

	return cret
}

var xMessageGetResponseHeaders func(uintptr) *MessageHeaders

// Returns the headers recieved with the response.
func (x *Message) GetResponseHeaders() *MessageHeaders {

	cret := xMessageGetResponseHeaders(x.GoPointer())

	return cret
}

var xMessageGetSiteForCookies func(uintptr) *glib.Uri

// Gets @msg's site for cookies #GUri.
func (x *Message) GetSiteForCookies() *glib.Uri {

	cret := xMessageGetSiteForCookies(x.GoPointer())

	return cret
}

var xMessageGetStatus func(uintptr) Status

// Returns the set status of this message.
func (x *Message) GetStatus() Status {

	cret := xMessageGetStatus(x.GoPointer())

	return cret
}

var xMessageGetTlsCiphersuiteName func(uintptr) string

// Gets the name of the TLS ciphersuite negotiated for @msg's connection.
func (x *Message) GetTlsCiphersuiteName() string {

	cret := xMessageGetTlsCiphersuiteName(x.GoPointer())

	return cret
}

var xMessageGetTlsPeerCertificate func(uintptr) uintptr

// Gets the peer's [class@Gio.TlsCertificate] associated with @msg's connection.
//
// Note that this is not set yet during the emission of
// [signal@Message::accept-certificate] signal.
func (x *Message) GetTlsPeerCertificate() *gio.TlsCertificate {
	var cls *gio.TlsCertificate

	cret := xMessageGetTlsPeerCertificate(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.TlsCertificate{}
	cls.Ptr = cret
	return cls
}

var xMessageGetTlsPeerCertificateErrors func(uintptr) gio.TlsCertificateFlags

// Gets the errors associated with validating @msg's TLS peer certificate.
// Note that this is not set yet during the emission of
// [signal@Message::accept-certificate] signal.
func (x *Message) GetTlsPeerCertificateErrors() gio.TlsCertificateFlags {

	cret := xMessageGetTlsPeerCertificateErrors(x.GoPointer())

	return cret
}

var xMessageGetTlsProtocolVersion func(uintptr) gio.TlsProtocolVersion

// Gets the TLS protocol version negotiated for @msg's connection.
//
// If the message connection is not SSL, %G_TLS_PROTOCOL_VERSION_UNKNOWN is returned.
func (x *Message) GetTlsProtocolVersion() gio.TlsProtocolVersion {

	cret := xMessageGetTlsProtocolVersion(x.GoPointer())

	return cret
}

var xMessageGetUri func(uintptr) *glib.Uri

// Gets @msg's URI.
func (x *Message) GetUri() *glib.Uri {

	cret := xMessageGetUri(x.GoPointer())

	return cret
}

var xMessageIsFeatureDisabled func(uintptr, types.GType) bool

// Get whether [iface@SessionFeature]s of the given @feature_type
// (or a subclass of that type) are disabled on @msg.
//
// See [method@Message.disable_feature].
func (x *Message) IsFeatureDisabled(FeatureTypeVar types.GType) bool {

	cret := xMessageIsFeatureDisabled(x.GoPointer(), FeatureTypeVar)

	return cret
}

var xMessageIsKeepalive func(uintptr) bool

// Determines whether or not @msg's connection can be kept alive for
// further requests after processing @msg.
//
// The result is based on the HTTP version, Connection header, etc.
func (x *Message) IsKeepalive() bool {

	cret := xMessageIsKeepalive(x.GoPointer())

	return cret
}

var xMessageQueryFlags func(uintptr, MessageFlags) bool

// Queries if @flags are present in the set of @msg's flags.
func (x *Message) QueryFlags(FlagsVar MessageFlags) bool {

	cret := xMessageQueryFlags(x.GoPointer(), FlagsVar)

	return cret
}

var xMessageRemoveFlags func(uintptr, MessageFlags)

// Removes @flags from the set of @msg's flags.
func (x *Message) RemoveFlags(FlagsVar MessageFlags) {

	xMessageRemoveFlags(x.GoPointer(), FlagsVar)

}

var xMessageSetFirstParty func(uintptr, *glib.Uri)

// Sets @first_party as the main document #GUri for @msg.
//
// For details of when and how this is used refer to the documentation for
// [enum@CookieJarAcceptPolicy].
func (x *Message) SetFirstParty(FirstPartyVar *glib.Uri) {

	xMessageSetFirstParty(x.GoPointer(), FirstPartyVar)

}

var xMessageSetFlags func(uintptr, MessageFlags)

// Sets the specified flags on @msg.
func (x *Message) SetFlags(FlagsVar MessageFlags) {

	xMessageSetFlags(x.GoPointer(), FlagsVar)

}

var xMessageSetForceHttp1 func(uintptr, bool)

// Sets whether HTTP/1 version should be used when sending this message.
// Some connections can still override it, if needed.
//
// Note the value is unset after the message send is finished.
func (x *Message) SetForceHttp1(ValueVar bool) {

	xMessageSetForceHttp1(x.GoPointer(), ValueVar)

}

var xMessageSetIsOptionsPing func(uintptr, bool)

// Set whether @msg is intended to be used to send `OPTIONS *` to a server.
//
// When set to %TRUE, the path of [property@Message:uri] will be ignored and
// [property@Message:method] set to %SOUP_METHOD_OPTIONS.
func (x *Message) SetIsOptionsPing(IsOptionsPingVar bool) {

	xMessageSetIsOptionsPing(x.GoPointer(), IsOptionsPingVar)

}

var xMessageSetIsTopLevelNavigation func(uintptr, bool)

// Sets whether the current request is a top-level navitation.
//
// See the [same-site spec](https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00)
// for more information.
func (x *Message) SetIsTopLevelNavigation(IsTopLevelNavigationVar bool) {

	xMessageSetIsTopLevelNavigation(x.GoPointer(), IsTopLevelNavigationVar)

}

var xMessageSetMethod func(uintptr, string)

// Set @msg's HTTP method to @method.
func (x *Message) SetMethod(MethodVar string) {

	xMessageSetMethod(x.GoPointer(), MethodVar)

}

var xMessageSetPriority func(uintptr, MessagePriority)

// Sets the priority of a message.
//
// Note that this won't have any effect unless used before the message is added
// to the session's message processing queue.
//
// The message will be placed just before any other previously added
// message with lower priority (messages with the same priority are
// processed on a FIFO basis).
//
// Setting priorities does not currently work with synchronous messages
// because in the synchronous/blocking case, priority ends up being determined
// semi-randomly by thread scheduling.
func (x *Message) SetPriority(PriorityVar MessagePriority) {

	xMessageSetPriority(x.GoPointer(), PriorityVar)

}

var xMessageSetRequestBody func(uintptr, uintptr, uintptr, int)

// Set the request body of a #SoupMessage.
//
// If @content_type is %NULL and @stream is not %NULL the Content-Type header will
// not be changed if present.
// The request body needs to be set again in case @msg is restarted
// (in case of redirection or authentication).
func (x *Message) SetRequestBody(ContentTypeVar *string, StreamVar *gio.InputStream, ContentLengthVar int) {

	ContentTypeVarPtr, ContentTypeVarBytes := core.NullableStringToPtr(ContentTypeVar)

	xMessageSetRequestBody(x.GoPointer(), ContentTypeVarPtr, StreamVar.GoPointer(), ContentLengthVar)

	runtime.KeepAlive(ContentTypeVarBytes)

}

var xMessageSetRequestBodyFromBytes func(uintptr, uintptr, *glib.Bytes)

// Set the request body of a #SoupMessage from [struct@GLib.Bytes].
//
// If @content_type is %NULL and @bytes is not %NULL the Content-Type header will
// not be changed if present.
// The request body needs to be set again in case @msg is restarted
// (in case of redirection or authentication).
func (x *Message) SetRequestBodyFromBytes(ContentTypeVar *string, BytesVar *glib.Bytes) {

	ContentTypeVarPtr, ContentTypeVarBytes := core.NullableStringToPtr(ContentTypeVar)

	xMessageSetRequestBodyFromBytes(x.GoPointer(), ContentTypeVarPtr, BytesVar)

	runtime.KeepAlive(ContentTypeVarBytes)

}

var xMessageSetSiteForCookies func(uintptr, *glib.Uri)

// Sets @site_for_cookies as the policy URL for same-site cookies for @msg.
//
// It is either the URL of the top-level document or %NULL depending on whether
// the registrable domain of this document's URL matches the registrable domain
// of its parent's/opener's URL. For the top-level document it is set to the
// document's URL.
//
// See the [same-site spec](https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00)
// for more information.
func (x *Message) SetSiteForCookies(SiteForCookiesVar *glib.Uri) {

	xMessageSetSiteForCookies(x.GoPointer(), SiteForCookiesVar)

}

var xMessageSetTlsClientCertificate func(uintptr, uintptr)

// Sets the @certificate to be used by @msg's connection when a
// client certificate is requested during the TLS handshake.
//
// You can call this as a response to [signal@Message::request-certificate]
// signal, or before the connection is started. If @certificate is %NULL
// the handshake will continue without providing a GTlsCertificate.
// Note that the [class@Gio.TlsCertificate] set by this function will be ignored if
// [property@Session:tls-interaction] is not %NULL.
func (x *Message) SetTlsClientCertificate(CertificateVar *gio.TlsCertificate) {

	xMessageSetTlsClientCertificate(x.GoPointer(), CertificateVar.GoPointer())

}

var xMessageSetUri func(uintptr, *glib.Uri)

// Sets @msg's URI to @uri.
//
// If @msg has already been sent and you want to re-send it with the new URI,
// you need to send it again.
func (x *Message) SetUri(UriVar *glib.Uri) {

	xMessageSetUri(x.GoPointer(), UriVar)

}

var xMessageTlsClientCertificatePasswordRequestComplete func(uintptr)

// Completes a certificate password request.
//
// You must call this as a response to
// [signal@Message::request-certificate-password] signal, to notify @msg that
// the [class@Gio.TlsPassword] has already been updated.
func (x *Message) TlsClientCertificatePasswordRequestComplete() {

	xMessageTlsClientCertificatePasswordRequestComplete(x.GoPointer())

}

func (c *Message) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *Message) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyFirstParty sets the "first-party" property.
// The [struct@GLib.Uri] loaded in the application when the message was
// queued.
func (x *Message) SetPropertyFirstParty(value uintptr) {
	var v gobject.Value
	v.Init(gobject.TypePointerVal)
	v.SetPointer(value)
	x.SetProperty("first-party", &v)
}

// GetPropertyFirstParty gets the "first-party" property.
// The [struct@GLib.Uri] loaded in the application when the message was
// queued.
func (x *Message) GetPropertyFirstParty() uintptr {
	var v gobject.Value
	x.GetProperty("first-party", &v)
	return v.GetPointer()
}

// SetPropertyIsOptionsPing sets the "is-options-ping" property.
// Whether the message is an OPTIONS ping.
//
// The #SoupMessage is intended to be used to send
// `OPTIONS *` to a server. When set to %TRUE, the
// path of [property@Message:uri] will be ignored and
// [property@Message:method] set to %SOUP_METHOD_OPTIONS.
func (x *Message) SetPropertyIsOptionsPing(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("is-options-ping", &v)
}

// GetPropertyIsOptionsPing gets the "is-options-ping" property.
// Whether the message is an OPTIONS ping.
//
// The #SoupMessage is intended to be used to send
// `OPTIONS *` to a server. When set to %TRUE, the
// path of [property@Message:uri] will be ignored and
// [property@Message:method] set to %SOUP_METHOD_OPTIONS.
func (x *Message) GetPropertyIsOptionsPing() bool {
	var v gobject.Value
	x.GetProperty("is-options-ping", &v)
	return v.GetBoolean()
}

// SetPropertyIsTopLevelNavigation sets the "is-top-level-navigation" property.
// Set when the message is navigating between top level domains.
func (x *Message) SetPropertyIsTopLevelNavigation(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("is-top-level-navigation", &v)
}

// GetPropertyIsTopLevelNavigation gets the "is-top-level-navigation" property.
// Set when the message is navigating between top level domains.
func (x *Message) GetPropertyIsTopLevelNavigation() bool {
	var v gobject.Value
	x.GetProperty("is-top-level-navigation", &v)
	return v.GetBoolean()
}

// SetPropertyMethod sets the "method" property.
// The message's HTTP method.
func (x *Message) SetPropertyMethod(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("method", &v)
}

// GetPropertyMethod gets the "method" property.
// The message's HTTP method.
func (x *Message) GetPropertyMethod() string {
	var v gobject.Value
	x.GetProperty("method", &v)
	return v.GetString()
}

// GetPropertyReasonPhrase gets the "reason-phrase" property.
// The HTTP response reason phrase.
func (x *Message) GetPropertyReasonPhrase() string {
	var v gobject.Value
	x.GetProperty("reason-phrase", &v)
	return v.GetString()
}

// GetPropertyRequestHeaders gets the "request-headers" property.
// The HTTP request headers.
func (x *Message) GetPropertyRequestHeaders() uintptr {
	var v gobject.Value
	x.GetProperty("request-headers", &v)
	return v.GetPointer()
}

// GetPropertyResponseHeaders gets the "response-headers" property.
// The HTTP response headers.
func (x *Message) GetPropertyResponseHeaders() uintptr {
	var v gobject.Value
	x.GetProperty("response-headers", &v)
	return v.GetPointer()
}

// SetPropertySiteForCookies sets the "site-for-cookies" property.
// Site used to compare cookies against. Used for SameSite cookie support.
func (x *Message) SetPropertySiteForCookies(value uintptr) {
	var v gobject.Value
	v.Init(gobject.TypePointerVal)
	v.SetPointer(value)
	x.SetProperty("site-for-cookies", &v)
}

// GetPropertySiteForCookies gets the "site-for-cookies" property.
// Site used to compare cookies against. Used for SameSite cookie support.
func (x *Message) GetPropertySiteForCookies() uintptr {
	var v gobject.Value
	x.GetProperty("site-for-cookies", &v)
	return v.GetPointer()
}

// GetPropertyStatusCode gets the "status-code" property.
// The HTTP response status code.
func (x *Message) GetPropertyStatusCode() uint {
	var v gobject.Value
	x.GetProperty("status-code", &v)
	return v.GetUint()
}

// GetPropertyTlsCiphersuiteName gets the "tls-ciphersuite-name" property.
// The Name of TLS ciphersuite negotiated for this message connection.
func (x *Message) GetPropertyTlsCiphersuiteName() string {
	var v gobject.Value
	x.GetProperty("tls-ciphersuite-name", &v)
	return v.GetString()
}

// SetPropertyUri sets the "uri" property.
// The message's Request-URI.
func (x *Message) SetPropertyUri(value uintptr) {
	var v gobject.Value
	v.Init(gobject.TypePointerVal)
	v.SetPointer(value)
	x.SetProperty("uri", &v)
}

// GetPropertyUri gets the "uri" property.
// The message's Request-URI.
func (x *Message) GetPropertyUri() uintptr {
	var v gobject.Value
	x.GetProperty("uri", &v)
	return v.GetPointer()
}

// Emitted during the @msg's connection TLS handshake
// after an unacceptable TLS certificate has been received.
//
// You can return %TRUE to accept @tls_certificate despite
// @tls_errors.
func (x *Message) ConnectAcceptCertificate(cb *func(Message, uintptr, gio.TlsCertificateFlags) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "accept-certificate", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, TlsPeerCertificateVarp uintptr, TlsPeerErrorsVarp gio.TlsCertificateFlags) bool {
		fa := Message{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, TlsPeerCertificateVarp, TlsPeerErrorsVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "accept-certificate", cbRefPtr)
}

// Emitted when the message requires authentication.
//
// If credentials are available call [method@Auth.authenticate] on
// @auth. If these credentials fail, the signal will be emitted again,
// with @retrying set to %TRUE, which will continue until you return
// without calling [method@Auth.authenticate] on @auth.
//
// Note that this may be emitted before @msg's body has been
// fully read.
//
// You can authenticate @auth asynchronously by calling
// [method@GObject.Object.ref] on @auth and returning %TRUE. The operation will
// complete once either [method@Auth.authenticate] or
// [method@Auth.cancel] are called.
func (x *Message) ConnectAuthenticate(cb *func(Message, uintptr, bool) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "authenticate", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, AuthVarp uintptr, RetryingVarp bool) bool {
		fa := Message{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, AuthVarp, RetryingVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "authenticate", cbRefPtr)
}

// This signal is emitted after [signal@Message::got-headers].
//
// If content sniffing is disabled, or no content sniffing will be
// performed, due to the sniffer deciding to trust the
// Content-Type sent by the server, this signal is emitted
// immediately after [signal@Message::got-headers], and @type is
// %NULL.
func (x *Message) ConnectContentSniffed(cb *func(Message, string, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "content-sniffed", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, TypeVarp string, ParamsVarp uintptr) {
		fa := Message{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, TypeVarp, ParamsVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "content-sniffed", cbRefPtr)
}

// Emitted when all HTTP processing is finished for a message.
//
// (After [signal@Message::got_body]).
func (x *Message) ConnectFinished(cb *func(Message)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "finished", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Message{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "finished", cbRefPtr)
}

// Emitted after receiving the complete message response body.
func (x *Message) ConnectGotBody(cb *func(Message)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "got-body", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Message{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "got-body", cbRefPtr)
}

// Emitted after reading a portion of the message
// body from the network.
func (x *Message) ConnectGotBodyData(cb *func(Message, uint)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "got-body-data", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ChunkSizeVarp uint) {
		fa := Message{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ChunkSizeVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "got-body-data", cbRefPtr)
}

// Emitted after receiving the Status-Line and response headers.
//
// See also [method@Message.add_header_handler] and
// [method@Message.add_status_code_handler], which can be used to
// connect to a subset of emissions of this signal.
//
// If you cancel or requeue @msg while processing this signal,
// then the current HTTP I/O will be stopped after this signal
// emission finished, and @msg's connection will be closed.
// (If you need to requeue a message--eg, after handling
// authentication or redirection--it is usually better to
// requeue it from a [signal@Message::got-body] handler rather
// than a [signal@Message::got_headers] handler, so that the
// existing HTTP connection can be reused.)
func (x *Message) ConnectGotHeaders(cb *func(Message)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "got-headers", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Message{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "got-headers", cbRefPtr)
}

// Emitted after receiving a 1xx (Informational) response for
// a (client-side) message.
//
// The response_headers will be filled in with the headers associated
// with the informational response; however, those header values will be
// erased after this signal is done.
//
// If you cancel or requeue @msg while processing this signal,
// then the current HTTP I/O will be stopped after this signal
// emission finished, and @msg's connection will be closed.
func (x *Message) ConnectGotInformational(cb *func(Message)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "got-informational", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Message{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "got-informational", cbRefPtr)
}

// Emitted when [class@HSTSEnforcer] has upgraded the protocol
// for @msg to HTTPS as a result of matching its domain with
// a HSTS policy.
func (x *Message) ConnectHstsEnforced(cb *func(Message)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "hsts-enforced", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Message{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "hsts-enforced", cbRefPtr)
}

// Emitted to indicate that some network-related event
// related to @msg has occurred.
//
// This essentially proxies the [signal@Gio.SocketClient::event] signal,
// but only for events that occur while @msg "owns" the connection; if
// @msg is sent on an existing persistent connection, then this signal
// will not be emitted. (If you want to force the message to be sent on
// a new connection, set the %SOUP_MESSAGE_NEW_CONNECTION flag on it.)
//
// See [signal@Gio.SocketClient::event] for more information on what
// the different values of @event correspond to, and what
// @connection will be in each case.
func (x *Message) ConnectNetworkEvent(cb *func(Message, gio.SocketClientEvent, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "network-event", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, EventVarp gio.SocketClientEvent, ConnectionVarp uintptr) {
		fa := Message{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, EventVarp, ConnectionVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "network-event", cbRefPtr)
}

// Emitted during the @msg's connection TLS handshake when
// @tls_connection requests a certificate from the client.
//
// You can set the client certificate by calling
// [method@Message.set_tls_client_certificate] and returning %TRUE. It's
// possible to handle the request asynchornously by returning %TRUE and
// call [method@Message.set_tls_client_certificate] later once the
// certificate is available. Note that this signal is not emitted if
// [property@Session:tls-interaction] was set, or if
// [method@Message.set_tls_client_certificate] was called before the
// connection TLS handshake started.
func (x *Message) ConnectRequestCertificate(cb *func(Message, uintptr) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "request-certificate", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, TlsConnectionVarp uintptr) bool {
		fa := Message{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, TlsConnectionVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "request-certificate", cbRefPtr)
}

// Emitted during the @msg's connection TLS handshake when
// @tls_connection requests a certificate password from the client.
//
// You can set the certificate password on @password, then call
// [method@Message.tls_client_certificate_password_request_complete] and
// return %TRUE to handle the signal synchronously. It's possible to
// handle the request asynchornously by calling
// [method@GObject.Object.ref] on @password, then returning %TRUE and
// call
// [method@Message.tls_client_certificate_password_request_complete]
// later after setting the password on @password. Note that this signal
// is not emitted if [property@Session:tls-interaction] was set.
func (x *Message) ConnectRequestCertificatePassword(cb *func(Message, uintptr) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "request-certificate-password", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, TlsPasswordVarp uintptr) bool {
		fa := Message{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, TlsPasswordVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "request-certificate-password", cbRefPtr)
}

// Emitted when a request that was already sent once is now
// being sent again.
//
// e.g. because the first attempt received a
// redirection response, or because we needed to use
// authentication.
func (x *Message) ConnectRestarted(cb *func(Message)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "restarted", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Message{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "restarted", cbRefPtr)
}

// Emitted just before a message is sent.
func (x *Message) ConnectStarting(cb *func(Message)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "starting", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Message{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "starting", cbRefPtr)
}

// Emitted immediately after writing the complete body for a
// message.
func (x *Message) ConnectWroteBody(cb *func(Message)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "wrote-body", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Message{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "wrote-body", cbRefPtr)
}

// Emitted immediately after writing a portion of the message
// body to the network.
func (x *Message) ConnectWroteBodyData(cb *func(Message, uint)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "wrote-body-data", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ChunkSizeVarp uint) {
		fa := Message{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ChunkSizeVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "wrote-body-data", cbRefPtr)
}

// Emitted immediately after writing the request headers for a
// message.
func (x *Message) ConnectWroteHeaders(cb *func(Message)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "wrote-headers", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := Message{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "wrote-headers", cbRefPtr)
}

func init() {
	core.SetPackageName("SOUP", "libsoup-3.0")
	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("SOUP") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xMessageFlagsGLibType, libs, "soup_message_flags_get_type")

	core.PuregoSafeRegister(&xMessagePriorityGLibType, libs, "soup_message_priority_get_type")

	core.PuregoSafeRegister(&xMessageGLibType, libs, "soup_message_get_type")

	core.PuregoSafeRegister(&xNewMessage, libs, "soup_message_new")
	core.PuregoSafeRegister(&xNewMessageFromEncodedForm, libs, "soup_message_new_from_encoded_form")
	core.PuregoSafeRegister(&xNewMessageFromMultipart, libs, "soup_message_new_from_multipart")
	core.PuregoSafeRegister(&xNewMessageFromUri, libs, "soup_message_new_from_uri")
	core.PuregoSafeRegister(&xNewMessageOptionsPing, libs, "soup_message_new_options_ping")

	core.PuregoSafeRegister(&xMessageAddFlags, libs, "soup_message_add_flags")
	core.PuregoSafeRegister(&xMessageAddHeaderHandler, libs, "soup_message_add_header_handler")
	core.PuregoSafeRegister(&xMessageAddStatusCodeHandler, libs, "soup_message_add_status_code_handler")
	core.PuregoSafeRegister(&xMessageDisableFeature, libs, "soup_message_disable_feature")
	core.PuregoSafeRegister(&xMessageGetConnectionId, libs, "soup_message_get_connection_id")
	core.PuregoSafeRegister(&xMessageGetFirstParty, libs, "soup_message_get_first_party")
	core.PuregoSafeRegister(&xMessageGetFlags, libs, "soup_message_get_flags")
	core.PuregoSafeRegister(&xMessageGetForceHttp1, libs, "soup_message_get_force_http1")
	core.PuregoSafeRegister(&xMessageGetHttpVersion, libs, "soup_message_get_http_version")
	core.PuregoSafeRegister(&xMessageGetIsOptionsPing, libs, "soup_message_get_is_options_ping")
	core.PuregoSafeRegister(&xMessageGetIsTopLevelNavigation, libs, "soup_message_get_is_top_level_navigation")
	core.PuregoSafeRegister(&xMessageGetMethod, libs, "soup_message_get_method")
	core.PuregoSafeRegister(&xMessageGetMetrics, libs, "soup_message_get_metrics")
	core.PuregoSafeRegister(&xMessageGetPriority, libs, "soup_message_get_priority")
	core.PuregoSafeRegister(&xMessageGetReasonPhrase, libs, "soup_message_get_reason_phrase")
	core.PuregoSafeRegister(&xMessageGetRemoteAddress, libs, "soup_message_get_remote_address")
	core.PuregoSafeRegister(&xMessageGetRequestHeaders, libs, "soup_message_get_request_headers")
	core.PuregoSafeRegister(&xMessageGetResponseHeaders, libs, "soup_message_get_response_headers")
	core.PuregoSafeRegister(&xMessageGetSiteForCookies, libs, "soup_message_get_site_for_cookies")
	core.PuregoSafeRegister(&xMessageGetStatus, libs, "soup_message_get_status")
	core.PuregoSafeRegister(&xMessageGetTlsCiphersuiteName, libs, "soup_message_get_tls_ciphersuite_name")
	core.PuregoSafeRegister(&xMessageGetTlsPeerCertificate, libs, "soup_message_get_tls_peer_certificate")
	core.PuregoSafeRegister(&xMessageGetTlsPeerCertificateErrors, libs, "soup_message_get_tls_peer_certificate_errors")
	core.PuregoSafeRegister(&xMessageGetTlsProtocolVersion, libs, "soup_message_get_tls_protocol_version")
	core.PuregoSafeRegister(&xMessageGetUri, libs, "soup_message_get_uri")
	core.PuregoSafeRegister(&xMessageIsFeatureDisabled, libs, "soup_message_is_feature_disabled")
	core.PuregoSafeRegister(&xMessageIsKeepalive, libs, "soup_message_is_keepalive")
	core.PuregoSafeRegister(&xMessageQueryFlags, libs, "soup_message_query_flags")
	core.PuregoSafeRegister(&xMessageRemoveFlags, libs, "soup_message_remove_flags")
	core.PuregoSafeRegister(&xMessageSetFirstParty, libs, "soup_message_set_first_party")
	core.PuregoSafeRegister(&xMessageSetFlags, libs, "soup_message_set_flags")
	core.PuregoSafeRegister(&xMessageSetForceHttp1, libs, "soup_message_set_force_http1")
	core.PuregoSafeRegister(&xMessageSetIsOptionsPing, libs, "soup_message_set_is_options_ping")
	core.PuregoSafeRegister(&xMessageSetIsTopLevelNavigation, libs, "soup_message_set_is_top_level_navigation")
	core.PuregoSafeRegister(&xMessageSetMethod, libs, "soup_message_set_method")
	core.PuregoSafeRegister(&xMessageSetPriority, libs, "soup_message_set_priority")
	core.PuregoSafeRegister(&xMessageSetRequestBody, libs, "soup_message_set_request_body")
	core.PuregoSafeRegister(&xMessageSetRequestBodyFromBytes, libs, "soup_message_set_request_body_from_bytes")
	core.PuregoSafeRegister(&xMessageSetSiteForCookies, libs, "soup_message_set_site_for_cookies")
	core.PuregoSafeRegister(&xMessageSetTlsClientCertificate, libs, "soup_message_set_tls_client_certificate")
	core.PuregoSafeRegister(&xMessageSetUri, libs, "soup_message_set_uri")
	core.PuregoSafeRegister(&xMessageTlsClientCertificatePasswordRequestComplete, libs, "soup_message_tls_client_certificate_password_request_complete")

}
