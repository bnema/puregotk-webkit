// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package soup

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// Class structure for #SoupHSTSEnforcer.
type HSTSEnforcerClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass

	xIsPersistent uintptr

	xHasValidPolicy uintptr

	xChanged uintptr

	Padding [4]uintptr
}

func (x *HSTSEnforcerClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideIsPersistent sets the "is_persistent" callback function.
// The @is_persistent function advertises whether the enforcer is persistent or
// whether changes made to it will be lost when the underlying [class@Session] is finished.
func (x *HSTSEnforcerClass) OverrideIsPersistent(cb func(*HSTSEnforcer) bool) {
	if cb == nil {
		x.xIsPersistent = 0
	} else {
		x.xIsPersistent = purego.NewCallback(func(HstsEnforcerVarp uintptr) bool {
			return cb(HSTSEnforcerNewFromInternalPtr(HstsEnforcerVarp))
		})
	}
}

// GetIsPersistent gets the "is_persistent" callback function.
// The @is_persistent function advertises whether the enforcer is persistent or
// whether changes made to it will be lost when the underlying [class@Session] is finished.
func (x *HSTSEnforcerClass) GetIsPersistent() func(*HSTSEnforcer) bool {
	if x.xIsPersistent == 0 {
		return nil
	}
	var rawCallback func(HstsEnforcerVarp uintptr) bool
	purego.RegisterFunc(&rawCallback, x.xIsPersistent)
	return func(HstsEnforcerVar *HSTSEnforcer) bool {
		return rawCallback(HstsEnforcerVar.GoPointer())
	}
}

// OverrideHasValidPolicy sets the "has_valid_policy" callback function.
// The @has_valid_policy function is called to check whether there is a valid
// policy for the given domain. This method should return %TRUE for #SoupHSTSEnforcer to
// change the scheme of the #GUri in the #SoupMessage to HTTPS. Implementations might want to
// chain up to the @has_valid_policy in the parent class to check, for instance, for runtime
// policies.
func (x *HSTSEnforcerClass) OverrideHasValidPolicy(cb func(*HSTSEnforcer, string) bool) {
	if cb == nil {
		x.xHasValidPolicy = 0
	} else {
		x.xHasValidPolicy = purego.NewCallback(func(HstsEnforcerVarp uintptr, DomainVarp string) bool {
			return cb(HSTSEnforcerNewFromInternalPtr(HstsEnforcerVarp), DomainVarp)
		})
	}
}

// GetHasValidPolicy gets the "has_valid_policy" callback function.
// The @has_valid_policy function is called to check whether there is a valid
// policy for the given domain. This method should return %TRUE for #SoupHSTSEnforcer to
// change the scheme of the #GUri in the #SoupMessage to HTTPS. Implementations might want to
// chain up to the @has_valid_policy in the parent class to check, for instance, for runtime
// policies.
func (x *HSTSEnforcerClass) GetHasValidPolicy() func(*HSTSEnforcer, string) bool {
	if x.xHasValidPolicy == 0 {
		return nil
	}
	var rawCallback func(HstsEnforcerVarp uintptr, DomainVarp string) bool
	purego.RegisterFunc(&rawCallback, x.xHasValidPolicy)
	return func(HstsEnforcerVar *HSTSEnforcer, DomainVar string) bool {
		return rawCallback(HstsEnforcerVar.GoPointer(), DomainVar)
	}
}

// OverrideChanged sets the "changed" callback function.
// The class closure for the #SoupHSTSEnforcer::changed signal.
func (x *HSTSEnforcerClass) OverrideChanged(cb func(*HSTSEnforcer, *HSTSPolicy, *HSTSPolicy)) {
	if cb == nil {
		x.xChanged = 0
	} else {
		x.xChanged = purego.NewCallback(func(EnforcerVarp uintptr, OldPolicyVarp *HSTSPolicy, NewPolicyVarp *HSTSPolicy) {
			cb(HSTSEnforcerNewFromInternalPtr(EnforcerVarp), OldPolicyVarp, NewPolicyVarp)
		})
	}
}

// GetChanged gets the "changed" callback function.
// The class closure for the #SoupHSTSEnforcer::changed signal.
func (x *HSTSEnforcerClass) GetChanged() func(*HSTSEnforcer, *HSTSPolicy, *HSTSPolicy) {
	if x.xChanged == 0 {
		return nil
	}
	var rawCallback func(EnforcerVarp uintptr, OldPolicyVarp *HSTSPolicy, NewPolicyVarp *HSTSPolicy)
	purego.RegisterFunc(&rawCallback, x.xChanged)
	return func(EnforcerVar *HSTSEnforcer, OldPolicyVar *HSTSPolicy, NewPolicyVar *HSTSPolicy) {
		rawCallback(EnforcerVar.GoPointer(), OldPolicyVar, NewPolicyVar)
	}
}

// Automatic HTTP Strict Transport Security enforcing for [class@Session].
//
// A #SoupHSTSEnforcer stores HSTS policies and enforces them when
// required. #SoupHSTSEnforcer implements [iface@SessionFeature], so you
// can add an HSTS enforcer to a session with
// [method@Session.add_feature] or [method@Session.add_feature_by_type].
//
// #SoupHSTSEnforcer keeps track of all the HTTPS destinations that,
// when connected to, return the Strict-Transport-Security header with
// valid values. #SoupHSTSEnforcer will forget those destinations
// upon expiry or when the server requests it.
//
// When the [class@Session] the #SoupHSTSEnforcer is attached to queues or
// restarts a message, the #SoupHSTSEnforcer will rewrite the URI to HTTPS if
// the destination is a known HSTS host and is contacted over an insecure
// transport protocol (HTTP). Users of #SoupHSTSEnforcer are advised to listen
// to changes in the [property@Message:uri] property in order to be aware of
// changes in the message URI.
//
// Note that #SoupHSTSEnforcer does not support any form of long-term
// HSTS policy persistence. See [class@HSTSEnforcerDB] for a persistent
// enforcer.
type HSTSEnforcer struct {
	gobject.Object
}

var xHSTSEnforcerGLibType func() types.GType

func HSTSEnforcerGLibType() types.GType {
	return xHSTSEnforcerGLibType()
}

func HSTSEnforcerNewFromInternalPtr(ptr uintptr) *HSTSEnforcer {
	cls := &HSTSEnforcer{}
	cls.Ptr = ptr
	return cls
}

var xNewHSTSEnforcer func() uintptr

// Creates a new #SoupHSTSEnforcer.
//
// The base #SoupHSTSEnforcer class does not support persistent storage of HSTS
// policies, see [class@HSTSEnforcerDB] for that.
func NewHSTSEnforcer() *HSTSEnforcer {
	var cls *HSTSEnforcer

	cret := xNewHSTSEnforcer()

	if cret == 0 {
		return nil
	}
	cls = &HSTSEnforcer{}
	cls.Ptr = cret
	return cls
}

var xHSTSEnforcerGetDomains func(uintptr, bool) *glib.List

// Gets a list of domains for which there are policies in @enforcer.
func (x *HSTSEnforcer) GetDomains(SessionPoliciesVar bool) *glib.List {

	cret := xHSTSEnforcerGetDomains(x.GoPointer(), SessionPoliciesVar)
	return cret
}

var xHSTSEnforcerGetPolicies func(uintptr, bool) *glib.List

// Gets a list with the policies in @enforcer.
func (x *HSTSEnforcer) GetPolicies(SessionPoliciesVar bool) *glib.List {

	cret := xHSTSEnforcerGetPolicies(x.GoPointer(), SessionPoliciesVar)
	return cret
}

var xHSTSEnforcerHasValidPolicy func(uintptr, string) bool

// Gets whether @hsts_enforcer has a currently valid policy for @domain.
func (x *HSTSEnforcer) HasValidPolicy(DomainVar string) bool {

	cret := xHSTSEnforcerHasValidPolicy(x.GoPointer(), DomainVar)
	return cret
}

var xHSTSEnforcerIsPersistent func(uintptr) bool

// Gets whether @hsts_enforcer stores policies persistenly.
func (x *HSTSEnforcer) IsPersistent() bool {

	cret := xHSTSEnforcerIsPersistent(x.GoPointer())
	return cret
}

var xHSTSEnforcerSetPolicy func(uintptr, *HSTSPolicy)

// Sets @policy to @hsts_enforcer.
//
// If @policy is expired, any existing HSTS policy for its host will be removed
// instead. If a policy existed for this host, it will be replaced. Otherwise,
// the new policy will be inserted. If the policy is a session policy, that is,
// one created with [ctor@HSTSPolicy.new_session_policy], the policy will not
// expire and will be enforced during the lifetime of @hsts_enforcer's
// [class@Session].
func (x *HSTSEnforcer) SetPolicy(PolicyVar *HSTSPolicy) {

	xHSTSEnforcerSetPolicy(x.GoPointer(), PolicyVar)

}

var xHSTSEnforcerSetSessionPolicy func(uintptr, string, bool)

// Sets a session policy for @domain.
//
// A session policy is a policy that is permanent to the lifetime of
// @hsts_enforcer's [class@Session] and doesn't expire.
func (x *HSTSEnforcer) SetSessionPolicy(DomainVar string, IncludeSubdomainsVar bool) {

	xHSTSEnforcerSetSessionPolicy(x.GoPointer(), DomainVar, IncludeSubdomainsVar)

}

func (c *HSTSEnforcer) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *HSTSEnforcer) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emitted when @hsts_enforcer changes.
//
// If a policy has been added,
// @new_policy will contain the newly-added policy and
// @old_policy will be %NULL. If a policy has been deleted,
// @old_policy will contain the to-be-deleted policy and
// @new_policy will be %NULL. If a policy has been changed,
// @old_policy will contain its old value, and @new_policy its
// new value.
//
// Note that you shouldn't modify the policies from a callback to
// this signal.
func (x *HSTSEnforcer) ConnectChanged(cb *func(HSTSEnforcer, uintptr, uintptr)) uint {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		handlerID := gobject.SignalConnect(x.GoPointer(), "changed", cbRefPtr)
		glib.SaveHandlerMapping(handlerID, cbPtr)
		return handlerID
	}

	fcb := func(clsPtr uintptr, OldPolicyVarp uintptr, NewPolicyVarp uintptr) {
		fa := HSTSEnforcer{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, OldPolicyVarp, NewPolicyVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	handlerID := gobject.SignalConnect(x.GoPointer(), "changed", cbRefPtr)
	glib.SaveHandlerMapping(handlerID, cbPtr)
	return handlerID
}

func init() {
	core.SetPackageName("SOUP", "libsoup-3.0")
	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("SOUP") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xHSTSEnforcerGLibType, libs, "soup_hsts_enforcer_get_type")

	core.PuregoSafeRegister(&xNewHSTSEnforcer, libs, "soup_hsts_enforcer_new")

	core.PuregoSafeRegister(&xHSTSEnforcerGetDomains, libs, "soup_hsts_enforcer_get_domains")
	core.PuregoSafeRegister(&xHSTSEnforcerGetPolicies, libs, "soup_hsts_enforcer_get_policies")
	core.PuregoSafeRegister(&xHSTSEnforcerHasValidPolicy, libs, "soup_hsts_enforcer_has_valid_policy")
	core.PuregoSafeRegister(&xHSTSEnforcerIsPersistent, libs, "soup_hsts_enforcer_is_persistent")
	core.PuregoSafeRegister(&xHSTSEnforcerSetPolicy, libs, "soup_hsts_enforcer_set_policy")
	core.PuregoSafeRegister(&xHSTSEnforcerSetSessionPolicy, libs, "soup_hsts_enforcer_set_session_policy")

}
