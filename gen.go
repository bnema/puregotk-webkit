package main

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/jwijenbergh/puregotk/pkg/gir/pass"
	"github.com/jwijenbergh/puregotk/pkg/gir/util"
)

//go:generate go run gen.go

// Namespaces to generate (others are for type resolution only)
var localNamespaces = map[string]bool{
	"WebKit":                    true,
	"JavaScriptCore":            true,
	"WebKitWebProcessExtension": true,
	"Soup":                      true,
}

func main() {
	dir := "."
	// Clean up previously generated packages
	for ns := range localNamespaces {
		os.RemoveAll(strings.ToLower(ns))
	}

	var girs []string
	filepath.Walk("internal/gir/spec", func(path string, f os.FileInfo, err error) error {
		if !strings.HasSuffix(path, ".gir") {
			return nil
		}
		girs = append(girs, path)
		return nil
	})

	p, err := pass.New(girs)
	if err != nil {
		panic(err)
	}

	// Collect ALL types for resolution (including base GTK types)
	p.First()

	// Filter to only generate WebKit namespaces
	var filtered []pass.Repository
	for _, r := range p.Parsed {
		ns := r.Namespaces[0].Name
		if localNamespaces[ns] {
			filtered = append(filtered, r)
		}
	}
	p.Parsed = filtered

	// Create the template
	gotemp, err := template.New("go").Funcs(template.FuncMap{
		"conv":     util.ConvertArgs,
		"convc":    util.ConvertArgsComma,
		"convcb":   util.ConvertCallbackArgs,
		"convcd":   util.ConvertArgsCommaDeref,
		"convd":    util.ConvertArgsDeref,
		"convcbne": util.ConvertCallbackArgsNoErr,
		"propsset": util.PropertyScalarSet,
		"propsget": util.PropertyScalarGet,
		"propvset": util.PropertyVectorSet,
		"propvget": util.PropertyVectorGet,
	}).ParseFiles("templates/go")
	if err != nil {
		panic(err)
	}

	// Write go files by making the second pass
	p.Second(dir, gotemp)

	// Manual fix for soup/gio.byte error
	fixSoupGioByte(dir)

	if err := writeWebViewExtras(dir); err != nil {
		panic(err)
	}

	if err := writeWebContextExtras(dir); err != nil {
		panic(err)
	}
}

func fixSoupGioByte(dir string) {
	path := filepath.Join(dir, "soup", "soup-multipart-input-stream.go")
	content, err := os.ReadFile(path)
	if err != nil {
		fmt.Println("Warning: could not fix gio.byte in soup-multipart-input-stream.go (file not found)")
		return
	}
	newContent := strings.ReplaceAll(string(content), "gio.byte", "byte")
	if err := os.WriteFile(path, []byte(newContent), 0644); err != nil {
		fmt.Println("Warning: failed to write fix for gio.byte in soup-multipart-input-stream.go")
	}
}

// writeWebContextExtras adds manually-crafted APIs for WebContext construct-only properties.
func writeWebContextExtras(dir string) error {
	const webContextExtras = `// Code generated by puregotk-webkit extras; DO NOT EDIT.
package webkit

import (
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

// WebContextOptions contains construct-only properties for creating a WebContext.
// All fields are optional - only non-nil values will be applied.
type WebContextOptions struct {
	// MemoryPressureSettings configures memory limits and thresholds for web processes.
	MemoryPressureSettings *MemoryPressureSettings

	// TimeZoneOverride sets the timezone for all webviews in this context.
	// Expected values are IANA timezone database identifiers (e.g. "America/New_York").
	TimeZoneOverride string
}

// NewWebContextWithOptions creates a new WebContext with the specified construct-only properties.
// This is necessary because properties like "memory-pressure-settings" can only be set at construction time.
func NewWebContextWithOptions(opts *WebContextOptions) *WebContext {
	if opts == nil {
		return NewWebContext()
	}

	var names []string
	var values []gobject.Value

	if opts.MemoryPressureSettings != nil {
		var v gobject.Value
		// MemoryPressureSettings is a boxed type, use its GType and SetBoxed
		v.Init(MemoryPressureSettingsGLibType())
		v.SetBoxed(opts.MemoryPressureSettings.GoPointer())
		names = append(names, "memory-pressure-settings")
		values = append(values, v)
	}

	if opts.TimeZoneOverride != "" {
		var v gobject.Value
		v.Init(gobject.TypeStringVal)
		v.SetString(&opts.TimeZoneOverride)
		names = append(names, "time-zone-override")
		values = append(values, v)
	}

	if len(names) == 0 {
		return NewWebContext()
	}

	obj := gobject.NewObjectWithProperties(
		WebContextGLibType(),
		uint(len(names)),
		names,
		values,
	)
	if obj == nil {
		return nil
	}

	ctx := &WebContext{}
	ctx.Ptr = obj.Ptr
	return ctx
}

// NewWebContextWithMemoryPressureSettings creates a new WebContext with memory pressure settings.
// This is a convenience wrapper around NewWebContextWithOptions for the common case of only
// setting memory pressure settings.
func NewWebContextWithMemoryPressureSettings(settings *MemoryPressureSettings) *WebContext {
	if settings == nil {
		return NewWebContext()
	}
	return NewWebContextWithOptions(&WebContextOptions{MemoryPressureSettings: settings})
}
`
	webkitDir := filepath.Join(dir, "webkit")
	if err := os.MkdirAll(webkitDir, 0o755); err != nil {
		return err
	}
	path := filepath.Join(webkitDir, "WebKitWebContextExtras.go")
	return os.WriteFile(path, []byte(webContextExtras), 0o644)
}

// writeWebViewExtras adds manually-crafted APIs that are not present in the GIR
// but are available via construct-only properties (e.g. related-view).
func writeWebViewExtras(dir string) error {
	const webViewExtras = `// Code generated by puregotk-webkit extras; DO NOT EDIT.
package webkit

import (
	"github.com/jwijenbergh/puregotk/v4/gobject"
)

// WebViewOptions contains construct-only properties for creating a WebView.
// All fields are optional - only non-nil values will be applied.
type WebViewOptions struct {
	// NetworkSession for cookie/data persistence. Required for persistent sessions.
	NetworkSession *NetworkSession

	// UserContentManager for script injection and content filtering.
	UserContentManager *UserContentManager

	// RelatedView to share WebContext and NetworkSession with (for popups).
	RelatedView *WebView

	// WebsitePolicies for autoplay and other website-specific policies.
	WebsitePolicies *WebsitePolicies

	// DefaultContentSecurityPolicy sets the default CSP for all pages.
	DefaultContentSecurityPolicy string

	// IsControlledByAutomation enables automation/WebDriver mode.
	IsControlledByAutomation bool

	// AutomationPresentationType specifies window vs tab presentation for automation.
	AutomationPresentationType AutomationBrowsingContextPresentation
}

// NewWebViewWithOptions creates a new WebView with the specified construct-only properties.
// This is the most flexible way to create a WebView, allowing any combination of options.
func NewWebViewWithOptions(opts *WebViewOptions) *WebView {
	if opts == nil {
		return NewWebView()
	}

	var names []string
	var values []gobject.Value

	if opts.NetworkSession != nil {
		var v gobject.Value
		v.Init(NetworkSessionGLibType())
		obj := gobject.Object{Ptr: opts.NetworkSession.GoPointer()}
		v.SetObject(&obj)
		names = append(names, "network-session")
		values = append(values, v)
	}

	if opts.UserContentManager != nil {
		var v gobject.Value
		v.Init(UserContentManagerGLibType())
		obj := gobject.Object{Ptr: opts.UserContentManager.GoPointer()}
		v.SetObject(&obj)
		names = append(names, "user-content-manager")
		values = append(values, v)
	}

	if opts.RelatedView != nil {
		var v gobject.Value
		v.Init(WebViewGLibType())
		obj := gobject.Object{Ptr: opts.RelatedView.GoPointer()}
		v.SetObject(&obj)
		names = append(names, "related-view")
		values = append(values, v)
	}

	if opts.WebsitePolicies != nil {
		var v gobject.Value
		v.Init(WebsitePoliciesGLibType())
		obj := gobject.Object{Ptr: opts.WebsitePolicies.GoPointer()}
		v.SetObject(&obj)
		names = append(names, "website-policies")
		values = append(values, v)
	}

	if opts.DefaultContentSecurityPolicy != "" {
		var v gobject.Value
		v.Init(gobject.TypeStringVal)
		v.SetString(&opts.DefaultContentSecurityPolicy)
		names = append(names, "default-content-security-policy")
		values = append(values, v)
	}

	if opts.IsControlledByAutomation {
		var v gobject.Value
		v.Init(gobject.TypeBooleanVal)
		v.SetBoolean(true)
		names = append(names, "is-controlled-by-automation")
		values = append(values, v)

		// Also set automation presentation type when automation is enabled
		var vType gobject.Value
		vType.Init(AutomationBrowsingContextPresentationGLibType())
		vType.SetEnum(int(opts.AutomationPresentationType))
		names = append(names, "automation-presentation-type")
		values = append(values, vType)
	}

	if len(names) == 0 {
		return NewWebView()
	}

	obj := gobject.NewObjectWithProperties(
		WebViewGLibType(),
		uint(len(names)),
		names,
		values,
	)
	if obj == nil {
		return nil
	}

	gobject.IncreaseRef(obj.GoPointer())

	view := &WebView{}
	view.Ptr = obj.Ptr
	return view
}

// NewWebViewWithRelatedView creates a new WebView that shares the same
// WebContext and NetworkSession as the provided related view. This is required
// for popup windows (window.open/target=_blank) to share cookies/session data.
func NewWebViewWithRelatedView(relatedView *WebView) *WebView {
	if relatedView == nil {
		return NewWebView()
	}
	return NewWebViewWithOptions(&WebViewOptions{RelatedView: relatedView})
}

// NewWebViewWithNetworkSession creates a new WebView using the specified NetworkSession.
// This is required for cookie/data persistence across sessions.
func NewWebViewWithNetworkSession(session *NetworkSession) *WebView {
	if session == nil {
		return NewWebView()
	}
	return NewWebViewWithOptions(&WebViewOptions{NetworkSession: session})
}

// NavigationActionFromPointer wraps a raw pointer from the "create" signal into
// a NavigationAction copy so callers don't need unsafe in their code. The
// returned NavigationAction should be freed with (*NavigationAction).Free() when
// no longer needed.
func NavigationActionFromPointer(ptr uintptr) *NavigationAction {
	if ptr == 0 {
		return nil
	}
	return xNavigationActionCopy(ptr)
}
`
	webkitDir := filepath.Join(dir, "webkit")
	if err := os.MkdirAll(webkitDir, 0o755); err != nil {
		return err
	}
	path := filepath.Join(webkitDir, "WebKitWebViewExtras.go")
	return os.WriteFile(path, []byte(webViewExtras), 0o644)
}
