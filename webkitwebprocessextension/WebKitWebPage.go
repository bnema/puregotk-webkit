// Package webkitwebprocessextension was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package webkitwebprocessextension

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type WebPageClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass
}

func (x *WebPageClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// A loaded web page.
type WebPage struct {
	gobject.Object
}

var xWebPageGLibType func() types.GType

func WebPageGLibType() types.GType {
	return xWebPageGLibType()
}

func WebPageNewFromInternalPtr(ptr uintptr) *WebPage {
	cls := &WebPage{}
	cls.Ptr = ptr
	return cls
}

var xWebPageGetEditor func(uintptr) uintptr

// Gets the #WebKitWebEditor of a #WebKitWebPage.
func (x *WebPage) GetEditor() *WebEditor {
	var cls *WebEditor

	cret := xWebPageGetEditor(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &WebEditor{}
	cls.Ptr = cret
	return cls
}

var xWebPageGetFormManager func(uintptr, uintptr) uintptr

// Get the #WebKitWebFormManager of @web_page in @world.
func (x *WebPage) GetFormManager(WorldVar *ScriptWorld) *WebFormManager {
	var cls *WebFormManager

	cret := xWebPageGetFormManager(x.GoPointer(), WorldVar.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &WebFormManager{}
	cls.Ptr = cret
	return cls
}

var xWebPageGetId func(uintptr) uint64

// Get the identifier of the #WebKitWebPage
func (x *WebPage) GetId() uint64 {

	cret := xWebPageGetId(x.GoPointer())
	return cret
}

var xWebPageGetMainFrame func(uintptr) uintptr

// Returns the main frame of a #WebKitWebPage.
func (x *WebPage) GetMainFrame() *Frame {
	var cls *Frame

	cret := xWebPageGetMainFrame(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Frame{}
	cls.Ptr = cret
	return cls
}

var xWebPageGetUri func(uintptr) string

// Returns the current active URI of @web_page.
//
// You can monitor the active URI by connecting to the notify::uri
// signal of @web_page.
func (x *WebPage) GetUri() string {

	cret := xWebPageGetUri(x.GoPointer())
	return cret
}

var xWebPageSendMessageToView func(uintptr, uintptr, uintptr, uintptr, uintptr)

// Send @message to the #WebKitWebView corresponding to @web_page. If @message is floating, it's consumed.
//
// If you don't expect any reply, or you simply want to ignore it, you can pass %NULL as @callback.
// When the operation is finished, @callback will be called. You can then call
// webkit_web_page_send_message_to_view_finish() to get the message reply.
func (x *WebPage) SendMessageToView(MessageVar *UserMessage, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *CallbackVar
				cbFn(arg0, arg1, arg2)
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(CallbackVarPtr, CallbackVarRef)
		}
	}

	xWebPageSendMessageToView(x.GoPointer(), MessageVar.GoPointer(), CancellableVar.GoPointer(), CallbackVarRef, UserDataVar)

}

var xWebPageSendMessageToViewFinish func(uintptr, uintptr, **glib.Error) uintptr

// Finish an asynchronous operation started with webkit_web_page_send_message_to_view().
func (x *WebPage) SendMessageToViewFinish(ResultVar gio.AsyncResult) (*UserMessage, error) {
	var cls *UserMessage
	var cerr *glib.Error

	cret := xWebPageSendMessageToViewFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &UserMessage{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

func (c *WebPage) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *WebPage) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// GetPropertyUri gets the "uri" property.
// The current active URI of the #WebKitWebPage.
func (x *WebPage) GetPropertyUri() string {
	var v gobject.Value
	x.GetProperty("uri", &v)
	return v.GetString()
}

// Emitted when a message is sent to the console. This can be a message
// produced by the use of JavaScript console API, a JavaScript exception,
// a security error or other errors, warnings, debug or log messages.
// The @console_message contains information of the message.
func (x *WebPage) ConnectConsoleMessageSent(cb *func(WebPage, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "console-message-sent", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ConsoleMessageVarp uintptr) {
		fa := WebPage{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, ConsoleMessageVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "console-message-sent", cbRefPtr)
}

// Emitted before a context menu is displayed in the UI Process to
// give the application a chance to customize the proposed menu,
// build its own context menu or pass user data to the UI Process.
// This signal is useful when the information available in the UI Process
// is not enough to build or customize the context menu, for example, to
// add menu entries depending on the node at the coordinates of the
// @hit_test_result. Otherwise, it's recommended to use #WebKitWebView::context-menu
// signal instead.
func (x *WebPage) ConnectContextMenu(cb *func(WebPage, uintptr, uintptr) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "context-menu", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, ContextMenuVarp uintptr, HitTestResultVarp uintptr) bool {
		fa := WebPage{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, ContextMenuVarp, HitTestResultVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "context-menu", cbRefPtr)
}

// This signal is emitted when the DOM document of a #WebKitWebPage has been
// loaded.
//
// You can wait for this signal to get the DOM document
func (x *WebPage) ConnectDocumentLoaded(cb *func(WebPage)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "document-loaded", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := WebPage{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "document-loaded", cbRefPtr)
}

// This signal is emitted when @request is about to be sent to
// the server. This signal can be used to modify the #WebKitURIRequest
// that will be sent to the server. You can also cancel the resource load
// operation by connecting to this signal and returning %TRUE.
//
// In case of a server redirection this signal is
// emitted again with the @request argument containing the new
// request to be sent to the server due to the redirection and the
// @redirected_response parameter containing the response
// received by the server for the initial request.
//
// Modifications to the #WebKitURIRequest and its associated
// #SoupMessageHeaders will be taken into account when the request
// is sent over the network.
func (x *WebPage) ConnectSendRequest(cb *func(WebPage, uintptr, uintptr) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "send-request", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, RequestVarp uintptr, RedirectedResponseVarp uintptr) bool {
		fa := WebPage{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, RequestVarp, RedirectedResponseVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "send-request", cbRefPtr)
}

// This signal is emitted when a #WebKitUserMessage is received from the
// #WebKitWebView corresponding to @web_page. You can reply to the message
// using webkit_user_message_send_reply().
//
// You can handle the user message asynchronously by calling g_object_ref() on
// @message and returning %TRUE. If the last reference of @message is removed
// and the message has been replied, the operation in the #WebKitWebView will
// finish with error %WEBKIT_USER_MESSAGE_UNHANDLED_MESSAGE.
func (x *WebPage) ConnectUserMessageReceived(cb *func(WebPage, uintptr) bool) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "user-message-received", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, MessageVarp uintptr) bool {
		fa := WebPage{}
		fa.Ptr = clsPtr
		cbFn := *cb

		return cbFn(fa, MessageVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "user-message-received", cbRefPtr)
}

func init() {
	core.SetPackageName("WEBKITWEBPROCESSEXTENSION", "webkitgtk-web-process-extension-6.0")
	core.SetSharedLibraries("WEBKITWEBPROCESSEXTENSION", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("WEBKITWEBPROCESSEXTENSION") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xWebPageGLibType, libs, "webkit_web_page_get_type")

	core.PuregoSafeRegister(&xWebPageGetEditor, libs, "webkit_web_page_get_editor")
	core.PuregoSafeRegister(&xWebPageGetFormManager, libs, "webkit_web_page_get_form_manager")
	core.PuregoSafeRegister(&xWebPageGetId, libs, "webkit_web_page_get_id")
	core.PuregoSafeRegister(&xWebPageGetMainFrame, libs, "webkit_web_page_get_main_frame")
	core.PuregoSafeRegister(&xWebPageGetUri, libs, "webkit_web_page_get_uri")
	core.PuregoSafeRegister(&xWebPageSendMessageToView, libs, "webkit_web_page_send_message_to_view")
	core.PuregoSafeRegister(&xWebPageSendMessageToViewFinish, libs, "webkit_web_page_send_message_to_view_finish")

}
