// Package webkitwebprocessextension was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package webkitwebprocessextension

import (
	"structs"
	"unsafe"

	"github.com/bnema/puregotk-webkit/javascriptcore"
	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type WebFormManagerClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass
}

func (x *WebFormManagerClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Form manager of a #WebKitWebPage in a #WebKitScriptWorld
type WebFormManager struct {
	gobject.Object
}

var xWebFormManagerGLibType func() types.GType

func WebFormManagerGLibType() types.GType {
	return xWebFormManagerGLibType()
}

func WebFormManagerNewFromInternalPtr(ptr uintptr) *WebFormManager {
	cls := &WebFormManager{}
	cls.Ptr = ptr
	return cls
}

func (c *WebFormManager) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *WebFormManager) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// Emitted after form elements (or form associated elements) are associated to @frame.
// This is useful to implement form auto filling for web pages where form fields are added
// dynamically. This signal might be emitted multiple times for the same frame.
//
// Note that this signal could be also emitted when form controls are moved between forms. In
// that case, the @elements array carries the list of those elements which have moved.
//
// Clients should take a reference to the members of the @elements array if it is desired to
// keep them alive after the signal handler returns.
func (x *WebFormManager) ConnectFormControlsAssociated(cb *func(WebFormManager, uintptr, []javascriptcore.Value)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "form-controls-associated", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, FrameVarp uintptr, ElementsVarp []javascriptcore.Value) {
		fa := WebFormManager{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, FrameVarp, ElementsVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "form-controls-associated", cbRefPtr)
}

// This signal is emitted when the DOM submit event is about to be fired for @form.
// JavaScript code may rely on the submit event to detect that the user has clicked
// on a submit button, and to possibly cancel the form submission before
// #WebKitWebFormManager::will-submit-form signal is emitted.
// However, beware that, for historical reasons, the submit event is not emitted at
// all if the form submission is triggered by JavaScript. For these reasons,
// this signal may not be used to reliably detect whether a form will be submitted.
// Instead, use it to detect if a user has clicked on a form's submit button even if
// JavaScript later cancels the form submission, or to read the values of the form's
// fields even if JavaScript later clears certain fields before submitting. This may
// be needed, for example, to implement a robust browser password manager, as some
// misguided websites may use such techniques to attempt to thwart password managers.
func (x *WebFormManager) ConnectWillSendSubmitEvent(cb *func(WebFormManager, uintptr, uintptr, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "will-send-submit-event", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, FormVarp uintptr, SourceFrameVarp uintptr, TargetFrameVarp uintptr) {
		fa := WebFormManager{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, FormVarp, SourceFrameVarp, TargetFrameVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "will-send-submit-event", cbRefPtr)
}

// This signal is emitted when @form will imminently be submitted. It can no longer
// be cancelled. This event always occurs immediately before a form is submitted to
// its target, so use this event to reliably detect when a form is submitted. This
// signal is emitted after #WebKitWebFormManager::will-send-submit-event if that
// signal is emitted.
func (x *WebFormManager) ConnectWillSubmitForm(cb *func(WebFormManager, uintptr, uintptr, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "will-submit-form", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, FormVarp uintptr, SourceFrameVarp uintptr, TargetFrameVarp uintptr) {
		fa := WebFormManager{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, FormVarp, SourceFrameVarp, TargetFrameVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallbackWithClosure(cbPtr, cbRefPtr, cb)
	return gobject.SignalConnect(x.GoPointer(), "will-submit-form", cbRefPtr)
}

var xWebFormManagerInputElementAutoFill func(uintptr, string)

// Set the value of an HTML input element as if it had been edited by
// the user, triggering a change event, and set it as filled automatically.
// If @element is not an HTML input element this function does nothing.
func WebFormManagerInputElementAutoFill(ElementVar *javascriptcore.Value, ValueVar string) {

	xWebFormManagerInputElementAutoFill(ElementVar.GoPointer(), ValueVar)

}

var xWebFormManagerInputElementIsAutoFilled func(uintptr) bool

// Get whether @element is an HTML input element that has been filled automatically.
func WebFormManagerInputElementIsAutoFilled(ElementVar *javascriptcore.Value) bool {

	cret := xWebFormManagerInputElementIsAutoFilled(ElementVar.GoPointer())

	return cret
}

var xWebFormManagerInputElementIsUserEdited func(uintptr) bool

// Get whether @element is an HTML text input element that has been edited by a user action.
func WebFormManagerInputElementIsUserEdited(ElementVar *javascriptcore.Value) bool {

	cret := xWebFormManagerInputElementIsUserEdited(ElementVar.GoPointer())

	return cret
}

func init() {
	core.SetPackageName("WEBKITWEBPROCESSEXTENSION", "webkitgtk-web-process-extension-6.0")
	core.SetSharedLibraries("WEBKITWEBPROCESSEXTENSION", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("WEBKITWEBPROCESSEXTENSION") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xWebFormManagerGLibType, libs, "webkit_web_form_manager_get_type")

	core.PuregoSafeRegister(&xWebFormManagerInputElementAutoFill, libs, "webkit_web_form_manager_input_element_auto_fill")
	core.PuregoSafeRegister(&xWebFormManagerInputElementIsAutoFilled, libs, "webkit_web_form_manager_input_element_is_auto_filled")
	core.PuregoSafeRegister(&xWebFormManagerInputElementIsUserEdited, libs, "webkit_web_form_manager_input_element_is_user_edited")

}
