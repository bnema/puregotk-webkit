// Package webkitwebprocessextension was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package webkitwebprocessextension

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

type ContextMenuItemClass struct {
	_ structs.HostLayout

	ParentClass gobject.InitiallyUnownedClass
}

func (x *ContextMenuItemClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// One item of a #WebKitContextMenu.
//
// The #WebKitContextMenu is composed of #WebKitContextMenuItem&lt;!--
// --&gt;s. These items can be created from a #GtkAction, from a
// #WebKitContextMenuAction or from a #WebKitContextMenuAction and a
// label. These #WebKitContextMenuAction&lt;!-- --&gt;s denote stock actions
// for the items. You can also create separators and submenus.
type ContextMenuItem struct {
	gobject.InitiallyUnowned
}

var xContextMenuItemGLibType func() types.GType

func ContextMenuItemGLibType() types.GType {
	return xContextMenuItemGLibType()
}

func ContextMenuItemNewFromInternalPtr(ptr uintptr) *ContextMenuItem {
	cls := &ContextMenuItem{}
	cls.Ptr = ptr
	return cls
}

var xNewContextMenuItemFromGaction func(uintptr, string, *glib.Variant) uintptr

// Creates a new #WebKitContextMenuItem for the given @action and @label.
//
// On activation
// @target will be passed as parameter to the callback.
func NewContextMenuItemFromGaction(ActionVar gio.Action, LabelVar string, TargetVar *glib.Variant) *ContextMenuItem {
	var cls *ContextMenuItem

	cret := xNewContextMenuItemFromGaction(ActionVar.GoPointer(), LabelVar, TargetVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &ContextMenuItem{}
	cls.Ptr = cret
	return cls
}

var xNewContextMenuItemFromStockAction func(ContextMenuAction) uintptr

// Creates a new #WebKitContextMenuItem for the given stock action.
//
// Stock actions are handled automatically by WebKit so that, for example,
// when a menu item created with a %WEBKIT_CONTEXT_MENU_ACTION_STOP is
// activated the action associated will be handled by WebKit and the current
// load operation will be stopped. You can get the #GAction of a
// #WebKitContextMenuItem created with a #WebKitContextMenuAction with
// webkit_context_menu_item_get_gaction() and connect to the #GSimpleAction::activate signal
// to be notified when the item is activated, but you can't prevent the associated
// action from being performed.
func NewContextMenuItemFromStockAction(ActionVar ContextMenuAction) *ContextMenuItem {
	var cls *ContextMenuItem

	cret := xNewContextMenuItemFromStockAction(ActionVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &ContextMenuItem{}
	cls.Ptr = cret
	return cls
}

var xNewContextMenuItemFromStockActionWithLabel func(ContextMenuAction, string) uintptr

// Creates a new #WebKitContextMenuItem for the given stock action using the given @label.
//
// Stock actions have a predefined label, this method can be used to create a
// #WebKitContextMenuItem for a #WebKitContextMenuAction but using a custom label.
func NewContextMenuItemFromStockActionWithLabel(ActionVar ContextMenuAction, LabelVar string) *ContextMenuItem {
	var cls *ContextMenuItem

	cret := xNewContextMenuItemFromStockActionWithLabel(ActionVar, LabelVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &ContextMenuItem{}
	cls.Ptr = cret
	return cls
}

var xNewContextMenuItemSeparator func() uintptr

// Creates a new #WebKitContextMenuItem representing a separator.
func NewContextMenuItemSeparator() *ContextMenuItem {
	var cls *ContextMenuItem

	cret := xNewContextMenuItemSeparator()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &ContextMenuItem{}
	cls.Ptr = cret
	return cls
}

var xNewContextMenuItemWithSubmenu func(string, uintptr) uintptr

// Creates a new #WebKitContextMenuItem using the given @label with a submenu.
func NewContextMenuItemWithSubmenu(LabelVar string, SubmenuVar *ContextMenu) *ContextMenuItem {
	var cls *ContextMenuItem

	cret := xNewContextMenuItemWithSubmenu(LabelVar, SubmenuVar.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &ContextMenuItem{}
	cls.Ptr = cret
	return cls
}

var xContextMenuItemGetGaction func(uintptr) uintptr

// Gets the action associated to @item as a #GAction.
func (x *ContextMenuItem) GetGaction() *gio.ActionBase {
	var cls *gio.ActionBase

	cret := xContextMenuItemGetGaction(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.ActionBase{}
	cls.Ptr = cret
	return cls
}

var xContextMenuItemGetStockAction func(uintptr) ContextMenuAction

// Gets the #WebKitContextMenuAction of @item.
//
// If the #WebKitContextMenuItem was not
// created for a stock action %WEBKIT_CONTEXT_MENU_ACTION_CUSTOM will be
// returned. If the #WebKitContextMenuItem is a separator %WEBKIT_CONTEXT_MENU_ACTION_NO_ACTION
// will be returned.
func (x *ContextMenuItem) GetStockAction() ContextMenuAction {

	cret := xContextMenuItemGetStockAction(x.GoPointer())
	return cret
}

var xContextMenuItemGetSubmenu func(uintptr) uintptr

// Gets the submenu of @item.
func (x *ContextMenuItem) GetSubmenu() *ContextMenu {
	var cls *ContextMenu

	cret := xContextMenuItemGetSubmenu(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &ContextMenu{}
	cls.Ptr = cret
	return cls
}

var xContextMenuItemIsSeparator func(uintptr) bool

// Checks whether @item is a separator.
func (x *ContextMenuItem) IsSeparator() bool {

	cret := xContextMenuItemIsSeparator(x.GoPointer())
	return cret
}

var xContextMenuItemSetSubmenu func(uintptr, uintptr)

// Sets or replaces the @item submenu.
//
// If @submenu is %NULL the current
// submenu of @item is removed.
func (x *ContextMenuItem) SetSubmenu(SubmenuVar *ContextMenu) {

	xContextMenuItemSetSubmenu(x.GoPointer(), SubmenuVar.GoPointer())

}

func (c *ContextMenuItem) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *ContextMenuItem) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	core.SetPackageName("WEBKITWEBPROCESSEXTENSION", "webkitgtk-web-process-extension-6.0")
	core.SetSharedLibraries("WEBKITWEBPROCESSEXTENSION", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("WEBKITWEBPROCESSEXTENSION") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xContextMenuItemGLibType, libs, "webkit_context_menu_item_get_type")

	core.PuregoSafeRegister(&xNewContextMenuItemFromGaction, libs, "webkit_context_menu_item_new_from_gaction")
	core.PuregoSafeRegister(&xNewContextMenuItemFromStockAction, libs, "webkit_context_menu_item_new_from_stock_action")
	core.PuregoSafeRegister(&xNewContextMenuItemFromStockActionWithLabel, libs, "webkit_context_menu_item_new_from_stock_action_with_label")
	core.PuregoSafeRegister(&xNewContextMenuItemSeparator, libs, "webkit_context_menu_item_new_separator")
	core.PuregoSafeRegister(&xNewContextMenuItemWithSubmenu, libs, "webkit_context_menu_item_new_with_submenu")

	core.PuregoSafeRegister(&xContextMenuItemGetGaction, libs, "webkit_context_menu_item_get_gaction")
	core.PuregoSafeRegister(&xContextMenuItemGetStockAction, libs, "webkit_context_menu_item_get_stock_action")
	core.PuregoSafeRegister(&xContextMenuItemGetSubmenu, libs, "webkit_context_menu_item_get_submenu")
	core.PuregoSafeRegister(&xContextMenuItemIsSeparator, libs, "webkit_context_menu_item_is_separator")
	core.PuregoSafeRegister(&xContextMenuItemSetSubmenu, libs, "webkit_context_menu_item_set_submenu")

}
