// Package webkitwebprocessextension was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package webkitwebprocessextension

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// Type definition for a function that will be called to initialize
// the web extension when the web process starts.
type WebProcessExtensionInitializeFunction func(uintptr)

// Type definition for a function that will be called to initialize
// the web extensions when the web process starts, and which receives
// as additional argument the user data set with
// webkit_web_context_set_web_process_extensions_initialization_user_data().
type WebProcessExtensionInitializeWithUserDataFunction func(uintptr, *glib.Variant)

type WebProcessExtensionClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass
}

func (x *WebProcessExtensionClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Represents an extension of the web process.
//
// WebKitWebProcessExtension is a loadable module for the web process. It allows you to execute code in the
// web process and being able to use the DOM API, to change any request or to inject custom
// JavaScript code, for example.
//
// To create a WebKitWebProcessExtension you should write a module with an initialization function that could
// be either webkit_web_process_extension_initialize() with prototype #WebKitWebProcessExtensionInitializeFunction or
// webkit_web_process_extension_initialize_with_user_data() with prototype #WebKitWebProcessExtensionInitializeWithUserDataFunction.
// This function has to be public and it has to use the #G_MODULE_EXPORT macro. It is called when the
// web process is initialized.
//
// ```c
// static void
// web_page_created_callback (WebKitWebProcessExtension *extension,
//
//	WebKitWebPage             *web_page,
//	gpointer                   user_data)
//
//	{
//	    g_print ("Page %d created for %s\n",
//	             webkit_web_page_get_id (web_page),
//	             webkit_web_page_get_uri (web_page));
//	}
//
// G_MODULE_EXPORT void
// webkit_web_process_extension_initialize (WebKitWebProcessExtension *extension)
//
//	{
//	    g_signal_connect (extension, "page-created",
//	                      G_CALLBACK (web_page_created_callback),
//	                      NULL);
//	}
//
// ```
//
// The previous piece of code shows a trivial example of an extension that notifies when
// a #WebKitWebPage is created.
//
// WebKit has to know where it can find the created WebKitWebProcessExtension. To do so you
// should use the webkit_web_context_set_web_extensions_directory() function. The signal
// #WebKitWebContext::initialize-web-extensions is the recommended place to call it.
//
// To provide the initialization data used by the webkit_web_process_extension_initialize_with_user_data()
// function, you have to call webkit_web_context_set_web_extensions_initialization_user_data() with
// the desired data as parameter. You can see an example of this in the following piece of code:
//
// ```c
// #define WEB_EXTENSIONS_DIRECTORY // ...
//
// static void
// initialize_web_extensions (WebKitWebContext *context,
//
//	gpointer          user_data)
//
//	{
//	  // Web Extensions get a different ID for each Web Process
//	  static guint32 unique_id = 0;
//
//	  webkit_web_context_set_web_extensions_directory (
//	     context, WEB_EXTENSIONS_DIRECTORY);
//	  webkit_web_context_set_web_extensions_initialization_user_data (
//	     context, g_variant_new_uint32 (unique_id++));
//	}
//
// int main (int argc, char **argv)
//
//	{
//	  g_signal_connect (webkit_web_context_get_default (),
//	                   "initialize-web-extensions",
//	                    G_CALLBACK (initialize_web_extensions),
//	                    NULL);
//
//	  GtkWidget *view = webkit_web_view_new ();
//
//	  // ...
//	}
//
// ```
type WebProcessExtension struct {
	gobject.Object
}

var xWebProcessExtensionGLibType func() types.GType

func WebProcessExtensionGLibType() types.GType {
	return xWebProcessExtensionGLibType()
}

func WebProcessExtensionNewFromInternalPtr(ptr uintptr) *WebProcessExtension {
	cls := &WebProcessExtension{}
	cls.Ptr = ptr
	return cls
}

var xWebProcessExtensionGetPage func(uintptr, uint64) uintptr

// Get the web page of the given @page_id.
func (x *WebProcessExtension) GetPage(PageIdVar uint64) *WebPage {
	var cls *WebPage

	cret := xWebProcessExtensionGetPage(x.GoPointer(), PageIdVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &WebPage{}
	cls.Ptr = cret
	return cls
}

var xWebProcessExtensionSendMessageToContext func(uintptr, uintptr, uintptr, uintptr, uintptr)

// Send @message to the #WebKitWebContext corresponding to @extension. If @message is floating, it's consumed.
//
// If you don't expect any reply, or you simply want to ignore it, you can pass %NULL as @calback.
// When the operation is finished, @callback will be called. You can then call
// webkit_web_process_extension_send_message_to_context_finish() to get the message reply.
func (x *WebProcessExtension) SendMessageToContext(MessageVar *UserMessage, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {

	xWebProcessExtensionSendMessageToContext(x.GoPointer(), MessageVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)

}

var xWebProcessExtensionSendMessageToContextFinish func(uintptr, uintptr, **glib.Error) uintptr

// Finish an asynchronous operation started with webkit_web_process_extension_send_message_to_context().
func (x *WebProcessExtension) SendMessageToContextFinish(ResultVar gio.AsyncResult) (*UserMessage, error) {
	var cls *UserMessage
	var cerr *glib.Error

	cret := xWebProcessExtensionSendMessageToContextFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)

	if cret == 0 {
		return nil, cerr
	}
	cls = &UserMessage{}
	cls.Ptr = cret
	if cerr == nil {
		return cls, nil
	}
	return cls, cerr

}

func (c *WebProcessExtension) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *WebProcessExtension) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// This signal is emitted when a new #WebKitWebPage is created in
// the Web Process.
func (x *WebProcessExtension) ConnectPageCreated(cb *func(WebProcessExtension, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "page-created", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, WebPageVarp uintptr) {
		fa := WebProcessExtension{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, WebPageVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "page-created", cbRefPtr)
}

// This signal is emitted when a #WebKitUserMessage is received from the
// #WebKitWebContext corresponding to @extension. Messages sent by #WebKitWebContext
// are always broadcasted to all web extensions and they can't be
// replied to. Calling webkit_user_message_send_reply() will do nothing.
func (x *WebProcessExtension) ConnectUserMessageReceived(cb *func(WebProcessExtension, uintptr)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "user-message-received", cbRefPtr)
	}

	fcb := func(clsPtr uintptr, MessageVarp uintptr) {
		fa := WebProcessExtension{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa, MessageVarp)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "user-message-received", cbRefPtr)
}

func init() {
	core.SetPackageName("WEBKITWEBPROCESSEXTENSION", "webkitgtk-web-process-extension-6.0")
	core.SetSharedLibraries("WEBKITWEBPROCESSEXTENSION", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("WEBKITWEBPROCESSEXTENSION") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xWebProcessExtensionGLibType, libs, "webkit_web_process_extension_get_type")

	core.PuregoSafeRegister(&xWebProcessExtensionGetPage, libs, "webkit_web_process_extension_get_page")
	core.PuregoSafeRegister(&xWebProcessExtensionSendMessageToContext, libs, "webkit_web_process_extension_send_message_to_context")
	core.PuregoSafeRegister(&xWebProcessExtensionSendMessageToContextFinish, libs, "webkit_web_process_extension_send_message_to_context_finish")

}
