// Package javascriptcore was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package javascriptcore

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// Function used to handle JavaScript exceptions in a #JSCContext.
type ExceptionHandler func(uintptr, uintptr, uintptr)

type ContextClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass
}

func (x *ContextClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Enum values to specify a mode to check for syntax errors in jsc_context_check_syntax().
type CheckSyntaxMode int

const (

	// mode to check syntax of a script
	JscCheckSyntaxModeScriptValue CheckSyntaxMode = 0
	// mode to check syntax of a module
	JscCheckSyntaxModeModuleValue CheckSyntaxMode = 1
)

// Enum values to specify the result of jsc_context_check_syntax().
type CheckSyntaxResult int

const (

	// no errors
	JscCheckSyntaxResultSuccessValue CheckSyntaxResult = 0
	// recoverable syntax error
	JscCheckSyntaxResultRecoverableErrorValue CheckSyntaxResult = 1
	// irrecoverable syntax error
	JscCheckSyntaxResultIrrecoverableErrorValue CheckSyntaxResult = 2
	// unterminated literal error
	JscCheckSyntaxResultUnterminatedLiteralErrorValue CheckSyntaxResult = 3
	// out of memory error
	JscCheckSyntaxResultOutOfMemoryErrorValue CheckSyntaxResult = 4
	// stack overflow error
	JscCheckSyntaxResultStackOverflowErrorValue CheckSyntaxResult = 5
)

// JSCContext represents a JavaScript execution context, where all operations
// take place and where the values will be associated.
//
// When a new context is created, a global object is allocated and the built-in JavaScript
// objects (Object, Function, String, Array) are populated. You can execute JavaScript in
// the context by using jsc_context_evaluate() or jsc_context_evaluate_with_source_uri().
// It's also possible to register custom objects in the context with jsc_context_register_class().
type Context struct {
	gobject.Object
}

var xContextGLibType func() types.GType

func ContextGLibType() types.GType {
	return xContextGLibType()
}

func ContextNewFromInternalPtr(ptr uintptr) *Context {
	cls := &Context{}
	cls.Ptr = ptr
	return cls
}

var xNewContext func() uintptr

// Create a new #JSCContext. The context is created in a new #JSCVirtualMachine.
// Use jsc_context_new_with_virtual_machine() to create a new #JSCContext in an
// existing #JSCVirtualMachine.
func NewContext() *Context {
	var cls *Context

	cret := xNewContext()

	if cret == 0 {
		return nil
	}
	cls = &Context{}
	cls.Ptr = cret
	return cls
}

var xNewContextWithVirtualMachine func(uintptr) uintptr

// Create a new #JSCContext in @virtual_machine.
func NewContextWithVirtualMachine(VmVar *VirtualMachine) *Context {
	var cls *Context

	cret := xNewContextWithVirtualMachine(VmVar.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &Context{}
	cls.Ptr = cret
	return cls
}

var xContextCheckSyntax func(uintptr, string, int, CheckSyntaxMode, string, uint, **Exception) CheckSyntaxResult

// Check the given @code in @context for syntax errors. The @line_number is the starting line number in @uri;
// the value is one-based so the first line is 1. @uri and @line_number are only used to fill the @exception.
// In case of errors @exception will be set to a new #JSCException with the details. You can pass %NULL to
// @exception to ignore the error details.
func (x *Context) CheckSyntax(CodeVar string, LengthVar int, ModeVar CheckSyntaxMode, UriVar string, LineNumberVar uint, ExceptionVar **Exception) CheckSyntaxResult {

	cret := xContextCheckSyntax(x.GoPointer(), CodeVar, LengthVar, ModeVar, UriVar, LineNumberVar, ExceptionVar)
	return cret
}

var xContextClearException func(uintptr)

// Clear the uncaught exception in @context if any.
func (x *Context) ClearException() {

	xContextClearException(x.GoPointer())

}

var xContextEvaluate func(uintptr, string, int) uintptr

// Evaluate @code in @context.
func (x *Context) Evaluate(CodeVar string, LengthVar int) *Value {
	var cls *Value

	cret := xContextEvaluate(x.GoPointer(), CodeVar, LengthVar)

	if cret == 0 {
		return nil
	}
	cls = &Value{}
	cls.Ptr = cret
	return cls
}

var xContextEvaluateInObject func(uintptr, string, int, uintptr, uintptr, string, uint, **Value) uintptr

// Evaluate @code and create an new object where symbols defined in @code will be added as properties,
// instead of being added to @context global object. The new object is returned as @object parameter.
// Similar to how jsc_value_new_object() works, if @object_instance is not %NULL @object_class must be provided too.
// The @line_number is the starting line number in @uri; the value is one-based so the first line is 1.
// @uri and @line_number will be shown in exceptions and they don't affect the behavior of the script.
func (x *Context) EvaluateInObject(CodeVar string, LengthVar int, ObjectInstanceVar uintptr, ObjectClassVar *Class, UriVar string, LineNumberVar uint, ObjectVar **Value) *Value {
	var cls *Value

	cret := xContextEvaluateInObject(x.GoPointer(), CodeVar, LengthVar, ObjectInstanceVar, ObjectClassVar.GoPointer(), UriVar, LineNumberVar, ObjectVar)

	if cret == 0 {
		return nil
	}
	cls = &Value{}
	cls.Ptr = cret
	return cls
}

var xContextEvaluateWithSourceUri func(uintptr, string, int, string, uint) uintptr

// Evaluate @code in @context using @uri as the source URI. The @line_number is the starting line number
// in @uri; the value is one-based so the first line is 1. @uri and @line_number will be shown in exceptions and
// they don't affect the behavior of the script.
func (x *Context) EvaluateWithSourceUri(CodeVar string, LengthVar int, UriVar string, LineNumberVar uint) *Value {
	var cls *Value

	cret := xContextEvaluateWithSourceUri(x.GoPointer(), CodeVar, LengthVar, UriVar, LineNumberVar)

	if cret == 0 {
		return nil
	}
	cls = &Value{}
	cls.Ptr = cret
	return cls
}

var xContextGetException func(uintptr) uintptr

// Get the last unhandled exception thrown in @context by API functions calls.
func (x *Context) GetException() *Exception {
	var cls *Exception

	cret := xContextGetException(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Exception{}
	cls.Ptr = cret
	return cls
}

var xContextGetGlobalObject func(uintptr) uintptr

// Get a #JSCValue referencing the @context global object
func (x *Context) GetGlobalObject() *Value {
	var cls *Value

	cret := xContextGetGlobalObject(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &Value{}
	cls.Ptr = cret
	return cls
}

var xContextGetValue func(uintptr, string) uintptr

// Get a property of @context global object with @name.
func (x *Context) GetValue(NameVar string) *Value {
	var cls *Value

	cret := xContextGetValue(x.GoPointer(), NameVar)

	if cret == 0 {
		return nil
	}
	cls = &Value{}
	cls.Ptr = cret
	return cls
}

var xContextGetVirtualMachine func(uintptr) uintptr

// Get the #JSCVirtualMachine where @context was created.
func (x *Context) GetVirtualMachine() *VirtualMachine {
	var cls *VirtualMachine

	cret := xContextGetVirtualMachine(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &VirtualMachine{}
	cls.Ptr = cret
	return cls
}

var xContextPopExceptionHandler func(uintptr)

// Remove the last #JSCExceptionHandler previously pushed to @context with
// jsc_context_push_exception_handler().
func (x *Context) PopExceptionHandler() {

	xContextPopExceptionHandler(x.GoPointer())

}

var xContextPushExceptionHandler func(uintptr, uintptr, uintptr, uintptr)

// Push an exception handler in @context. Whenever a JavaScript exception happens in
// the #JSCContext, the given @handler will be called. The default #JSCExceptionHandler
// simply calls jsc_context_throw_exception() to throw the exception to the #JSCContext.
// If you don't want to catch the exception, but only get notified about it, call
// jsc_context_throw_exception() in @handler like the default one does.
// The last exception handler pushed is the only one used by the #JSCContext, use
// jsc_context_pop_exception_handler() to remove it and set the previous one. When @handler
// is removed from the context, @destroy_notify i called with @user_data as parameter.
func (x *Context) PushExceptionHandler(HandlerVar *ExceptionHandler, UserDataVar uintptr, DestroyNotifyVar *glib.DestroyNotify) {

	var HandlerVarRef uintptr
	if HandlerVar != nil {
		HandlerVarPtr := uintptr(unsafe.Pointer(HandlerVar))
		if cbRefPtr, ok := glib.GetCallback(HandlerVarPtr); ok {
			HandlerVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr, arg1 uintptr, arg2 uintptr) {
				cbFn := *HandlerVar
				cbFn(arg0, arg1, arg2)
			}
			HandlerVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(HandlerVarPtr, HandlerVarRef)
		}
	}

	var DestroyNotifyVarRef uintptr
	if DestroyNotifyVar != nil {
		DestroyNotifyVarPtr := uintptr(unsafe.Pointer(DestroyNotifyVar))
		if cbRefPtr, ok := glib.GetCallback(DestroyNotifyVarPtr); ok {
			DestroyNotifyVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *DestroyNotifyVar
				cbFn(arg0)
			}
			DestroyNotifyVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(DestroyNotifyVarPtr, DestroyNotifyVarRef)
		}
	}

	xContextPushExceptionHandler(x.GoPointer(), HandlerVarRef, UserDataVar, DestroyNotifyVarRef)

}

var xContextRegisterClass func(uintptr, string, uintptr, *ClassVTable, uintptr) uintptr

// Register a custom class in @context using the given @name. If the new class inherits from
// another #JSCClass, the parent should be passed as @parent_class, otherwise %NULL should be
// used. The optional @vtable parameter allows to provide a custom implementation for handling
// the class, for example, to handle external properties not added to the prototype.
// When an instance of the #JSCClass is cleared in the context, @destroy_notify is called with
// the instance as parameter.
func (x *Context) RegisterClass(NameVar string, ParentClassVar *Class, VtableVar *ClassVTable, DestroyNotifyVar *glib.DestroyNotify) *Class {
	var cls *Class

	var DestroyNotifyVarRef uintptr
	if DestroyNotifyVar != nil {
		DestroyNotifyVarPtr := uintptr(unsafe.Pointer(DestroyNotifyVar))
		if cbRefPtr, ok := glib.GetCallback(DestroyNotifyVarPtr); ok {
			DestroyNotifyVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *DestroyNotifyVar
				cbFn(arg0)
			}
			DestroyNotifyVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(DestroyNotifyVarPtr, DestroyNotifyVarRef)
		}
	}

	cret := xContextRegisterClass(x.GoPointer(), NameVar, ParentClassVar.GoPointer(), VtableVar, DestroyNotifyVarRef)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Class{}
	cls.Ptr = cret
	return cls
}

var xContextSetValue func(uintptr, string, uintptr)

// Set a property of @context global object with @name and @value.
func (x *Context) SetValue(NameVar string, ValueVar *Value) {

	xContextSetValue(x.GoPointer(), NameVar, ValueVar.GoPointer())

}

var xContextThrow func(uintptr, string)

// Throw an exception to @context using the given error message. The created #JSCException
// can be retrieved with jsc_context_get_exception().
func (x *Context) Throw(ErrorMessageVar string) {

	xContextThrow(x.GoPointer(), ErrorMessageVar)

}

var xContextThrowException func(uintptr, uintptr)

// Throw @exception to @context.
func (x *Context) ThrowException(ExceptionVar *Exception) {

	xContextThrowException(x.GoPointer(), ExceptionVar.GoPointer())

}

var xContextThrowPrintf func(uintptr, string, ...interface{})

// Throw an exception to @context using the given formatted string as error message.
// The created #JSCException can be retrieved with jsc_context_get_exception().
func (x *Context) ThrowPrintf(FormatVar string, varArgs ...interface{}) {

	xContextThrowPrintf(x.GoPointer(), FormatVar, varArgs...)

}

var xContextThrowWithName func(uintptr, string, string)

// Throw an exception to @context using the given error name and message. The created #JSCException
// can be retrieved with jsc_context_get_exception().
func (x *Context) ThrowWithName(ErrorNameVar string, ErrorMessageVar string) {

	xContextThrowWithName(x.GoPointer(), ErrorNameVar, ErrorMessageVar)

}

var xContextThrowWithNamePrintf func(uintptr, string, string, ...interface{})

// Throw an exception to @context using the given error name and the formatted string as error message.
// The created #JSCException can be retrieved with jsc_context_get_exception().
func (x *Context) ThrowWithNamePrintf(ErrorNameVar string, FormatVar string, varArgs ...interface{}) {

	xContextThrowWithNamePrintf(x.GoPointer(), ErrorNameVar, FormatVar, varArgs...)

}

func (c *Context) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *Context) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

var xContextGetCurrent func() uintptr

// Get the #JSCContext that is currently executing a function. This should only be
// called within a function or method callback, otherwise %NULL will be returned.
func ContextGetCurrent() *Context {
	var cls *Context

	cret := xContextGetCurrent()

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Context{}
	cls.Ptr = cret
	return cls
}

func init() {
	core.SetPackageName("JAVASCRIPTCORE", "javascriptcoregtk-6.0")
	core.SetSharedLibraries("JAVASCRIPTCORE", []string{"libjavascriptcoregtk-6.0.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("JAVASCRIPTCORE") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xContextGLibType, libs, "jsc_context_get_type")

	core.PuregoSafeRegister(&xNewContext, libs, "jsc_context_new")
	core.PuregoSafeRegister(&xNewContextWithVirtualMachine, libs, "jsc_context_new_with_virtual_machine")

	core.PuregoSafeRegister(&xContextCheckSyntax, libs, "jsc_context_check_syntax")
	core.PuregoSafeRegister(&xContextClearException, libs, "jsc_context_clear_exception")
	core.PuregoSafeRegister(&xContextEvaluate, libs, "jsc_context_evaluate")
	core.PuregoSafeRegister(&xContextEvaluateInObject, libs, "jsc_context_evaluate_in_object")
	core.PuregoSafeRegister(&xContextEvaluateWithSourceUri, libs, "jsc_context_evaluate_with_source_uri")
	core.PuregoSafeRegister(&xContextGetException, libs, "jsc_context_get_exception")
	core.PuregoSafeRegister(&xContextGetGlobalObject, libs, "jsc_context_get_global_object")
	core.PuregoSafeRegister(&xContextGetValue, libs, "jsc_context_get_value")
	core.PuregoSafeRegister(&xContextGetVirtualMachine, libs, "jsc_context_get_virtual_machine")
	core.PuregoSafeRegister(&xContextPopExceptionHandler, libs, "jsc_context_pop_exception_handler")
	core.PuregoSafeRegister(&xContextPushExceptionHandler, libs, "jsc_context_push_exception_handler")
	core.PuregoSafeRegister(&xContextRegisterClass, libs, "jsc_context_register_class")
	core.PuregoSafeRegister(&xContextSetValue, libs, "jsc_context_set_value")
	core.PuregoSafeRegister(&xContextThrow, libs, "jsc_context_throw")
	core.PuregoSafeRegister(&xContextThrowException, libs, "jsc_context_throw_exception")
	core.PuregoSafeRegister(&xContextThrowPrintf, libs, "jsc_context_throw_printf")
	core.PuregoSafeRegister(&xContextThrowWithName, libs, "jsc_context_throw_with_name")
	core.PuregoSafeRegister(&xContextThrowWithNamePrintf, libs, "jsc_context_throw_with_name_printf")

	core.PuregoSafeRegister(&xContextGetCurrent, libs, "jsc_context_get_current")

}
