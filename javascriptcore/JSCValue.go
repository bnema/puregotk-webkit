// Package javascriptcore was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package javascriptcore

import (
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// A function passed to @jsc_value_new_promise called during initialization
//
// It is called like a JavaScript function, so exceptions raised will not be propagated
// to the context, but handled by the promise causing a rejection.
// @resolve and @reject can be reffed for later use to handle async task completion.
type Executor func(uintptr, uintptr, uintptr)

type ValueClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass
}

func (x *ValueClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Flags used when defining properties with jsc_value_object_define_property_data() and
// jsc_value_object_define_property_accessor().
type ValuePropertyFlags int

const (

	// the type of the property descriptor may be changed and the
	//  property may be deleted from the corresponding object.
	JscValuePropertyConfigurableValue ValuePropertyFlags = 1
	// the property shows up during enumeration of the properties on
	//  the corresponding object.
	JscValuePropertyEnumerableValue ValuePropertyFlags = 2
	// the value associated with the property may be changed with an
	//  assignment operator. This doesn't have any effect when passed to jsc_value_object_define_property_accessor().
	JscValuePropertyWritableValue ValuePropertyFlags = 4
)

// Possible types of the elements contained in a typed array.
type TypedArrayType int

const (

	// Not a typed array, or type unsupported.
	JscTypedArrayNoneValue TypedArrayType = 0
	// Array elements are 8-bit signed integers (int8_t).
	JscTypedArrayInt8Value TypedArrayType = 1
	// Array elements are 16-bit signed integers (int16_t).
	JscTypedArrayInt16Value TypedArrayType = 2
	// Array elements are 32-bit signed integers (int32_t).
	JscTypedArrayInt32Value TypedArrayType = 3
	// Array elements are 64-bit signed integers (int64_t).
	JscTypedArrayInt64Value TypedArrayType = 4
	// Array elements are 8-bit unsigned integers (uint8_t).
	JscTypedArrayUint8Value TypedArrayType = 5
	// Array elements are 8-bit unsigned integers (uint8_t).
	JscTypedArrayUint8ClampedValue TypedArrayType = 6
	// Array elements are 16-bit unsigned integers (uint16_t).
	JscTypedArrayUint16Value TypedArrayType = 7
	// Array elements are 32-bit unsigned integers (uint32_t).
	JscTypedArrayUint32Value TypedArrayType = 8
	// Array elements are 64-bit unsigned integers (uint64_t).
	JscTypedArrayUint64Value TypedArrayType = 9
	// Array elements are 32-bit floating point numbers (float).
	JscTypedArrayFloat32Value TypedArrayType = 10
	// Array elements are 64-bit floating point numbers (double).
	JscTypedArrayFloat64Value TypedArrayType = 11
)

// JSCValue represents a reference to a value in a #JSCContext. The JSCValue
// protects the referenced value from being garbage collected.
type Value struct {
	gobject.Object
}

var xValueGLibType func() types.GType

func ValueGLibType() types.GType {
	return xValueGLibType()
}

func ValueNewFromInternalPtr(ptr uintptr) *Value {
	cls := &Value{}
	cls.Ptr = ptr
	return cls
}

var xNewValueArray func(uintptr, types.GType, ...interface{}) uintptr

// Create a new #JSCValue referencing an array with the given items. If @first_item_type
// is %G_TYPE_NONE an empty array is created.
func NewValueArray(ContextVar *Context, FirstItemTypeVar types.GType, varArgs ...interface{}) *Value {
	var cls *Value

	cret := xNewValueArray(ContextVar.GoPointer(), FirstItemTypeVar, varArgs...)

	if cret == 0 {
		return nil
	}
	cls = &Value{}
	cls.Ptr = cret
	return cls
}

var xNewValueArrayBuffer func(uintptr, uintptr, uint, uintptr, uintptr) uintptr

// Creates a new %ArrayBuffer from existing @data in memory.
//
// The @data is not copied: while this allows sharing data with JavaScript
// efficiently, the caller must ensure that the memory region remains valid
// until the newly created object is released by JSC.
//
// Optionally, a @destroy_notify callback can be provided, which will be
// invoked with @user_data as parameter when the %ArrayBuffer object is
// released. This is intended to be used for freeing resources related to
// the memory region which contains the data:
//
// |[!&lt;-- language="C" --&gt;
// GMappedFile *f = g_mapped_file_new (file_path, TRUE, NULL);
// JSCValue *value = jsc_value_new_array_buffer (context,
//
//	g_mapped_file_get_contents (f), g_mapped_file_get_length (f),
//	(GDestroyNotify) g_mapped_file_unref, f);
//
// ]|
//
// Note that the @user_data can be the same value as @data:
//
// |[!&lt;-- language="C" --&gt;
// void *bytes = g_malloc0 (100);
// JSCValue *value = jsc_value_new_array_buffer (context, bytes, 100, g_free, bytes);
// ]|
func NewValueArrayBuffer(ContextVar *Context, DataVar uintptr, SizeVar uint, DestroyNotifyVar *glib.DestroyNotify, UserDataVar uintptr) *Value {
	var cls *Value

	cret := xNewValueArrayBuffer(ContextVar.GoPointer(), DataVar, SizeVar, glib.NewCallbackNullable(DestroyNotifyVar), UserDataVar)

	if cret == 0 {
		return nil
	}
	cls = &Value{}
	cls.Ptr = cret
	return cls
}

var xNewValueArrayFromGarray func(uintptr, []Value) uintptr

// Create a new #JSCValue referencing an array with the items from @array. If @array
// is %NULL or empty a new empty array will be created. Elements of @array should be
// pointers to a #JSCValue.
func NewValueArrayFromGarray(ContextVar *Context, ArrayVar []Value) *Value {
	var cls *Value

	cret := xNewValueArrayFromGarray(ContextVar.GoPointer(), ArrayVar)

	if cret == 0 {
		return nil
	}
	cls = &Value{}
	cls.Ptr = cret
	return cls
}

var xNewValueArrayFromStrv func(uintptr, []string) uintptr

// Create a new #JSCValue referencing an array of strings with the items from @strv. If @array
// is %NULL or empty a new empty array will be created.
func NewValueArrayFromStrv(ContextVar *Context, StrvVar []string) *Value {
	var cls *Value

	cret := xNewValueArrayFromStrv(ContextVar.GoPointer(), StrvVar)

	if cret == 0 {
		return nil
	}
	cls = &Value{}
	cls.Ptr = cret
	return cls
}

var xNewValueBoolean func(uintptr, bool) uintptr

// Create a new #JSCValue from @value
func NewValueBoolean(ContextVar *Context, ValueVar bool) *Value {
	var cls *Value

	cret := xNewValueBoolean(ContextVar.GoPointer(), ValueVar)

	if cret == 0 {
		return nil
	}
	cls = &Value{}
	cls.Ptr = cret
	return cls
}

var xNewValueFromJson func(uintptr, string) uintptr

// Create a new #JSCValue referencing a new value created by parsing @json.
func NewValueFromJson(ContextVar *Context, JsonVar string) *Value {
	var cls *Value

	cret := xNewValueFromJson(ContextVar.GoPointer(), JsonVar)

	if cret == 0 {
		return nil
	}
	cls = &Value{}
	cls.Ptr = cret
	return cls
}

var xNewValueFunction func(uintptr, string, uintptr, uintptr, uintptr, types.GType, uint, ...interface{}) uintptr

// Create a function in @context. If @name is %NULL an anonymous function will be created.
// When the function is called by JavaScript or jsc_value_function_call(), @callback is called
// receiving the function parameters and then @user_data as last parameter. When the function is
// cleared in @context, @destroy_notify is called with @user_data as parameter.
//
// Note that the value returned by @callback must be fully transferred. In case of boxed types, you could use
// %G_TYPE_POINTER instead of the actual boxed #GType to ensure that the instance owned by #JSCClass is used.
// If you really want to return a new copy of the boxed type, use #JSC_TYPE_VALUE and return a #JSCValue created
// with jsc_value_new_object() that receives the copy as instance parameter.
func NewValueFunction(ContextVar *Context, NameVar string, CallbackVar *gobject.Callback, UserDataVar uintptr, DestroyNotifyVar *glib.DestroyNotify, ReturnTypeVar types.GType, NParamsVar uint, varArgs ...interface{}) *Value {
	var cls *Value

	cret := xNewValueFunction(ContextVar.GoPointer(), NameVar, glib.NewCallback(CallbackVar), UserDataVar, glib.NewCallbackNullable(DestroyNotifyVar), ReturnTypeVar, NParamsVar, varArgs...)

	if cret == 0 {
		return nil
	}
	cls = &Value{}
	cls.Ptr = cret
	return cls
}

var xNewValueFunctionVariadic func(uintptr, string, uintptr, uintptr, uintptr, types.GType) uintptr

// Create a function in @context. If @name is %NULL an anonymous function will be created.
// When the function is called by JavaScript or jsc_value_function_call(), @callback is called
// receiving an #GPtrArray of #JSCValue&lt;!-- --&gt;s with the arguments and then @user_data as last parameter.
// When the function is cleared in @context, @destroy_notify is called with @user_data as parameter.
//
// Note that the value returned by @callback must be fully transferred. In case of boxed types, you could use
// %G_TYPE_POINTER instead of the actual boxed #GType to ensure that the instance owned by #JSCClass is used.
// If you really want to return a new copy of the boxed type, use #JSC_TYPE_VALUE and return a #JSCValue created
// with jsc_value_new_object() that receives the copy as instance parameter.
func NewValueFunctionVariadic(ContextVar *Context, NameVar string, CallbackVar *gobject.Callback, UserDataVar uintptr, DestroyNotifyVar *glib.DestroyNotify, ReturnTypeVar types.GType) *Value {
	var cls *Value

	cret := xNewValueFunctionVariadic(ContextVar.GoPointer(), NameVar, glib.NewCallback(CallbackVar), UserDataVar, glib.NewCallbackNullable(DestroyNotifyVar), ReturnTypeVar)

	if cret == 0 {
		return nil
	}
	cls = &Value{}
	cls.Ptr = cret
	return cls
}

var xNewValueFunctionv func(uintptr, string, uintptr, uintptr, uintptr, types.GType, uint, []types.GType) uintptr

// Create a function in @context. If @name is %NULL an anonymous function will be created.
// When the function is called by JavaScript or jsc_value_function_call(), @callback is called
// receiving the function parameters and then @user_data as last parameter. When the function is
// cleared in @context, @destroy_notify is called with @user_data as parameter.
//
// Note that the value returned by @callback must be fully transferred. In case of boxed types, you could use
// %G_TYPE_POINTER instead of the actual boxed #GType to ensure that the instance owned by #JSCClass is used.
// If you really want to return a new copy of the boxed type, use #JSC_TYPE_VALUE and return a #JSCValue created
// with jsc_value_new_object() that receives the copy as instance parameter.
func NewValueFunctionv(ContextVar *Context, NameVar string, CallbackVar *gobject.Callback, UserDataVar uintptr, DestroyNotifyVar *glib.DestroyNotify, ReturnTypeVar types.GType, NParametersVar uint, ParameterTypesVar []types.GType) *Value {
	var cls *Value

	cret := xNewValueFunctionv(ContextVar.GoPointer(), NameVar, glib.NewCallback(CallbackVar), UserDataVar, glib.NewCallbackNullable(DestroyNotifyVar), ReturnTypeVar, NParametersVar, ParameterTypesVar)

	if cret == 0 {
		return nil
	}
	cls = &Value{}
	cls.Ptr = cret
	return cls
}

var xNewValueNull func(uintptr) uintptr

// Create a new #JSCValue referencing &lt;function&gt;null&lt;/function&gt; in @context.
func NewValueNull(ContextVar *Context) *Value {
	var cls *Value

	cret := xNewValueNull(ContextVar.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &Value{}
	cls.Ptr = cret
	return cls
}

var xNewValueNumber func(uintptr, float64) uintptr

// Create a new #JSCValue from @number.
func NewValueNumber(ContextVar *Context, NumberVar float64) *Value {
	var cls *Value

	cret := xNewValueNumber(ContextVar.GoPointer(), NumberVar)

	if cret == 0 {
		return nil
	}
	cls = &Value{}
	cls.Ptr = cret
	return cls
}

var xNewValueObject func(uintptr, uintptr, uintptr) uintptr

// Create a new #JSCValue from @instance. If @instance is %NULL a new empty object is created.
// When @instance is provided, @jsc_class must be provided too. @jsc_class takes ownership of
// @instance that will be freed by the #GDestroyNotify passed to jsc_context_register_class().
func NewValueObject(ContextVar *Context, InstanceVar uintptr, JscClassVar *Class) *Value {
	var cls *Value

	cret := xNewValueObject(ContextVar.GoPointer(), InstanceVar, JscClassVar.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &Value{}
	cls.Ptr = cret
	return cls
}

var xNewValuePromise func(uintptr, uintptr, uintptr) uintptr

// Creates a new Promise. @executor will be invoked during promise initialization
// and it receives the @resolve and @reject objects than can be called to resolve
// or reject the promise. It is called like a JavaScript function, so exceptions raised
// during the executor invocation will not be propagated to the context, but
// handled by the promise causing a rejection.
func NewValuePromise(ContextVar *Context, ExecutorVar *Executor, UserDataVar uintptr) *Value {
	var cls *Value

	cret := xNewValuePromise(ContextVar.GoPointer(), glib.NewCallback(ExecutorVar), UserDataVar)

	if cret == 0 {
		return nil
	}
	cls = &Value{}
	cls.Ptr = cret
	return cls
}

var xNewValueString func(uintptr, string) uintptr

// Create a new #JSCValue from @string. If you need to create a #JSCValue from a
// string containing null characters, use jsc_value_new_string_from_bytes() instead.
func NewValueString(ContextVar *Context, StringVar string) *Value {
	var cls *Value

	cret := xNewValueString(ContextVar.GoPointer(), StringVar)

	if cret == 0 {
		return nil
	}
	cls = &Value{}
	cls.Ptr = cret
	return cls
}

var xNewValueStringFromBytes func(uintptr, *glib.Bytes) uintptr

// Create a new #JSCValue from @bytes.
func NewValueStringFromBytes(ContextVar *Context, BytesVar *glib.Bytes) *Value {
	var cls *Value

	cret := xNewValueStringFromBytes(ContextVar.GoPointer(), BytesVar)

	if cret == 0 {
		return nil
	}
	cls = &Value{}
	cls.Ptr = cret
	return cls
}

var xNewValueTypedArray func(uintptr, TypedArrayType, uint) uintptr

// Create a new typed array containing a given amount of elements.
//
// Create a #JSCValue referencing a new typed array with space for @length
// elements of a given @type. As all typed arrays must have an associated
// `ArrayBuffer`, a new one of suitable size will be allocated to store
// the elements, which will be initialized to zero.
//
// The @type must *not* be %JSC_TYPED_ARRAY_NONE.
func NewValueTypedArray(ContextVar *Context, TypeVar TypedArrayType, LengthVar uint) *Value {
	var cls *Value

	cret := xNewValueTypedArray(ContextVar.GoPointer(), TypeVar, LengthVar)

	if cret == 0 {
		return nil
	}
	cls = &Value{}
	cls.Ptr = cret
	return cls
}

var xNewValueUndefined func(uintptr) uintptr

// Create a new #JSCValue referencing &lt;function&gt;undefined&lt;/function&gt; in @context.
func NewValueUndefined(ContextVar *Context) *Value {
	var cls *Value

	cret := xNewValueUndefined(ContextVar.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &Value{}
	cls.Ptr = cret
	return cls
}

var xValueArrayBufferGetData func(uintptr, *uint) uintptr

// Gets a pointer to memory that contains the array buffer data.
//
// Obtains a pointer to the memory region that holds the contents of the
// %ArrayBuffer; modifications done to the data will be visible to JavaScript
// code. If @size is not %NULL, the size in bytes of the memory region
// will also be stored in the pointed location.
//
// Note that the pointer returned by this function is not guaranteed to remain
// the same after calls to other JSC API functions. If you plan to access the
// data of the %ArrayBuffer later, you can keep a reference to the @value and
// obtain the data pointer at a later point. Keep in mind that if JavaScript
// code has a chance to run, for example due to main loop events that result
// in JSC being called, the contents of the memory region might be modified in
// the meantime. Consider taking a copy of the data and using the copy instead
// in asynchronous code.
func (x *Value) ArrayBufferGetData(SizeVar *uint) uintptr {

	cret := xValueArrayBufferGetData(x.GoPointer(), SizeVar)
	return cret
}

var xValueArrayBufferGetSize func(uintptr) uint

// Gets the size in bytes of the array buffer.
//
// Obtains the size in bytes of the memory region that holds the contents of
// an %ArrayBuffer.
func (x *Value) ArrayBufferGetSize() uint {

	cret := xValueArrayBufferGetSize(x.GoPointer())
	return cret
}

var xValueConstructorCall func(uintptr, types.GType, ...interface{}) uintptr

// Invoke &lt;function&gt;new&lt;/function&gt; with constructor referenced by @value. If @first_parameter_type
// is %G_TYPE_NONE no parameters will be passed to the constructor.
func (x *Value) ConstructorCall(FirstParameterTypeVar types.GType, varArgs ...interface{}) *Value {
	var cls *Value

	cret := xValueConstructorCall(x.GoPointer(), FirstParameterTypeVar, varArgs...)

	if cret == 0 {
		return nil
	}
	cls = &Value{}
	cls.Ptr = cret
	return cls
}

var xValueConstructorCallv func(uintptr, uint, []Value) uintptr

// Invoke &lt;function&gt;new&lt;/function&gt; with constructor referenced by @value. If @n_parameters
// is 0 no parameters will be passed to the constructor.
func (x *Value) ConstructorCallv(NParametersVar uint, ParametersVar []Value) *Value {
	var cls *Value

	cret := xValueConstructorCallv(x.GoPointer(), NParametersVar, ParametersVar)

	if cret == 0 {
		return nil
	}
	cls = &Value{}
	cls.Ptr = cret
	return cls
}

var xValueFunctionCall func(uintptr, types.GType, ...interface{}) uintptr

// Call function referenced by @value, passing the given parameters. If @first_parameter_type
// is %G_TYPE_NONE no parameters will be passed to the function.
//
// This function always returns a #JSCValue, in case of void functions a #JSCValue referencing
// &lt;function&gt;undefined&lt;/function&gt; is returned
func (x *Value) FunctionCall(FirstParameterTypeVar types.GType, varArgs ...interface{}) *Value {
	var cls *Value

	cret := xValueFunctionCall(x.GoPointer(), FirstParameterTypeVar, varArgs...)

	if cret == 0 {
		return nil
	}
	cls = &Value{}
	cls.Ptr = cret
	return cls
}

var xValueFunctionCallv func(uintptr, uint, []Value) uintptr

// Call function referenced by @value, passing the given @parameters. If @n_parameters
// is 0 no parameters will be passed to the function.
//
// This function always returns a #JSCValue, in case of void functions a #JSCValue referencing
// &lt;function&gt;undefined&lt;/function&gt; is returned
func (x *Value) FunctionCallv(NParametersVar uint, ParametersVar []Value) *Value {
	var cls *Value

	cret := xValueFunctionCallv(x.GoPointer(), NParametersVar, ParametersVar)

	if cret == 0 {
		return nil
	}
	cls = &Value{}
	cls.Ptr = cret
	return cls
}

var xValueGetContext func(uintptr) uintptr

// Get the #JSCContext in which @value was created.
func (x *Value) GetContext() *Context {
	var cls *Context

	cret := xValueGetContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Context{}
	cls.Ptr = cret
	return cls
}

var xValueIsArray func(uintptr) bool

// Get whether the value referenced by @value is an array.
func (x *Value) IsArray() bool {

	cret := xValueIsArray(x.GoPointer())
	return cret
}

var xValueIsArrayBuffer func(uintptr) bool

// Check whether the @value is an %ArrayBuffer.
func (x *Value) IsArrayBuffer() bool {

	cret := xValueIsArrayBuffer(x.GoPointer())
	return cret
}

var xValueIsBoolean func(uintptr) bool

// Get whether the value referenced by @value is a boolean.
func (x *Value) IsBoolean() bool {

	cret := xValueIsBoolean(x.GoPointer())
	return cret
}

var xValueIsConstructor func(uintptr) bool

// Get whether the value referenced by @value is a constructor.
func (x *Value) IsConstructor() bool {

	cret := xValueIsConstructor(x.GoPointer())
	return cret
}

var xValueIsFunction func(uintptr) bool

// Get whether the value referenced by @value is a function
func (x *Value) IsFunction() bool {

	cret := xValueIsFunction(x.GoPointer())
	return cret
}

var xValueIsNull func(uintptr) bool

// Get whether the value referenced by @value is &lt;function&gt;null&lt;/function&gt;.
func (x *Value) IsNull() bool {

	cret := xValueIsNull(x.GoPointer())
	return cret
}

var xValueIsNumber func(uintptr) bool

// Get whether the value referenced by @value is a number.
func (x *Value) IsNumber() bool {

	cret := xValueIsNumber(x.GoPointer())
	return cret
}

var xValueIsObject func(uintptr) bool

// Get whether the value referenced by @value is an object.
func (x *Value) IsObject() bool {

	cret := xValueIsObject(x.GoPointer())
	return cret
}

var xValueIsString func(uintptr) bool

// Get whether the value referenced by @value is a string
func (x *Value) IsString() bool {

	cret := xValueIsString(x.GoPointer())
	return cret
}

var xValueIsTypedArray func(uintptr) bool

// Determines whether a value is a typed array.
func (x *Value) IsTypedArray() bool {

	cret := xValueIsTypedArray(x.GoPointer())
	return cret
}

var xValueIsUndefined func(uintptr) bool

// Get whether the value referenced by @value is &lt;function&gt;undefined&lt;/function&gt;.
func (x *Value) IsUndefined() bool {

	cret := xValueIsUndefined(x.GoPointer())
	return cret
}

var xValueNewTypedArrayWithBuffer func(uintptr, TypedArrayType, uint, int) uintptr

// Create a new typed array value with elements from an array buffer.
//
// Create a #JSCValue referencing a new typed array value containing
// elements of the given @type, where the elements are stored at the memory
// region represented by the @array_buffer.
//
// The @type must *not* be %JSC_TYPED_ARRAY_NONE.
//
// The @offset and @length parameters can be used to indicate which part of
// the array buffer can be accessed through the typed array. If both are
// omitted (passing zero as @offset, and `-1` as @length), the whole
// @array_buffer is exposed through the typed array. Omitting the @length
// with a non-zero @offset will expose the remainder of the @array_buffer
// starting at the indicated offset.
func (x *Value) NewTypedArrayWithBuffer(TypeVar TypedArrayType, OffsetVar uint, LengthVar int) *Value {
	var cls *Value

	cret := xValueNewTypedArrayWithBuffer(x.GoPointer(), TypeVar, OffsetVar, LengthVar)

	if cret == 0 {
		return nil
	}
	cls = &Value{}
	cls.Ptr = cret
	return cls
}

var xValueObjectDefinePropertyAccessor func(uintptr, string, ValuePropertyFlags, types.GType, uintptr, uintptr, uintptr, uintptr)

// Define or modify a property with @property_name in object referenced by @value. When the
// property value needs to be getted or set, @getter and @setter callbacks will be called.
// When the property is cleared in the #JSCClass context, @destroy_notify is called with
// @user_data as parameter. This is equivalent to JavaScript &lt;function&gt;Object.defineProperty()&lt;/function&gt;
// when used with an accessor descriptor.
//
// Note that the value returned by @getter must be fully transferred. In case of boxed types, you could use
// %G_TYPE_POINTER instead of the actual boxed #GType to ensure that the instance owned by #JSCClass is used.
// If you really want to return a new copy of the boxed type, use #JSC_TYPE_VALUE and return a #JSCValue created
// with jsc_value_new_object() that receives the copy as instance parameter.
//
// Note that @getter and @setter are called as functions and not methods, so they don't receive an instance as
// first parameter. Use jsc_class_add_property() if you want to add property accessor invoked as a method.
func (x *Value) ObjectDefinePropertyAccessor(PropertyNameVar string, FlagsVar ValuePropertyFlags, PropertyTypeVar types.GType, GetterVar *gobject.Callback, SetterVar *gobject.Callback, UserDataVar uintptr, DestroyNotifyVar *glib.DestroyNotify) {

	xValueObjectDefinePropertyAccessor(x.GoPointer(), PropertyNameVar, FlagsVar, PropertyTypeVar, glib.NewCallbackNullable(GetterVar), glib.NewCallbackNullable(SetterVar), UserDataVar, glib.NewCallbackNullable(DestroyNotifyVar))

}

var xValueObjectDefinePropertyData func(uintptr, string, ValuePropertyFlags, uintptr)

// Define or modify a property with @property_name in object referenced by @value. This is equivalent to
// JavaScript &lt;function&gt;Object.defineProperty()&lt;/function&gt; when used with a data descriptor.
func (x *Value) ObjectDefinePropertyData(PropertyNameVar string, FlagsVar ValuePropertyFlags, PropertyValueVar *Value) {

	xValueObjectDefinePropertyData(x.GoPointer(), PropertyNameVar, FlagsVar, PropertyValueVar.GoPointer())

}

var xValueObjectDeleteProperty func(uintptr, string) bool

// Try to delete property with @name from @value. This function will return %FALSE if
// the property was defined without %JSC_VALUE_PROPERTY_CONFIGURABLE flag.
func (x *Value) ObjectDeleteProperty(NameVar string) bool {

	cret := xValueObjectDeleteProperty(x.GoPointer(), NameVar)
	return cret
}

var xValueObjectEnumerateProperties func(uintptr) []string

// Get the list of property names of @value. Only properties defined with %JSC_VALUE_PROPERTY_ENUMERABLE
// flag will be collected.
func (x *Value) ObjectEnumerateProperties() []string {

	cret := xValueObjectEnumerateProperties(x.GoPointer())
	return cret
}

var xValueObjectGetProperty func(uintptr, string) uintptr

// Get property with @name from @value.
func (x *Value) ObjectGetProperty(NameVar string) *Value {
	var cls *Value

	cret := xValueObjectGetProperty(x.GoPointer(), NameVar)

	if cret == 0 {
		return nil
	}
	cls = &Value{}
	cls.Ptr = cret
	return cls
}

var xValueObjectGetPropertyAtIndex func(uintptr, uint) uintptr

// Get property at @index from @value.
func (x *Value) ObjectGetPropertyAtIndex(IndexVar uint) *Value {
	var cls *Value

	cret := xValueObjectGetPropertyAtIndex(x.GoPointer(), IndexVar)

	if cret == 0 {
		return nil
	}
	cls = &Value{}
	cls.Ptr = cret
	return cls
}

var xValueObjectHasProperty func(uintptr, string) bool

// Get whether @value has property with @name.
func (x *Value) ObjectHasProperty(NameVar string) bool {

	cret := xValueObjectHasProperty(x.GoPointer(), NameVar)
	return cret
}

var xValueObjectInvokeMethod func(uintptr, string, types.GType, ...interface{}) uintptr

// Invoke method with @name on object referenced by @value, passing the given parameters. If
// @first_parameter_type is %G_TYPE_NONE no parameters will be passed to the method.
// The object instance will be handled automatically even when the method is a custom one
// registered with jsc_class_add_method(), so it should never be passed explicitly as parameter
// of this function.
//
// This function always returns a #JSCValue, in case of void methods a #JSCValue referencing
// &lt;function&gt;undefined&lt;/function&gt; is returned.
func (x *Value) ObjectInvokeMethod(NameVar string, FirstParameterTypeVar types.GType, varArgs ...interface{}) *Value {
	var cls *Value

	cret := xValueObjectInvokeMethod(x.GoPointer(), NameVar, FirstParameterTypeVar, varArgs...)

	if cret == 0 {
		return nil
	}
	cls = &Value{}
	cls.Ptr = cret
	return cls
}

var xValueObjectInvokeMethodv func(uintptr, string, uint, []Value) uintptr

// Invoke method with @name on object referenced by @value, passing the given @parameters. If
// @n_parameters is 0 no parameters will be passed to the method.
// The object instance will be handled automatically even when the method is a custom one
// registered with jsc_class_add_method(), so it should never be passed explicitly as parameter
// of this function.
//
// This function always returns a #JSCValue, in case of void methods a #JSCValue referencing
// &lt;function&gt;undefined&lt;/function&gt; is returned.
func (x *Value) ObjectInvokeMethodv(NameVar string, NParametersVar uint, ParametersVar []Value) *Value {
	var cls *Value

	cret := xValueObjectInvokeMethodv(x.GoPointer(), NameVar, NParametersVar, ParametersVar)

	if cret == 0 {
		return nil
	}
	cls = &Value{}
	cls.Ptr = cret
	return cls
}

var xValueObjectIsInstanceOf func(uintptr, string) bool

// Get whether the value referenced by @value is an instance of class @name.
func (x *Value) ObjectIsInstanceOf(NameVar string) bool {

	cret := xValueObjectIsInstanceOf(x.GoPointer(), NameVar)
	return cret
}

var xValueObjectSetProperty func(uintptr, string, uintptr)

// Set @property with @name on @value.
func (x *Value) ObjectSetProperty(NameVar string, PropertyVar *Value) {

	xValueObjectSetProperty(x.GoPointer(), NameVar, PropertyVar.GoPointer())

}

var xValueObjectSetPropertyAtIndex func(uintptr, uint, uintptr)

// Set @property at @index on @value.
func (x *Value) ObjectSetPropertyAtIndex(IndexVar uint, PropertyVar *Value) {

	xValueObjectSetPropertyAtIndex(x.GoPointer(), IndexVar, PropertyVar.GoPointer())

}

var xValueToBoolean func(uintptr) bool

// Convert @value to a boolean.
func (x *Value) ToBoolean() bool {

	cret := xValueToBoolean(x.GoPointer())
	return cret
}

var xValueToDouble func(uintptr) float64

// Convert @value to a double.
func (x *Value) ToDouble() float64 {

	cret := xValueToDouble(x.GoPointer())
	return cret
}

var xValueToInt32 func(uintptr) int32

// Convert @value to a #gint32.
func (x *Value) ToInt32() int32 {

	cret := xValueToInt32(x.GoPointer())
	return cret
}

var xValueToJson func(uintptr, uint) string

// Create a JSON string of @value serialization. If @indent is 0, the resulting JSON will
// not contain newlines. The size of the indent is clamped to 10 spaces.
func (x *Value) ToJson(IndentVar uint) string {

	cret := xValueToJson(x.GoPointer(), IndentVar)
	return cret
}

var xValueToString func(uintptr) string

// Convert @value to a string. Use jsc_value_to_string_as_bytes() instead, if you need to
// handle strings containing null characters.
func (x *Value) ToString() string {

	cret := xValueToString(x.GoPointer())
	return cret
}

var xValueToStringAsBytes func(uintptr) *glib.Bytes

// Convert @value to a string and return the results as #GBytes. This is needed
// to handle strings with null characters.
func (x *Value) ToStringAsBytes() *glib.Bytes {

	cret := xValueToStringAsBytes(x.GoPointer())
	return cret
}

var xValueTypedArrayGetBuffer func(uintptr) uintptr

// Obtain the %ArrayBuffer for the memory region of the typed array elements.
func (x *Value) TypedArrayGetBuffer() *Value {
	var cls *Value

	cret := xValueTypedArrayGetBuffer(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &Value{}
	cls.Ptr = cret
	return cls
}

var xValueTypedArrayGetData func(uintptr, *uint) uintptr

// Obtains a pointer to the memory region that holds the elements of the typed
// array; modifications done to them will be visible to JavaScript code. If
// @length is not %NULL, the number of elements contained in the typed array
// are also stored in the pointed location.
//
// The returned pointer needs to be casted to the appropriate type (see
// #JSCTypedArrayType), and has the `offset` over the underlying array
// buffer data appliedâ€”that is, points to the first element of the typed
// array:
//
// |[&lt;!-- language="C" --&gt;
// if (jsc_value_typed_array_get_type(value) != JSC_TYPED_ARRAY_UINT32)
//
//	g_error ("Only arrays of uint32_t are supported");
//
// gsize count = 0;
// uint32_t *elements = jsc_value_typed_array_get_contents (value, &amp;count);
// for (gsize i = 0; i &lt; count; i++)
//
//	g_print ("index %zu, value %" PRIu32 "\n", i, elements[i]);
//
// ]|
//
// Note that the pointer returned by this function is not guaranteed to remain
// the same after calls to other JSC API functions. See
// jsc_value_array_buffer_get_data() for details.
func (x *Value) TypedArrayGetData(LengthVar *uint) uintptr {

	cret := xValueTypedArrayGetData(x.GoPointer(), LengthVar)
	return cret
}

var xValueTypedArrayGetLength func(uintptr) uint

// Gets the number of elements in a typed array.
func (x *Value) TypedArrayGetLength() uint {

	cret := xValueTypedArrayGetLength(x.GoPointer())
	return cret
}

var xValueTypedArrayGetOffset func(uintptr) uint

// Gets the offset over the underlying array buffer data.
func (x *Value) TypedArrayGetOffset() uint {

	cret := xValueTypedArrayGetOffset(x.GoPointer())
	return cret
}

var xValueTypedArrayGetSize func(uintptr) uint

// Gets the size of a typed array.
func (x *Value) TypedArrayGetSize() uint {

	cret := xValueTypedArrayGetSize(x.GoPointer())
	return cret
}

var xValueTypedArrayGetType func(uintptr) TypedArrayType

// Gets the type of elements contained in a typed array.
func (x *Value) TypedArrayGetType() TypedArrayType {

	cret := xValueTypedArrayGetType(x.GoPointer())
	return cret
}

func (c *Value) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *Value) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

func init() {
	core.SetPackageName("JAVASCRIPTCORE", "javascriptcoregtk-6.0")
	core.SetSharedLibraries("JAVASCRIPTCORE", []string{"libjavascriptcoregtk-6.0.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("JAVASCRIPTCORE") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xValueGLibType, libs, "jsc_value_get_type")

	core.PuregoSafeRegister(&xNewValueArray, libs, "jsc_value_new_array")
	core.PuregoSafeRegister(&xNewValueArrayBuffer, libs, "jsc_value_new_array_buffer")
	core.PuregoSafeRegister(&xNewValueArrayFromGarray, libs, "jsc_value_new_array_from_garray")
	core.PuregoSafeRegister(&xNewValueArrayFromStrv, libs, "jsc_value_new_array_from_strv")
	core.PuregoSafeRegister(&xNewValueBoolean, libs, "jsc_value_new_boolean")
	core.PuregoSafeRegister(&xNewValueFromJson, libs, "jsc_value_new_from_json")
	core.PuregoSafeRegister(&xNewValueFunction, libs, "jsc_value_new_function")
	core.PuregoSafeRegister(&xNewValueFunctionVariadic, libs, "jsc_value_new_function_variadic")
	core.PuregoSafeRegister(&xNewValueFunctionv, libs, "jsc_value_new_functionv")
	core.PuregoSafeRegister(&xNewValueNull, libs, "jsc_value_new_null")
	core.PuregoSafeRegister(&xNewValueNumber, libs, "jsc_value_new_number")
	core.PuregoSafeRegister(&xNewValueObject, libs, "jsc_value_new_object")
	core.PuregoSafeRegister(&xNewValuePromise, libs, "jsc_value_new_promise")
	core.PuregoSafeRegister(&xNewValueString, libs, "jsc_value_new_string")
	core.PuregoSafeRegister(&xNewValueStringFromBytes, libs, "jsc_value_new_string_from_bytes")
	core.PuregoSafeRegister(&xNewValueTypedArray, libs, "jsc_value_new_typed_array")
	core.PuregoSafeRegister(&xNewValueUndefined, libs, "jsc_value_new_undefined")

	core.PuregoSafeRegister(&xValueArrayBufferGetData, libs, "jsc_value_array_buffer_get_data")
	core.PuregoSafeRegister(&xValueArrayBufferGetSize, libs, "jsc_value_array_buffer_get_size")
	core.PuregoSafeRegister(&xValueConstructorCall, libs, "jsc_value_constructor_call")
	core.PuregoSafeRegister(&xValueConstructorCallv, libs, "jsc_value_constructor_callv")
	core.PuregoSafeRegister(&xValueFunctionCall, libs, "jsc_value_function_call")
	core.PuregoSafeRegister(&xValueFunctionCallv, libs, "jsc_value_function_callv")
	core.PuregoSafeRegister(&xValueGetContext, libs, "jsc_value_get_context")
	core.PuregoSafeRegister(&xValueIsArray, libs, "jsc_value_is_array")
	core.PuregoSafeRegister(&xValueIsArrayBuffer, libs, "jsc_value_is_array_buffer")
	core.PuregoSafeRegister(&xValueIsBoolean, libs, "jsc_value_is_boolean")
	core.PuregoSafeRegister(&xValueIsConstructor, libs, "jsc_value_is_constructor")
	core.PuregoSafeRegister(&xValueIsFunction, libs, "jsc_value_is_function")
	core.PuregoSafeRegister(&xValueIsNull, libs, "jsc_value_is_null")
	core.PuregoSafeRegister(&xValueIsNumber, libs, "jsc_value_is_number")
	core.PuregoSafeRegister(&xValueIsObject, libs, "jsc_value_is_object")
	core.PuregoSafeRegister(&xValueIsString, libs, "jsc_value_is_string")
	core.PuregoSafeRegister(&xValueIsTypedArray, libs, "jsc_value_is_typed_array")
	core.PuregoSafeRegister(&xValueIsUndefined, libs, "jsc_value_is_undefined")
	core.PuregoSafeRegister(&xValueNewTypedArrayWithBuffer, libs, "jsc_value_new_typed_array_with_buffer")
	core.PuregoSafeRegister(&xValueObjectDefinePropertyAccessor, libs, "jsc_value_object_define_property_accessor")
	core.PuregoSafeRegister(&xValueObjectDefinePropertyData, libs, "jsc_value_object_define_property_data")
	core.PuregoSafeRegister(&xValueObjectDeleteProperty, libs, "jsc_value_object_delete_property")
	core.PuregoSafeRegister(&xValueObjectEnumerateProperties, libs, "jsc_value_object_enumerate_properties")
	core.PuregoSafeRegister(&xValueObjectGetProperty, libs, "jsc_value_object_get_property")
	core.PuregoSafeRegister(&xValueObjectGetPropertyAtIndex, libs, "jsc_value_object_get_property_at_index")
	core.PuregoSafeRegister(&xValueObjectHasProperty, libs, "jsc_value_object_has_property")
	core.PuregoSafeRegister(&xValueObjectInvokeMethod, libs, "jsc_value_object_invoke_method")
	core.PuregoSafeRegister(&xValueObjectInvokeMethodv, libs, "jsc_value_object_invoke_methodv")
	core.PuregoSafeRegister(&xValueObjectIsInstanceOf, libs, "jsc_value_object_is_instance_of")
	core.PuregoSafeRegister(&xValueObjectSetProperty, libs, "jsc_value_object_set_property")
	core.PuregoSafeRegister(&xValueObjectSetPropertyAtIndex, libs, "jsc_value_object_set_property_at_index")
	core.PuregoSafeRegister(&xValueToBoolean, libs, "jsc_value_to_boolean")
	core.PuregoSafeRegister(&xValueToDouble, libs, "jsc_value_to_double")
	core.PuregoSafeRegister(&xValueToInt32, libs, "jsc_value_to_int32")
	core.PuregoSafeRegister(&xValueToJson, libs, "jsc_value_to_json")
	core.PuregoSafeRegister(&xValueToString, libs, "jsc_value_to_string")
	core.PuregoSafeRegister(&xValueToStringAsBytes, libs, "jsc_value_to_string_as_bytes")
	core.PuregoSafeRegister(&xValueTypedArrayGetBuffer, libs, "jsc_value_typed_array_get_buffer")
	core.PuregoSafeRegister(&xValueTypedArrayGetData, libs, "jsc_value_typed_array_get_data")
	core.PuregoSafeRegister(&xValueTypedArrayGetLength, libs, "jsc_value_typed_array_get_length")
	core.PuregoSafeRegister(&xValueTypedArrayGetOffset, libs, "jsc_value_typed_array_get_offset")
	core.PuregoSafeRegister(&xValueTypedArrayGetSize, libs, "jsc_value_typed_array_get_size")
	core.PuregoSafeRegister(&xValueTypedArrayGetType, libs, "jsc_value_typed_array_get_type")

}
