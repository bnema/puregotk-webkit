// Package javascriptcore was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package javascriptcore

import (
	"runtime"
	"structs"
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
)

// The type of delete_property in #JSCClassVTable. This is only required when you need to handle
// external properties not added to the prototype.
type ClassDeletePropertyFunction func(uintptr, uintptr, uintptr, string) bool

// The type of enumerate_properties in #JSCClassVTable. This is only required when you need to handle
// external properties not added to the prototype.
type ClassEnumeratePropertiesFunction func(uintptr, uintptr, uintptr) []string

// The type of get_property in #JSCClassVTable. This is only required when you need to handle
// external properties not added to the prototype.
type ClassGetPropertyFunction func(uintptr, uintptr, uintptr, string) uintptr

// The type of has_property in #JSCClassVTable. This is only required when you need to handle
// external properties not added to the prototype.
type ClassHasPropertyFunction func(uintptr, uintptr, uintptr, string) bool

// The type of set_property in #JSCClassVTable. This is only required when you need to handle
// external properties not added to the prototype.
type ClassSetPropertyFunction func(uintptr, uintptr, uintptr, string, uintptr) bool

type ClassClass struct {
	_ structs.HostLayout

	ParentClass gobject.ObjectClass
}

func (x *ClassClass) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// Virtual table for a JSCClass. This can be optionally used when registering a #JSCClass in a #JSCContext
// to provide a custom implementation for the class. All virtual functions are optional and can be set to
// %NULL to fallback to the default implementation.
type ClassVTable struct {
	_ structs.HostLayout

	GetProperty ClassGetPropertyFunction

	SetProperty ClassSetPropertyFunction

	HasProperty ClassHasPropertyFunction

	DeleteProperty ClassDeletePropertyFunction

	EnumerateProperties ClassEnumeratePropertiesFunction

	xJscReserved0 uintptr

	xJscReserved1 uintptr

	xJscReserved2 uintptr

	xJscReserved3 uintptr

	xJscReserved4 uintptr

	xJscReserved5 uintptr

	xJscReserved6 uintptr

	xJscReserved7 uintptr
}

func (x *ClassVTable) GoPointer() uintptr {
	return uintptr(unsafe.Pointer(x))
}

// OverrideJscReserved0 sets the "_jsc_reserved0" callback function.
func (x *ClassVTable) OverrideJscReserved0(cb func()) {
	if cb == nil {
		x.xJscReserved0 = 0
	} else {
		x.xJscReserved0 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetJscReserved0 gets the "_jsc_reserved0" callback function.
func (x *ClassVTable) GetJscReserved0() func() {
	if x.xJscReserved0 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xJscReserved0)
	return func() {
		rawCallback()
	}
}

// OverrideJscReserved1 sets the "_jsc_reserved1" callback function.
func (x *ClassVTable) OverrideJscReserved1(cb func()) {
	if cb == nil {
		x.xJscReserved1 = 0
	} else {
		x.xJscReserved1 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetJscReserved1 gets the "_jsc_reserved1" callback function.
func (x *ClassVTable) GetJscReserved1() func() {
	if x.xJscReserved1 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xJscReserved1)
	return func() {
		rawCallback()
	}
}

// OverrideJscReserved2 sets the "_jsc_reserved2" callback function.
func (x *ClassVTable) OverrideJscReserved2(cb func()) {
	if cb == nil {
		x.xJscReserved2 = 0
	} else {
		x.xJscReserved2 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetJscReserved2 gets the "_jsc_reserved2" callback function.
func (x *ClassVTable) GetJscReserved2() func() {
	if x.xJscReserved2 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xJscReserved2)
	return func() {
		rawCallback()
	}
}

// OverrideJscReserved3 sets the "_jsc_reserved3" callback function.
func (x *ClassVTable) OverrideJscReserved3(cb func()) {
	if cb == nil {
		x.xJscReserved3 = 0
	} else {
		x.xJscReserved3 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetJscReserved3 gets the "_jsc_reserved3" callback function.
func (x *ClassVTable) GetJscReserved3() func() {
	if x.xJscReserved3 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xJscReserved3)
	return func() {
		rawCallback()
	}
}

// OverrideJscReserved4 sets the "_jsc_reserved4" callback function.
func (x *ClassVTable) OverrideJscReserved4(cb func()) {
	if cb == nil {
		x.xJscReserved4 = 0
	} else {
		x.xJscReserved4 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetJscReserved4 gets the "_jsc_reserved4" callback function.
func (x *ClassVTable) GetJscReserved4() func() {
	if x.xJscReserved4 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xJscReserved4)
	return func() {
		rawCallback()
	}
}

// OverrideJscReserved5 sets the "_jsc_reserved5" callback function.
func (x *ClassVTable) OverrideJscReserved5(cb func()) {
	if cb == nil {
		x.xJscReserved5 = 0
	} else {
		x.xJscReserved5 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetJscReserved5 gets the "_jsc_reserved5" callback function.
func (x *ClassVTable) GetJscReserved5() func() {
	if x.xJscReserved5 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xJscReserved5)
	return func() {
		rawCallback()
	}
}

// OverrideJscReserved6 sets the "_jsc_reserved6" callback function.
func (x *ClassVTable) OverrideJscReserved6(cb func()) {
	if cb == nil {
		x.xJscReserved6 = 0
	} else {
		x.xJscReserved6 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetJscReserved6 gets the "_jsc_reserved6" callback function.
func (x *ClassVTable) GetJscReserved6() func() {
	if x.xJscReserved6 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xJscReserved6)
	return func() {
		rawCallback()
	}
}

// OverrideJscReserved7 sets the "_jsc_reserved7" callback function.
func (x *ClassVTable) OverrideJscReserved7(cb func()) {
	if cb == nil {
		x.xJscReserved7 = 0
	} else {
		x.xJscReserved7 = purego.NewCallback(func() {
			cb()
		})
	}
}

// GetJscReserved7 gets the "_jsc_reserved7" callback function.
func (x *ClassVTable) GetJscReserved7() func() {
	if x.xJscReserved7 == 0 {
		return nil
	}
	var rawCallback func()
	purego.RegisterFunc(&rawCallback, x.xJscReserved7)
	return func() {
		rawCallback()
	}
}

// A JSSClass represents a custom JavaScript class registered by the user in a #JSCContext.
// It allows to create new JavaScripts objects whose instances are created by the user using
// this API.
// It's possible to add constructors, properties and methods for a JSSClass by providing
// #GCallback&lt;!-- --&gt;s to implement them.
type Class struct {
	gobject.Object
}

var xClassGLibType func() types.GType

func ClassGLibType() types.GType {
	return xClassGLibType()
}

func ClassNewFromInternalPtr(ptr uintptr) *Class {
	cls := &Class{}
	cls.Ptr = ptr
	return cls
}

var xClassAddConstructor func(uintptr, uintptr, uintptr, uintptr, uintptr, types.GType, uint, ...interface{}) uintptr

// Add a constructor to @jsc_class. If @name is %NULL, the class name will be used. When &lt;function&gt;new&lt;/function&gt;
// is used with the constructor or jsc_value_constructor_call() is called, @callback is invoked receiving the
// parameters and @user_data as the last parameter. When the constructor object is cleared in the #JSCClass context,
// @destroy_notify is called with @user_data as parameter.
//
// This function creates the constructor, which needs to be added to an object as a property to be able to use it. Use
// jsc_context_set_value() to make the constructor available in the global object.
//
// Note that the value returned by @callback is adopted by @jsc_class, and the #GDestroyNotify passed to
// jsc_context_register_class() is responsible for disposing of it.
func (x *Class) AddConstructor(NameVar *string, CallbackVar *gobject.Callback, UserDataVar uintptr, DestroyNotifyVar *glib.DestroyNotify, ReturnTypeVar types.GType, NParamsVar uint, varArgs ...interface{}) *Value {
	var cls *Value

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func() {
				cbFn := *CallbackVar
				cbFn()
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(CallbackVarPtr, CallbackVarRef)
		}
	}

	var DestroyNotifyVarRef uintptr
	if DestroyNotifyVar != nil {
		DestroyNotifyVarPtr := uintptr(unsafe.Pointer(DestroyNotifyVar))
		if cbRefPtr, ok := glib.GetCallback(DestroyNotifyVarPtr); ok {
			DestroyNotifyVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *DestroyNotifyVar
				cbFn(arg0)
			}
			DestroyNotifyVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(DestroyNotifyVarPtr, DestroyNotifyVarRef)
		}
	}

	NameVarPtr, NameVarBytes := core.NullableStringToPtr(NameVar)

	cret := xClassAddConstructor(x.GoPointer(), NameVarPtr, CallbackVarRef, UserDataVar, DestroyNotifyVarRef, ReturnTypeVar, NParamsVar, varArgs...)

	runtime.KeepAlive(NameVarBytes)

	if cret == 0 {
		return nil
	}
	cls = &Value{}
	cls.Ptr = cret
	return cls
}

var xClassAddConstructorVariadic func(uintptr, uintptr, uintptr, uintptr, uintptr, types.GType) uintptr

// Add a constructor to @jsc_class. If @name is %NULL, the class name will be used. When &lt;function&gt;new&lt;/function&gt;
// is used with the constructor or jsc_value_constructor_call() is called, @callback is invoked receiving
// a #GPtrArray of #JSCValue&lt;!-- --&gt;s as arguments and @user_data as the last parameter. When the constructor object
// is cleared in the #JSCClass context, @destroy_notify is called with @user_data as parameter.
//
// This function creates the constructor, which needs to be added to an object as a property to be able to use it. Use
// jsc_context_set_value() to make the constructor available in the global object.
//
// Note that the value returned by @callback is adopted by @jsc_class, and the #GDestroyNotify passed to
// jsc_context_register_class() is responsible for disposing of it.
func (x *Class) AddConstructorVariadic(NameVar *string, CallbackVar *gobject.Callback, UserDataVar uintptr, DestroyNotifyVar *glib.DestroyNotify, ReturnTypeVar types.GType) *Value {
	var cls *Value

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func() {
				cbFn := *CallbackVar
				cbFn()
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(CallbackVarPtr, CallbackVarRef)
		}
	}

	var DestroyNotifyVarRef uintptr
	if DestroyNotifyVar != nil {
		DestroyNotifyVarPtr := uintptr(unsafe.Pointer(DestroyNotifyVar))
		if cbRefPtr, ok := glib.GetCallback(DestroyNotifyVarPtr); ok {
			DestroyNotifyVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *DestroyNotifyVar
				cbFn(arg0)
			}
			DestroyNotifyVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(DestroyNotifyVarPtr, DestroyNotifyVarRef)
		}
	}

	NameVarPtr, NameVarBytes := core.NullableStringToPtr(NameVar)

	cret := xClassAddConstructorVariadic(x.GoPointer(), NameVarPtr, CallbackVarRef, UserDataVar, DestroyNotifyVarRef, ReturnTypeVar)

	runtime.KeepAlive(NameVarBytes)

	if cret == 0 {
		return nil
	}
	cls = &Value{}
	cls.Ptr = cret
	return cls
}

var xClassAddConstructorv func(uintptr, uintptr, uintptr, uintptr, uintptr, types.GType, uint, []types.GType) uintptr

// Add a constructor to @jsc_class. If @name is %NULL, the class name will be used. When &lt;function&gt;new&lt;/function&gt;
// is used with the constructor or jsc_value_constructor_call() is called, @callback is invoked receiving the
// parameters and @user_data as the last parameter. When the constructor object is cleared in the #JSCClass context,
// @destroy_notify is called with @user_data as parameter.
//
// This function creates the constructor, which needs to be added to an object as a property to be able to use it. Use
// jsc_context_set_value() to make the constructor available in the global object.
//
// Note that the value returned by @callback is adopted by @jsc_class, and the #GDestroyNotify passed to
// jsc_context_register_class() is responsible for disposing of it.
func (x *Class) AddConstructorv(NameVar *string, CallbackVar *gobject.Callback, UserDataVar uintptr, DestroyNotifyVar *glib.DestroyNotify, ReturnTypeVar types.GType, NParametersVar uint, ParameterTypesVar []types.GType) *Value {
	var cls *Value

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func() {
				cbFn := *CallbackVar
				cbFn()
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(CallbackVarPtr, CallbackVarRef)
		}
	}

	var DestroyNotifyVarRef uintptr
	if DestroyNotifyVar != nil {
		DestroyNotifyVarPtr := uintptr(unsafe.Pointer(DestroyNotifyVar))
		if cbRefPtr, ok := glib.GetCallback(DestroyNotifyVarPtr); ok {
			DestroyNotifyVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *DestroyNotifyVar
				cbFn(arg0)
			}
			DestroyNotifyVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(DestroyNotifyVarPtr, DestroyNotifyVarRef)
		}
	}

	NameVarPtr, NameVarBytes := core.NullableStringToPtr(NameVar)

	cret := xClassAddConstructorv(x.GoPointer(), NameVarPtr, CallbackVarRef, UserDataVar, DestroyNotifyVarRef, ReturnTypeVar, NParametersVar, ParameterTypesVar)

	runtime.KeepAlive(NameVarBytes)

	if cret == 0 {
		return nil
	}
	cls = &Value{}
	cls.Ptr = cret
	return cls
}

var xClassAddMethod func(uintptr, string, uintptr, uintptr, uintptr, types.GType, uint, ...interface{})

// Add method with @name to @jsc_class. When the method is called by JavaScript or jsc_value_object_invoke_method(),
// @callback is called receiving the class instance as first parameter, followed by the method parameters and then
// @user_data as last parameter. When the method is cleared in the #JSCClass context, @destroy_notify is called with
// @user_data as parameter.
//
// Note that the value returned by @callback must be transfer full. In case of non-refcounted boxed types, you should use
// %G_TYPE_POINTER instead of the actual boxed #GType to ensure that the instance owned by #JSCClass is used.
// If you really want to return a new copy of the boxed type, use #JSC_TYPE_VALUE and return a #JSCValue created
// with jsc_value_new_object() that receives the copy as the instance parameter.
func (x *Class) AddMethod(NameVar string, CallbackVar *gobject.Callback, UserDataVar uintptr, DestroyNotifyVar *glib.DestroyNotify, ReturnTypeVar types.GType, NParamsVar uint, varArgs ...interface{}) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func() {
				cbFn := *CallbackVar
				cbFn()
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(CallbackVarPtr, CallbackVarRef)
		}
	}

	var DestroyNotifyVarRef uintptr
	if DestroyNotifyVar != nil {
		DestroyNotifyVarPtr := uintptr(unsafe.Pointer(DestroyNotifyVar))
		if cbRefPtr, ok := glib.GetCallback(DestroyNotifyVarPtr); ok {
			DestroyNotifyVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *DestroyNotifyVar
				cbFn(arg0)
			}
			DestroyNotifyVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(DestroyNotifyVarPtr, DestroyNotifyVarRef)
		}
	}

	xClassAddMethod(x.GoPointer(), NameVar, CallbackVarRef, UserDataVar, DestroyNotifyVarRef, ReturnTypeVar, NParamsVar, varArgs...)

}

var xClassAddMethodVariadic func(uintptr, string, uintptr, uintptr, uintptr, types.GType)

// Add method with @name to @jsc_class. When the method is called by JavaScript or jsc_value_object_invoke_method(),
// @callback is called receiving the class instance as first parameter, followed by a #GPtrArray of #JSCValue&lt;!-- --&gt;s
// with the method arguments and then @user_data as last parameter. When the method is cleared in the #JSCClass context,
// @destroy_notify is called with @user_data as parameter.
//
// Note that the value returned by @callback must be transfer full. In case of non-refcounted boxed types, you should use
// %G_TYPE_POINTER instead of the actual boxed #GType to ensure that the instance owned by #JSCClass is used.
// If you really want to return a new copy of the boxed type, use #JSC_TYPE_VALUE and return a #JSCValue created
// with jsc_value_new_object() that receives the copy as the instance parameter.
func (x *Class) AddMethodVariadic(NameVar string, CallbackVar *gobject.Callback, UserDataVar uintptr, DestroyNotifyVar *glib.DestroyNotify, ReturnTypeVar types.GType) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func() {
				cbFn := *CallbackVar
				cbFn()
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(CallbackVarPtr, CallbackVarRef)
		}
	}

	var DestroyNotifyVarRef uintptr
	if DestroyNotifyVar != nil {
		DestroyNotifyVarPtr := uintptr(unsafe.Pointer(DestroyNotifyVar))
		if cbRefPtr, ok := glib.GetCallback(DestroyNotifyVarPtr); ok {
			DestroyNotifyVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *DestroyNotifyVar
				cbFn(arg0)
			}
			DestroyNotifyVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(DestroyNotifyVarPtr, DestroyNotifyVarRef)
		}
	}

	xClassAddMethodVariadic(x.GoPointer(), NameVar, CallbackVarRef, UserDataVar, DestroyNotifyVarRef, ReturnTypeVar)

}

var xClassAddMethodv func(uintptr, string, uintptr, uintptr, uintptr, types.GType, uint, []types.GType)

// Add method with @name to @jsc_class. When the method is called by JavaScript or jsc_value_object_invoke_method(),
// @callback is called receiving the class instance as first parameter, followed by the method parameters and then
// @user_data as last parameter. When the method is cleared in the #JSCClass context, @destroy_notify is called with
// @user_data as parameter.
//
// Note that the value returned by @callback must be transfer full. In case of non-refcounted boxed types, you should use
// %G_TYPE_POINTER instead of the actual boxed #GType to ensure that the instance owned by #JSCClass is used.
// If you really want to return a new copy of the boxed type, use #JSC_TYPE_VALUE and return a #JSCValue created
// with jsc_value_new_object() that receives the copy as the instance parameter.
func (x *Class) AddMethodv(NameVar string, CallbackVar *gobject.Callback, UserDataVar uintptr, DestroyNotifyVar *glib.DestroyNotify, ReturnTypeVar types.GType, NParametersVar uint, ParameterTypesVar []types.GType) {

	var CallbackVarRef uintptr
	if CallbackVar != nil {
		CallbackVarPtr := uintptr(unsafe.Pointer(CallbackVar))
		if cbRefPtr, ok := glib.GetCallback(CallbackVarPtr); ok {
			CallbackVarRef = cbRefPtr
		} else {
			fcb := func() {
				cbFn := *CallbackVar
				cbFn()
			}
			CallbackVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(CallbackVarPtr, CallbackVarRef)
		}
	}

	var DestroyNotifyVarRef uintptr
	if DestroyNotifyVar != nil {
		DestroyNotifyVarPtr := uintptr(unsafe.Pointer(DestroyNotifyVar))
		if cbRefPtr, ok := glib.GetCallback(DestroyNotifyVarPtr); ok {
			DestroyNotifyVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *DestroyNotifyVar
				cbFn(arg0)
			}
			DestroyNotifyVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(DestroyNotifyVarPtr, DestroyNotifyVarRef)
		}
	}

	xClassAddMethodv(x.GoPointer(), NameVar, CallbackVarRef, UserDataVar, DestroyNotifyVarRef, ReturnTypeVar, NParametersVar, ParameterTypesVar)

}

var xClassAddProperty func(uintptr, string, types.GType, uintptr, uintptr, uintptr, uintptr)

// Add a property with @name to @jsc_class. When the property value needs to be getted, @getter is called
// receiving the the class instance as first parameter and @user_data as last parameter. When the property
// value needs to be set, @setter is called receiving the the class instance as first parameter, followed
// by the value to be set and then @user_data as the last parameter. When the property is cleared in the
// #JSCClass context, @destroy_notify is called with @user_data as parameter.
//
// Note that the value returned by @getter must be transfer full. In case of non-refcounted boxed types, you should use
// %G_TYPE_POINTER instead of the actual boxed #GType to ensure that the instance owned by #JSCClass is used.
// If you really want to return a new copy of the boxed type, use #JSC_TYPE_VALUE and return a #JSCValue created
// with jsc_value_new_object() that receives the copy as the instance parameter.
func (x *Class) AddProperty(NameVar string, PropertyTypeVar types.GType, GetterVar *gobject.Callback, SetterVar *gobject.Callback, UserDataVar uintptr, DestroyNotifyVar *glib.DestroyNotify) {

	var GetterVarRef uintptr
	if GetterVar != nil {
		GetterVarPtr := uintptr(unsafe.Pointer(GetterVar))
		if cbRefPtr, ok := glib.GetCallback(GetterVarPtr); ok {
			GetterVarRef = cbRefPtr
		} else {
			fcb := func() {
				cbFn := *GetterVar
				cbFn()
			}
			GetterVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(GetterVarPtr, GetterVarRef)
		}
	}

	var SetterVarRef uintptr
	if SetterVar != nil {
		SetterVarPtr := uintptr(unsafe.Pointer(SetterVar))
		if cbRefPtr, ok := glib.GetCallback(SetterVarPtr); ok {
			SetterVarRef = cbRefPtr
		} else {
			fcb := func() {
				cbFn := *SetterVar
				cbFn()
			}
			SetterVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(SetterVarPtr, SetterVarRef)
		}
	}

	var DestroyNotifyVarRef uintptr
	if DestroyNotifyVar != nil {
		DestroyNotifyVarPtr := uintptr(unsafe.Pointer(DestroyNotifyVar))
		if cbRefPtr, ok := glib.GetCallback(DestroyNotifyVarPtr); ok {
			DestroyNotifyVarRef = cbRefPtr
		} else {
			fcb := func(arg0 uintptr) {
				cbFn := *DestroyNotifyVar
				cbFn(arg0)
			}
			DestroyNotifyVarRef = purego.NewCallback(fcb)
			glib.SaveCallback(DestroyNotifyVarPtr, DestroyNotifyVarRef)
		}
	}

	xClassAddProperty(x.GoPointer(), NameVar, PropertyTypeVar, GetterVarRef, SetterVarRef, UserDataVar, DestroyNotifyVarRef)

}

var xClassGetName func(uintptr) string

// Get the class name of @jsc_class
func (x *Class) GetName() string {

	cret := xClassGetName(x.GoPointer())

	return cret
}

var xClassGetParent func(uintptr) uintptr

// Get the parent class of @jsc_class
func (x *Class) GetParent() *Class {
	var cls *Class

	cret := xClassGetParent(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &Class{}
	cls.Ptr = cret
	return cls
}

func (c *Class) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *Class) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyName sets the "name" property.
// The name of the class.
func (x *Class) SetPropertyName(value string) {
	var v gobject.Value
	v.Init(gobject.TypeStringVal)
	v.SetString(&value)
	x.SetProperty("name", &v)
}

// GetPropertyName gets the "name" property.
// The name of the class.
func (x *Class) GetPropertyName() string {
	var v gobject.Value
	x.GetProperty("name", &v)
	return v.GetString()
}

func init() {
	core.SetPackageName("JAVASCRIPTCORE", "javascriptcoregtk-6.0")
	core.SetSharedLibraries("JAVASCRIPTCORE", []string{"libjavascriptcoregtk-6.0.so.1"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("JAVASCRIPTCORE") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xClassGLibType, libs, "jsc_class_get_type")

	core.PuregoSafeRegister(&xClassAddConstructor, libs, "jsc_class_add_constructor")
	core.PuregoSafeRegister(&xClassAddConstructorVariadic, libs, "jsc_class_add_constructor_variadic")
	core.PuregoSafeRegister(&xClassAddConstructorv, libs, "jsc_class_add_constructorv")
	core.PuregoSafeRegister(&xClassAddMethod, libs, "jsc_class_add_method")
	core.PuregoSafeRegister(&xClassAddMethodVariadic, libs, "jsc_class_add_method_variadic")
	core.PuregoSafeRegister(&xClassAddMethodv, libs, "jsc_class_add_methodv")
	core.PuregoSafeRegister(&xClassAddProperty, libs, "jsc_class_add_property")
	core.PuregoSafeRegister(&xClassGetName, libs, "jsc_class_get_name")
	core.PuregoSafeRegister(&xClassGetParent, libs, "jsc_class_get_parent")

}
